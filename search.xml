<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[模拟事件]]></title>
    <url>%2F2019%2F08%2F10%2Fweb%2Fjs%2F%E5%9F%BA%E7%A1%80%2F%E6%A8%A1%E6%8B%9F%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[事件，就是网页中某个特别值得关注的瞬间。那什么是模拟事件？高程三里的解释就是使用 JavaScript 在任意时刻来触发特定的事件，而此时的事件就如同浏览器创建的事件一样。 创建 初始化 触发 createEvent() 在 document 对象上使用 createEvent() 方法创建 event 对象。方法接收一个参数，即表示要创建的事件类型的字符串。事件类型可能包括”UIEvents”, “MouseEvents”, “MutationEvents”, 或者 “HTMLEvents”。详细可以看一下MDN。 initEvent() 初始化event对象。接受三个参数type（事件的类型）, bubbles（事件是否应该向上冒泡）, cancelable（默认事件是否可以被取消）。不同的事件类型方法名不同可能不一样MouseEvents的initMouseEvent()，CustomEvent的initCustomEvent()等，传的参数个数不一样，初始化的信息不一样，但是前三个参数是一样的。 dispatchEvent() 所有支持事件的DOM 节点都支持这个方法。 传入一个参数，即表示要触发事件的 event 对象。我们来模拟一个鼠标点击事件： 12345678910111213var btn = document.getElementById("myBtn");// 创建事件对象var event = document.createEvent("MouseEvents");// 初始化事件对象 必须在dispatchEvent之前 这里设置的type就是监听时的typeevent.initMouseEvent("click", true, true, document.defaultView, 0, 0, 0, 0, 0,false, false, false, false, 0, null); // 参数的设置请参考 MDNbtn.addEventListener('click',function(e)&#123; console.log(e) console.log('btn onclick');&#125;)// 触发事件btn.dispatchEvent(event); // 触发事件，该事件就跻身“官方事件”之列了，因而能够照样冒泡并引发相应事件处理程序的执行。btn.click() // click() 也可以达到同样的效果 不过事件对象的信息却不能模拟出来了 使用构造函数来创建和初始化我们MDN上会发现createEvent()和initEvent()等方法已经被废弃了，推荐使用event constructors （事件构造函数）来替代。MDN上也有一些例子，下面是一个自定义事件例子： 1234567891011// 要向事件对象添加更多数据，可以使用 CustomEvent，detail 属性可用于传递自定义数据CustomEvent 接口可以为 event 对象添加更多的数据。// 实例化事件对象var event = new CustomEvent('custom', &#123; detail: 'custom event'&#125;);// 监听事件document.addEventListener('custom', function (e) &#123; console.log(e, e.detail)&#125;, false);// 触发事件document.dispatchEvent(event); 修改一开始的模拟鼠标事件： 123456789101112131415161718192021222324var btn = document.getElementById("myBtn");// 创建事件对象var event = new MouseEvent("click", &#123; bubbles: true, cancelable: true, view: document.defaultView, // 就是window， document.defaultView 在浏览器中，该属性返回当前 document 对象所关联的 window 对象 detail: 0, screenX: 0, screenY: 0, clientX: 0, clientY: 0, ctrlKey: false, altKey: false, shiftKey: false, metaKey: false, button: 0, relatedTarget: null&#125;);btn.addEventListener('click',function(e)&#123; console.log(e) console.log('btn onclick');&#125;)btn.dispatchEvent(event); 在 IE8 及之前版本中模拟事件与在 DOM 中模拟事件的思路相似：先创建 event 对象，然后为其指定相应的信息，然后再使用该对象来触发事件。document.createEventObject() 方法可以在 IE 中创建 event 对象。这个方法不接受参数，结果会返回一个通用的 event 对象。调用 fireEvent() 方法，这个方法接受两个参数：事件处理程序的名称和 event 对象。 事件类型你会发现上面有鼠标事件MouseEvent，又有自定义事件CustomEvent，其实事件类型还有变动（mutation）事件MutationEvent、键盘事件KeyboardEvent等，它们都是继承了Event对象。 事件模式 EventEmitter这里只是简单提一下详细请参考资料。 开发中我们经常会使用EventEmitter，你会发现跟上面模拟事件非常相似。 高程三里有讲到事件是一种叫做观察者的设计模式，这是一种创建松散耦合代码的技术。，准确来说是发布订阅模式。浏览器中的事件模式算是订阅/发布模式的一种，不过它具有冒泡捕获特性。 参考链接：javascript中自定义事件和声明调用函数有什么区别？发布订阅模式，在工作中它的能量超乎你的想象]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数柯里化]]></title>
    <url>%2F2019%2F08%2F08%2Fweb%2Fjs%2F%E5%9F%BA%E7%A1%80%2F%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%2F</url>
    <content type="text"><![CDATA[函数柯里化，听起来就觉得很厉害的亚子。我之前很早就听说过，却没有真正的了解，找些文章看了一下，这里总结一下。 函数绑定bind在了解函数柯里化之前我们先了解一下bind()方法。ES5的Function.prototype.bind()方法会创建一个函数的实例，其 this 值会被绑 定到传给 bind() 函数的值（IE6-8不支持此方法）。 bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。 —— MDN 一个简单的 bind() 函数实现 （注意这里只是简单的实现了,跟原生的不一样，MDN上有更详细的Polyfill版本）： 123456789// 这里没有放到原型上 function bind(fn, context)&#123; return function()&#123; return fn.apply(context, arguments); &#125;;&#125;var testF = bind(function()&#123;console.log(this.a)&#125;,&#123;a:1&#125;)testF() 函数柯里化 curry与函数绑定紧密相关的主题是函数柯里化（function currying），函数柯里化的基本方法和函数绑定是一样的：使用一个闭包返回一个函数!!!。 curry 的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。（它用于创建已经设置好了一个或多个参数的函数。） 主要作用和特点：1. 参数复用；2. 提前返回；3. 延迟执行 通用方式柯里化函数通常由以下步骤动态创建：调用另一个函数并为它传入要柯里化的函数和必要参数。这里是高程三里的例子： 12345678910111213141516function curry(fn)&#123; var args = Array.prototype.slice.call(arguments, 1); return function()&#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return fn.apply(null, finalArgs); &#125;;&#125;function add(num1, num2)&#123; return num1 + num2;&#125;var curriedAdd = curry(add, 5);console.log(curriedAdd(3)); //8curriedAdd = curry(add);console.log(curriedAdd(3, 5)); //8 进阶方法进阶方法其实就是在通用方式上增加一些处理，上面add方法只有两个参数，但如果我有三个参数怎么办？ 我们可以在curry函数中加入对参数长度的判断： 1234567891011121314151617181920212223242526 function add(num1, num2, num3)&#123; return num1 + num2 + num3;&#125;function add(num1, num2, num3)&#123; return num1 + num2 + num3;&#125;function curry(fn)&#123; var args = Array.prototype.slice.call(arguments, 1); var argLength = fn.length return function()&#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); var fnArgsArr = finalArgs.slice() fnArgsArr.unshift(fn) if(finalArgs.length &lt; argLength)&#123; // return curry.call(this, fn, ...finalArgs); return curry.apply(this, fnArgsArr); &#125; else &#123; return fn.apply(null, finalArgs); &#125;; &#125;&#125;var curriedAdd = curry(add,6); console.log(curriedAdd(1)(1)); // 8curriedAdd = curry(add);console.log(curriedAdd(2,7)(6)); // 15 你可能会问n个参数的时候怎么办？这时候弄一个条件调用返回之前执行函数的结果就可以了（这也就是“延迟执行”）。 12345678910111213141516171819202122232425262728function curry(fn)&#123; var args = Array.prototype.slice.call(arguments, 1); var finalArgs = [] return function() &#123; var innerArgs = Array.prototype.slice.call(arguments); finalArgs = args.concat(innerArgs); if (arguments.length === 0) &#123; return fn.apply(null, finalArgs); // 没有参数的时候执行函数 &#125;else &#123; var fnArgsArr = finalArgs.slice() fnArgsArr.unshift(fn) return curry.apply(this, fnArgsArr); &#125; &#125;&#125;function add()&#123; var i=0; len = arguments.length; var num = 0 for (i; i&lt;len; i+=1) &#123; num += arguments[i]; &#125; return num&#125;var curriedAdd = curry(add,6); console.log(curriedAdd(1)(1)(1,2,3,4,5)());console.log(curriedAdd(1)());curriedAdd = curry(add);console.log(curriedAdd(2,7)(6)(3)()); bind()方法的柯里化函数柯里化函数绑定紧密相关的，原生的bind()方法就实现了柯里化（多了修改this的功能）。 所以上面函数绑定写的例子，扩展一下。 1234567891011121314151617181920212223// 直接用函数function bind(fn, context)&#123; var args = Array.prototype.slice.call(arguments, 2); // 这里 return function() &#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return fn.apply(context, finalArgs); &#125;;&#125;// 添加到原型Function.prototype.mybind = function(context) &#123; var self = this , args = Array.prototype.slice.call(arguments, 1); return function() &#123; return self.apply(context, args.concat(Array.prototype.slice.call(arguments))); &#125;&#125;;function testF(a, b) &#123; console.log(a + b)&#125;var testBind = testF.mybind(null, 1)testBind(2) 当你想除了 event 对象再额外给事件处理程序传递参数时，这非常有用。（但是要注意bind参数的个数，想要更灵活的使用就写一个闭包函数） 1234567function handleClick(name, e)&#123; console.log(name) console.log(e)&#125;var body = document.getElementsByTagName("body")[0]; // 为了显示效果直接绑定事件到body上body.addEventListener("click", handleClick.bind(null, "body")); 我们知道bind会使用一个闭包返回一个函数，所以我们可以用来解决一道经典的面试题： 12345for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function (i) &#123; console.log('bind', i) &#125;.bind(null, i), 1000);&#125; 参考链接：Function.prototype.bind()bind方法的javascript实现及函数柯里化 柯里化（curry）(推荐)JS中的柯里化(currying)从一道面试题认识函数柯里化柯里化与反柯里化前端之函数柯里化Currying]]></content>
  </entry>
  <entry>
    <title><![CDATA[节流throttle和防抖debounce]]></title>
    <url>%2F2019%2F08%2F05%2Fweb%2Fjs%2F%E5%9F%BA%E7%A1%80%2F%E8%8A%82%E6%B5%81throttle%E5%92%8C%E9%98%B2%E6%8A%96debounce%2F</url>
    <content type="text"><![CDATA[节流和防抖非常容易让人混淆，这里值得一提的高程三里函数节流这一节里讲的是防抖的并不是节流，我也被弄混淆了。这里有个demo，可以看区别。 区别 这里以lodash的debounce()和throttle()方法来区别： debounce(func, wait, options)：创建并返回函数的防反跳版本，将延迟函数的执行（真正的执行）在函数最后一次调用时刻的wait毫秒之后，对于必须在一些输入（多是一些用户操作）停止之后再执行的行为有帮助。将一个连续的调用归为一个，如果连续在wait毫秒内调用，最后只有最后一次会执行。（任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行） throttle(func, wait, options)：创建并返回一个像节流阀一样的函数，当重复调用函数的时候，最多每隔指定的wait毫秒调用一次该函数；不允许方法在每wait毫秒间执行超过一次，如果连续在wait毫秒内调用，最后执行会均匀分布在大约每wait一次。（指定时间间隔内只会执行一次任务） 对于lodash来说，throttle是调用debounce来实现的，throttle 和 debounce 最终都会都会调用 debounce 方法。_.throttle 方法只不过是多给 debounce 传了一个 options = {maxWait: $maxWait, leading: true, trailing: true}（leading马上执行一次调用 trailing执行最后一次延时调用），这个选项的意思是至少保证在每 maxWait 时间让 func 被调用 123window.addEventListener('mousemove', _.throttle(function()&#123;console.log('throttle')&#125;, 500, false));window.addEventListener('mousemove', _.debounce(function()&#123;console.log('maxWait debounce')&#125;, 500, &#123;maxWait: 500, leading: true, trailing: true&#125;), false);window.addEventListener('mousemove', _.debounce(function()&#123;console.log('debounce')&#125;, 500), false); debounce的简单实现1234567891011121314function debounce(func, delay) &#123; var timeout = null return function(e) &#123; clearTimeout(timeout) var context = this, args = arguments timeout = setTimeout(function()&#123; func.apply(context, args) &#125;,delay) &#125;&#125;function log() &#123; console.log('debounce')&#125;window.onmousemove = debounce(log, 300) throttle的简单实现1234567891011121314151617181920212223242526function throttle(fn, threshhold) &#123; var timeout var start = new Date var threshhold = threshhold || 160 return function () &#123; var context = this, args = arguments, curr = new Date() - 0 clearTimeout(timeout) if (curr - start &gt;= threshhold) &#123; // 时间间隔内执行一次 fn.apply(context, args) start = curr &#125; else &#123; // 最后一次的执行 timeout = setTimeout(function () &#123; fn.apply(context, args) &#125;, threshhold) &#125; &#125;&#125;function log() &#123; console.log('throttle')&#125;window.onscroll = throttle(log, 300) 使用场景 mouse move 时减少计算次数：debounce input 中输入文字自动发送 ajax 请求进行自动补全： debounce ajax 请求合并，不希望短时间内大量的请求被重复发送：debounce resize window 重新计算样式或布局：debounce 或 throttle scroll 时触发操作，如随动效果：throttle 对用户输入的验证，不想停止输入再进行验证，而是每n秒进行验证：throttle 参考链接：debounce与throttle区别throttle与debounce的区别JS throttle与debounce的区别the-difference-between-throttling-and-debouncing函数节流与函数防抖聊聊lodash的debounce实现]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元素大小 offset client scroll]]></title>
    <url>%2F2019%2F08%2F05%2Fweb%2Fjs%2F%E5%9F%BA%E7%A1%80%2F%E5%85%83%E7%B4%A0%E5%A4%A7%E5%B0%8F-offset-client-scroll%2F</url>
    <content type="text"><![CDATA[clientHeight、offsetHeight、offsetTop、scrollHeight、scrollTop等DOM的属性非常容易混乱，每次用到的时候都会找一文档，还有一大堆的兼容问题，最近看了一下红宝书这一部分的内容，这里复习记录一下。 窗口大小在了解DOM的元素大小之前，我们先来简单看一下window对象的innerWidth 、 innerHeight 、 outerWidth 和 outerHeight这几个属性。区别在JQuery里有着几个方法，也是非常容易让人混乱。 innerHeight 返回窗口的文档显示区的高度。 innerWidth 返回窗口的文档显示区的宽度。 outerHeight 返回一个窗口的外部高度，包括所有界面元素（如工具栏/滚动） outerWidth 返回窗口的外部宽度，包括所有的界面元素（如工具栏/滚动） 1234console.log(window.innerHeight)console.log(window.innerWidth)console.log(window.outerHeight)console.log(window.outerWidth) IE8 及更早版本没有提供取得当前浏览器窗口尺寸的属性；不过，它通过 DOM 提供了页面可见区域的相关信息。它用 document.documentElement 或 document.body （与 IE 的版本相关）的 clientWidth 和 clientHeight 属性作为替代。 混杂模式下，需要用 document.body 代替 document.documentElement 元素大小偏移量（offset dimension）包括元素在屏幕上占用的所有可见的空间。元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小（注意，不包括外边距）。 offsetHeight — 元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上边框高度和下边框高度。(height + borderWidth + paddingLeft/Right + scrollbar) offsetWidth — 元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂直滚动条的宽度、左边框宽度和右边框宽度。(width + borderWidth + paddingTop/Bottom + scrollbar) offsetLeft — 元素的左外边框至包含元素的左内边框之间的像素距离。 offsetTop — 元素的上外边框至包含元素的上内边框之间的像素距离。 还有一个 offsetParent 属性 返回的是ele元素最近的并且是定位过(relative, absolute)的父元素，如果没有父元素或者是父元素中没有一个是定位过的，返回值就是body元素 客户区大小（client dimension）元素内容及其内边距所占据的空间大小，从字面上看，客户区大小就是元素内部的空间大小 clientWidth — 属性是元素内容区宽度加上左右内边距宽度。 clientHeight — 属性是元素内容区高度加上上下内边距高度。 滚动大小（scroll dimension）指的是包含滚动内容的元素的大小。 scrollHeight — 在没有滚动条的情况下，元素内容的总高度（这里理解为没有滚动条下的文档）。 scrollWidth — 在没有滚动条的情况下，元素内容的总宽度。 scrollLeft — 被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。 scrollTop — 被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。 getBoundingClientRect()IE、Firefox 3+、Safari 4+、Opera 9.5及 Chrome为每个元素都提供了一个 getBoundingClientRect() 方法。这个方法返回会一个矩形对象，包含left 、 top 、 right 和 bottom 等属性。 document.documentElement 与 document.body 傻傻分不清我们知道 document.documentElement 与 document.body 分别指向文档的 &lt;html&gt;元素 和 &lt;body&gt;元素。 这两个属性的问题大多数都是因为文档模式引起的，标准声明的存在会对document.body和document.documentElement的属性值有影响。 在chrome上document.body.scrollTop为0在混杂模式下，可以通过 &lt;body&gt; 元素的 scrollLeft 和 scrollTop 来监控到这一变化而在标准模式下，除 Safari（使用pageXOffset/pageYOffset） 之外的所有浏览器都会通过 &lt;html&gt; 元素来反映这一变化 使用以下代码解决 1window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0 主流浏览器（IE要9+）都支持 pageXOffset 和 pageYOffset 属性 MDN上scrollingElement属性（返回滚动文档的 Element 对象的引用）说明中有提到在标准模式下, 这是文档的根元素, document.documentElement。当在怪异模式下， scrollingElement 属性返回 HTML body 元素（若不存在返回 null ）。 document.body.scrollTop Firefox returns 0 : ONLY JS]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[location 对象 和 history 对象]]></title>
    <url>%2F2019%2F08%2F02%2Fweb%2Fjs%2F%E5%9F%BA%E7%A1%80%2Flocation%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[在html中路由相关的知识非常重要，主要是我经常忘记。所以这篇文章复习记录一下BOM中的location 对象 和 history 对象。 location 对象location 是最有用的 BOM 对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。事实上，location 对象是很特别的一个对象，因为它既是 window 对象的属性，也是 document 对象的属性；换句话说，window.location 和 document.location 引用的是同一个对象。 Location 对象属性包含有关当前 URL 的信息。可以通过不同的属性访问这些 URL 片段。修改 location 对象的属性(hash 除外)也可以改变当前加载的页面。 123456789101112131415//假设初始 URL 为 http://www.wrox.com/WileyCDA/location.protocol // httplocation.pathname // /WileyCDA/location.href = "http://www.wrox.com/WileyCDA/"; // 最常用的 设置为一个 URL 值，也会以该值调用 assign() 方法。//将 URL 修改为"http://www.wrox.com/WileyCDA/#section1"location.hash = "#section1"; //将 URL 修改为"http://www.wrox.com/WileyCDA/?q=javascript"location.search = "?q=javascript";//将 URL 修改为"http://www.yahoo.com/WileyCDA/"location.hostname = "www.yahoo.com";//将 URL 修改为"http://www.yahoo.com/mydir/"location.pathname = "mydir";//将 URL 修改为"http://www.yahoo.com:8080/WileyCDA/"location.port = 8080;// 每次修改 location 的属性（hash 除外），页面都会以新 URL 重新加载。 修改 hash 的值会在浏览器的历史记录中生成一条新记录。在 IE 的早期版本中， hash 属性不会在用户单击“后退”和“前进”按钮时被更新，而只会在用户单击包含 hash 的 URL 时才会被更新。 Location 对象方法location 对象可以通过很多方式来改变浏览器的位置。 assign() 立即打开新 URL 并在浏览器的历史记录中生成一条记录。如果是将 location.href 或 window.location 设置为一个 URL 值，也会以该值调用 assign() 方法。 replace() 接受一个参数，即要导航到的 URL；结果虽然会导致浏览器位置改变，但不会在历史记录中生成新记录。 reload() 作用是重新加载当前显示的页面。 1234567891011// assign()location.assign('https://www.baidu.com')location.href = 'https://www.baidu.com'window.location = 'https://www.baidu.com'// reload()location.replace("https://www.bilibili.com/");// reload()location.reload(); //重新加载（有可能从缓存中加载）location.reload(true); //重新加载（从服务器重新加载） history 对象history 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。出于安全方面的考虑，开发人员无法得知用户浏览过的 URL。不过，借由用户访问过的页面列表，同样可以在不知道实际 URL 的情况下实现后退和前进。 go() 可以在用户的历史记录中任意跳转。这个方法接受一个参数，表示向后或向前跳转的页面数的一个整数值。 back() 后退 forward() 前进 123456789101112//后退一页history.go(-1);//前进一页history.go(1);//前进两页history.go(2);//后退一页history.back();//前进一页history.forward();history.length // length 属性，保存着历史记录的数量 HTML5 新增（重点）历史状态管理历史状态管理是现代 Web 应用开发中的一个难点。在现代 Web 应用中（随着 ajax 的出现，页面实现非 reload 就能刷新数据，也给前端路由的出现奠定了基础），用户的每次操作不一定会打开一个全新的页面，因此“后退”和“前进”按钮也就失去了作用，导致用户很难在不同状态间切换。 目前两种主流方式实现前端路由的方式 History API 和 Hash。 History API新增两个的API history.pushState 和 history.replaceState，pushState会增加一条新的历史记录，而replaceState则会替换当前的历史记录。都接收三个参数： 状态对象 – 一个JavaScript对象 新状态的标题 – 第二个参数目前还没有浏览器实现，因此完全可以只传入一个空字 URL（可选） – 新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。 123456789101112131415// 记得去到打开百度在执行下面window.history.pushState(null, null, "https://www.baidu.com/test");// https://www.baidu.com/testwindow.history.pushState(null, null, "?name=orange");// https://www.baidu.com/test?name=orangewindow.history.pushState(null, null, "name=test");// https://www.baidu.com/name=testwindow.history.pushState(null, null, "/name/test");// https://www.baidu.com/name/testwindow.history.pushState(null, null, "name/test");// https://www.baidu.com/name/name/test popstate 事件 因为 pushState() 会创建新的历史状态，所以你会发现“后退”按钮也能使用了。按下“后退” popstate事件的事件对象有一个 state 属性，这个属性就包含着当初以第一个参数传递给 pushState() 的状态对象按钮，会触发 window 对象的 popstate 事件。 1234567891011window.addEventListener('popstate', (event) =&gt; &#123; console.log("location: " + document.location + ", state: " + JSON.stringify(event.state));&#125;);history.pushState(&#123;page: 1&#125;, "title 1", "?page=1");history.pushState(&#123;page: 2&#125;, "title 2", "?page=2");history.replaceState(&#123;page: 3&#125;, "title 3", "?page=3");history.back(); // Logs "location: http://example.com/example.html?page=1, state: &#123;"page":1&#125;"history.back(); // Logs "location: http://example.com/example.html, state: null -- 浏览器加载的第一个页面没有状态，因此单击“后退”按钮返回浏览器加载的第一个页面时， event.state 值为 nullhistory.go(2); // Logs "location: http://example.com/example.html?page=3, state: &#123;"page":3&#125;history.state // Logs &#123; "page":3&#125; -- 它返回当前状态的状态对象 Hash （兼容性比较好）修改 hash 的值会在浏览器的历史记录中生成一条新记录。我们经常在 url 中看到 #，这个 # 有两种情况，一个是锚点。一个是路由里的 # 不叫锚点，我们称之为 hash，大型框架的路由系统大多都是哈希实现的。 HTML5 新增了 hashchange 事件，以便在 URL 的参数列表（及 URL 中“#”号后面的所有字符串）发生变化时通知开发人员。之所以新增这个事件，是因为在 Ajax 应用中，开发人员经常要利用 URL 参数列表来保存状态或导航信息。 支持 hashchange 事件的浏览器有 IE8+、Firefox 3.6+、Safari 5+、Chrome 和 Opera 10.6+。在这些浏览器中，只有 Firefox 6+、Chrome 和 Opera 支持 oldURL 和 newURL 属性 MDN 上实现兼容的代码 1234567891011121314151617181920212223242526272829(function(window) &#123; // 如果浏览器原生支持该事件,则退出 if ( "onhashchange" in window.document.body ) &#123; return; &#125; var location = window.location, oldURL = location.href, oldHash = location.hash; // 每隔100ms检测一下location.hash是否发生变化 setInterval(function() &#123; var newURL = location.href, newHash = location.hash; // 如果hash发生了变化,且绑定了处理函数... if ( newHash != oldHash &amp;&amp; typeof window.onhashchange === "function" ) &#123; // execute the handler window.onhashchange(&#123; type: "hashchange", oldURL: oldURL, newURL: newURL &#125;); oldURL = newURL; oldHash = newHash; &#125; &#125;, 100);&#125;)(window); 参考链接： 前端路由的两种实现原理]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Awesome]]></title>
    <url>%2F2019%2F07%2F14%2Fbookmarks%2F</url>
    <content type="text"><![CDATA[个人技术收藏集一些平时用到的库，常用，有趣的网站和小工具。 前端 hammer 移动端手势库 dayjs 一个轻量级类 API 时间库 moment.js pinyin 汉字拼音转换 uppy 一款时尚的模块化JavaScript文件上传器 Filepond 一个小巧灵活而有趣的JavaScript文件上传库 Regular Expressions 在线正则网站 挺好用的 jex 正则可视化网站，可以导出图片，配合上面的 Regular Expressions，写正则方便很多 awesome-nodejs Node.js包和资源 primjs 让页面支持代码高亮 pre标签 code标签 highlight.js Javascript语法高亮 img-2 一个提高图片加载性能和体验的库，懒加载、web worker、模糊预览 uppy 浏览器上传器 html5-boilerplate 一个专业的前端模板，用于构建快速，健壮且适应性强的Web应用程序或站点 Css CSS triangle generator 帮你快速用 css 做出三角形 cssarrowplease 帮你做对话框三角的 clippy 在线帮你使用 css clip-path 做出各种形状的 sprite-generator 生成雪碧图 css_tricks Some CSS tricks,一些 CSS 常用样式 一些前端开发中可能会用到的 Headroom.js Hide your header until you need it. 控制header的显示隐藏 gsap JavaScript动画库 typed.js 打字机效果 browser-sync 浏览器同步测试工具 NProgress 进度 jquery-pjax pjax是一个jQuery插件，它使用ajax和pushState通过真实的永久链接，页面标题和工作后退按钮提供快速浏览体验。 css.loli.net 常用前端公共库 CDN 服务 Google 公共库、字体库 fastclick 解决移动端浏览器在派发点击事件的时候会出现300ms左右的延迟 fancyBox JQ图片预览的插件 velocity 非常火的一个动画库 clipboard.js 前端复制粘贴的库 Vue vee-validate 基于 vue 的验证 vue-multiselect select 组件 工具 JavaScript Obfuscator Tool js 代码混淆工具 hipdf 一站式在线 PDF 解决方案 ReLaXed 一个将 document html 转成 PDF 的工具 tinypng 压缩图片 Lorem Picsum 提供免费的占位图 相比dummyimage的图片是很好看的 sm.ms 免费图床 colorkitty 从你的图片中提取配色 devhints.io cheatsheets 开发者语言速查 bezier-easing JavaScript动画缓动的cubic-bezier实现 gka 一款高效、高性能的帧动画生成工具 HEAD 放在文档head标签的所有内容列表 Chrome拓展 Tampermonkey 油猴 最强的浏览器插件 扩展管理器 一键管理所有扩展，快速开启/禁用、批量闪电管理，智能排序，右键卸载、锁定、选项配置，角标提醒，大小布局随心配。快捷、简单、安全。 The Great Suspender chrome 太吃内存了，当页面开的很多时候会很卡，它就完美的解决了这个问题。我就经常放着一大堆网页没有关闭，对我帮助很大。多标签爱好者福音,临时冻结不用网页。 infinity 非常实用的chrome新标签页 Adblock Plus 免费广告拦截程序 装机必备 Save All Resources 可以直接下载浏览器sources资源 安装完DevTools会多了一个ResourceSaver，之后就是下载了 WEB 前端助手 包含多个独立小应用，比如：Json工具、代码美化工具、代码压缩、二维码工具、markdown工具、网页油猴工具、便签笔记工具、信息加密与解密、随机密码生成、Crontab等等！ JSON-handle 对JSON格式的内容进行浏览和编辑，以树形图样式展现JSON文档，并可实时编辑。 Octotree github 上看代码显示目录结构 npmhub在 README 下方显示 npm 依赖信息 可能快速找到相应依赖的代码库 hostAdmin App 修改host的应用 安装方式：修改下载的crx为zip解压 然后加载chrome的扩展程序中点击加载已解压的扩展程序按钮 好玩 awesome-comment 里面收集了很多有趣的代码注释 hitokoto 提供一句话服务。 alloyteam 腾讯全端 AlloyTeam 团队 里面有很多有意思的项目 Node cross-env 解决跨平台设置NODE_ENV的问题]]></content>
  </entry>
  <entry>
    <title><![CDATA[事件冒泡和默认事件]]></title>
    <url>%2F2019%2F03%2F09%2Fweb%2Fjs%2F%E5%9F%BA%E7%A1%80%2F%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[今天又遇到事件冒泡的问题，专门找时间整理一下相关的资料，记录一下。ヽ(ー_ー)ノ 事件冒泡（event bubbling）我们先来理解一下事件冒泡是什么。（事件捕获与之相反我这里就不展开了）(^▽^) 123456789&lt;!DOCTYPE html&gt;&lt;html onclick="alert('h')"&gt;&lt;head&gt;&lt;title&gt;Event Bubbling Example&lt;/title&gt;&lt;/head&gt;&lt;body onclick="alert('b')"&gt; &lt;div onclick="alert('d')" id="myDiv"&gt;Click Me&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如果你单击了页面中的 &lt;div&gt; 元素, click 事件首先在 &lt;div&gt; 元素上发生，而这个元素就是我们单击的元素。然后， click事件沿 DOM 树向上传播，在每一级节点上都会发生，直至传播到 document 对象。 这就是事件冒泡 阻止事件冒泡/默认事件一般我们处理事件时出现奇怪的现像，大多数都是由事件冒泡引起的，或者我们想阻止一下默认事件（也可以叫默认行为，eg：链接的默认行为就是在被单击时会导航到其 href 特性指定的 URL，表单提交等），接下来我们来看一下怎么解决吧！ return false为什么我要第一个讲它，因为在网上找阻止事件冒泡和默认事件的方法会出现return false这个方法，这里我要点一下的是在JQuery！JQuery！JQuery！封装的事件函数中return false确实是可以阻止事件冒泡和默认事件的（这就是我挖到的坑o(╥﹏╥)o，原理我还没去看），但在原生的事件处理程序里可以用来阻止默认事件，只有阻止默认事件！ stopPropagation()/preventDefault()这两个方法是DOM事件对象的，stopPropagation()用来阻止事件冒泡（如果事件对象的bubbles为true ，则可以使用这个方法），preventDefault()用来取消事件的默认行为（如果事件对象的cancelable为true ，则可以使用这个方法）。 stopImmediatePropagation()stopImmediatePropagation()方法是DOM3级事件中新增的取消事件的进一步捕获或冒泡，并且阻止相同事件的其他侦听器被调用。 如果有多个相同类型事件的事件监听函数绑定到同一个元素，当该类型的事件触发时，它们会按照被添加的顺序执行。如果其中某个监听函数执行了event.stopImmediatePropagation() 方法，则当前元素剩下的监听函数将不会被执行。（注意区别 event.stopPropagation()） cancelBubble/returnValue这两个属性是IE事件对象的，cancelBubble属性（默认值为false）其设置为 true 用来阻止事件冒泡（与 DOM 中的 stopPropagation()方法作用相同），returnValue属性（默认值为true）其设置为 false 用来取消事件的默认行为（相当 DOM 中的 preventDefault()方法）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Test&lt;/title&gt; &lt;/head&gt; &lt;style&gt; .box &#123; height: 200px; width: 600px; margin: 0 auto; &#125; .box a&#123; display: block; height: 50%; width: 50%; background: red; &#125; &lt;/style&gt; &lt;body onclick="alert('body')"&gt; &lt;div class="box"&gt; &lt;a id="link" href="http://www.baidu.com" target="_blank"&gt;1111111111&lt;/a&gt; &lt;/div&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"&gt;&lt;/script&gt; &lt;script&gt; window.onload = function () &#123; document.getElementsByClassName("box")[0].onclick = function()&#123; alert('box') &#125; document.getElementById('link').onclick = function(event)&#123; alert('link') event.stopPropagation(); // 阻止事件冒泡 // event.preventDefault() // 阻止默认行为，页面不会跳转 // event.returnValue = false // 阻止默认行为 // event.cancelBubble = true // 阻止事件冒泡 console.log(event); return false; // 阻止默认行为 观察event对象会发现returnValue变成false了 &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件流和事件处理程序]]></title>
    <url>%2F2019%2F03%2F09%2Fweb%2Fjs%2F%E5%9F%BA%E7%A1%80%2F%E4%BA%8B%E4%BB%B6%E6%B5%81%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[事件流JavaScript的事件流（事件流描述的是从页面中接收事件的顺序）有三种，分别是：事件冒泡、事件捕获、DOM事件流。 IE 的事件流叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档） Netscape Communicator团队提出的另一种事件流叫做事件捕获（event capturing）。事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。 “DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。 IE9、Opera、Firefox、Chrome 和 Safari 都支持 DOM 事件流；IE8 及更早版本不支持 DOM 事件流。 事件处理程序事件就是用户或浏览器自身执行的某种动作。诸如 click 、 load 和 mouseover ，都是事件的名字。而响应某个事件的函数就叫做事件处理程序（或事件侦听器）。事件处理程序的名字以 “on” 开头，因此click 事件的事件处理程序就是 onclick … HTML事件处理程序某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML 特性来指定。这个特性的值应该是能够执行的 JavaScript 代码。例如，要在按钮被单击时执行一些 JavaScript，可以像下面这样编写代码： 1&lt;input type="button" value="Click Me" onclick="alert('Clicked')" /&gt; 缺点： 样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。不同 JavaScript引擎遵循的标识符解析规则略有差异，很可能会在访问非限定对象成员时出错。 HTML 与 JavaScript 代码紧密耦合。如果要更换事件处理程序，就要改动两个地方：HTML 代码和 JavaScript 代码。 DOM0 级事件处理程序（事件处理程序会在事件流的冒泡阶段被处理）通过 JavaScript 指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。这种为事件处理程序赋值的方法是在第四代 Web 浏览器中出现的，而且至今仍然为所有现代浏览器所支持。原因一是简单，二是具有跨浏览器的优势。以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。~~ 每个元素（包括 window 和 document ）都有自己的事件处理程序属性，这些属性通常全部小写，例如 onclick 。将这种属性的值设置为一个函数，就可以指定事件处理程序，如下所示： 1234var btn = document.getElementById("myBtn");btn.onclick = function()&#123; alert("Clicked");&#125;; 缺点： 一个元素只能添加一个事件处理程序。 移除 DOM0 级方法指定的事件处理程序只要像下面这样将事件处理程序属性的值设置为 null 即可： 1btn.onclick = null; //删除事件处理程序 DOM2 级事件处理程序 （可以设置事件在捕获还是冒泡处理）“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作： addEventListener()和 removeEventListener() 。所有 DOM 节点中都包含这两个方法，并且它们都接受 3 个参数：要处理的事件名（没有on）、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true ，表示在捕获阶段调用事件处理程序；如果是 false ，表示在冒泡阶段调用事件处理程序。 1234var btn = document.getElementById("myBtn"); btn.addEventListener("click", function()&#123; alert(this.id);&#125;, false); 移除 DOM2 级事件处理程序传入 removeEventListener() 中的事件处理程序函数必须与传入addEventListener() 中的相同才可以移除！！！ 1234567var btn = document.getElementById("myBtn");var handler = function()&#123;alert(this.id);&#125;;btn.addEventListener("click", handler, false);// 这里省略了其他代码btn.removeEventListener("click", handler, false); // 有效！ IE9、Firefox、Safari、Chrome和 Opera 支持 DOM2 级事件处理程序。 IE事件处理程序 （只支持事件冒泡）IE 实现了与 DOM 中类似的两个方法： attachEvent() 和 detachEvent()。这两个方法接受相同的两个参数：事件处理程序名称（以 &quot;on&quot; 开头的, 区别DOM）与事件处理程序函数。由于 IE8 及更早版本只支持事件冒泡，所以通过attachEvent() 添加的事件处理程序都会被添加到冒泡阶段。 移除跟 DOM2 级事件处理程序一样参数必须相同！ 要使用 attachEvent() 为按钮添加一个事件处理程序，可以使用以下代码。 1234var btn = document.getElementById("myBtn");btn.attachEvent("onclick", function()&#123; alert("Clicked");&#125;); 注意！在 IE 中使用 attachEvent() 与使用 DOM0 级方法的主要区别在于事件处理程序的作用域。在使用 DOM0 级方法的情况下，事件处理程序会在其所属元素的作用域内运行；在使用 attachEvent() 方法的情况下，事件处理程序会在全局作用域中运行，因此 this 等于 window 。 1234var btn = document.getElementById("myBtn"); btn.attachEvent("onclick", function()&#123; alert(this === window); //true&#125;); 支持 IE 事件处理程序的浏览器有 IE 和 Opera。 整理自JavaScript高级程序设计。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex Layout 弹性盒子模型 的 flex属性]]></title>
    <url>%2F2019%2F03%2F06%2Fweb%2Fcss%2Fflex%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[最近都在忙着实习的事情，好久没写过博客了。。。o(╥﹏╥)o，来复习一下flex布局吧。。Flex布局的基本使用我这里就不赘述了，可以去看阮一峰老师的Flex 布局教程：语法篇这篇文章。这里我主要介绍一下Flex布局中的项目的属性的flex属性。 flex 属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。 flex 的写法 当 flex 取值为 none，则计算值为 0 0 auto 当 flex 取值为 auto，则计算值为 1 1 auto 当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0% 当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1，有如下等同情况（注意 0% 是一个百分比而不是一个非负数字） 当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0% 当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1 flex-grow, flex-shrink 和 flex-basisflex-grow, flex-shrink 和 flex-basis三个属性是对剩余空间（就是父容器在主轴的方向上还有多少可用的空间）的操作 剩余空间剩余空间＝父容器空间－子容器1.flex-basis/width - 子容器2.flex-basis/width - …flex-basis和width其中有一个是auto，那么另外一个非auto的属性优先级会更高。flex-basis和width为auto值，那最后的空间就是根据内容多少来定的，内容多占据的水平空间就多。 参考链接：深入理解css3中的flex-grow、flex-shrink、flex-basis （转）flex-grow、flex-shrink、flex-basis详解、flex:1;详解]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenkins初了解]]></title>
    <url>%2F2019%2F02%2F24%2FTechnologyStack%2Fjenkins%2F</url>
    <content type="text"><![CDATA[这边文章只是简单了解一下什么是jenkins，详细可以到官网。 Jenkins是什么?Jenkins是一款开源CI（持续集成）&amp;CD（持续交付）软件，用于自动化各种任务，包括构建、测试和部署软件.Jenkins支持各种运行方式，可通过系统包,Docker或者通过一个独立的Java程序. 发布流程设计 参考：jenkins自动化部署及三种构建部署方式 https://blog.csdn.net/achudk/article/details/78925081Jenkins与Docker的自动化CI/CD实战 https://blog.51cto.com/qiuyt/2163950]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发中的各种环境]]></title>
    <url>%2F2019%2F02%2F23%2FSoftwareEngineering%2F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[记录一下开发中的各种环境。 local：本地开发环境dev：内部开发环境test：供测试人员测试环境stage：试运行环境（新功能部分目标用户使用）production：对外开放的产品环境 https://segmentfault.com/q/1010000006921696/a-1020000006921997]]></content>
      <tags>
        <tag>Software Testing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象]]></title>
    <url>%2F2019%2F02%2F22%2FTechnologyStack%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[说到面向对象肯定会想到三大特性（封装、继承、多态），今天面试被问到了，(〃’▽’〃)却发现回答不上来。。。这里先简答记录一下。 三大特性面向对象编程的三大特性（封装、继承、多态） 封装将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问 好处： a.只能通过规定的方法访问数据 b.隐藏类的实例细节，方便修改和实现（增强安全性和简化编程，使用者不必了解具体的实现细节，而只要通过对外公开的访问方法，来使用类的成员。） 封装的实现步骤： 1、修改属性的可见性：设为private。 2、创建getter/setter方法，用于属性的读写。 3、在getter/setter方法中加入属性控制语句，对属性值的合法性进行判断。 继承继承：子类拥有父类所有的属性和方法 （修饰符为private则无效） 可以实现代码的复用语法：class 子类 extends 父类{} （创建子类时可以选择 Super class 中的父类）目的：实现代码的复用。 多态多态：相同的事物，调用其相同的方法，参数也相同时，但表现的行为却不同。 引用多态 父类的引用可以指向本类的对象 父类的引用可以指向子类的对象 方法多态 创建本类对象时，调用的方法为本类方法 创建子类对象时，调用的方法为子类重写的方法或者继承的方法 引用类型转换 向上类型转换（隐式/自动类型转换），是小类型到大类型的转换 向下类型转换（强制类型转换），是大类型到小类型 instanceof运算符，来解决引用对象的类型（进行判断），避免类型转换的安全性问题 12345A a = new B(); //这就称父类的引用a 指向了子类的对象new B()，就是这个意思。 B继承ADog dog = new Dog();Animal animal = dog; //自动类型提升，向上类型转换。Dog dog2 = (Dog)animal; //父引用转向子类引用 向下类型转换，强制类型转换 参考：Java入门第二季Java 面向对象编程的三大特性（封装、继承、多态）以及重写和重载https://blog.csdn.net/qq_22118507/article/details/51422591 抽象在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。 抽象类是不可以实例化，也就是抽象类不能被new（不能通过new来生成抽象类的对象），抽象类必须被继承利用，抽象类一定是用来被其它类继承 抽象方法的定义格式： [修饰符] abstract 返回值类型 方法名(参数); 修饰符：public protected 默认 当子类继承抽象类时，一定要覆盖抽象类的抽象方法，否则子类也会是抽象类也需要用abstract修饰 可以把子类对象赋值给抽象类父类的引用，父类引用调用抽象方法将会调用子类的方法 接口接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。 常量的定义格式： [public] [static] [final] 数据类型 变量名=值; 数据类型前面的public static final可以省略 使用接口中的常量的格式：接口名.常量名 抽象方法的定义格式： [public] [abstract] 返回值类型 方法名(参数); 返回值类型前面的public abstract可以省略 接口中成员都是public的 接口也是不能实例化，也就是不能new接口对象，它用来被继承 一个类可以继承多个接口，其格式： 123class 子类 implements 接口1,接口2,...&#123;&#125; 一个类可以继承一个父类，还可以继承多个接口： 123class 子类 extends 父类 implements 接口1,接口2,...&#123;&#125; 当一个子类继承接口时，需要覆盖(实现)接口中的所有抽象方法 可以把子类对象赋值给接口的引用，接口引用调用方法时调用的是子类的方法 抽象类和接口的异同1、接口和抽象类都是不能实例化的，也就是都是不能new2、接口中的方法都是抽象方法，而抽象类中可以有具体的方法3、一个类可以继承多个接口，但只能继承一个抽象类。类：单继承，接口：多继承4、接口不能有构造方法的，但抽象类可以有构造方法5、接口中的成员都是公共的]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的for...in和for...of]]></title>
    <url>%2F2019%2F02%2F21%2Fweb%2Fjs%2F%E5%9F%BA%E7%A1%80%2Fjs%E7%9A%84for-in%E5%92%8Cfor-of%2F</url>
    <content type="text"><![CDATA[for…in 用来循环对象循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。 屏蔽了原型中不可枚举属性（即将[[Enumerable]] 标记为 false 的属性）的实例属性也会在 for-in 循环中返回（早版本的IE不会） for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。 一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。 循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。 for…in循环读取键名，for…of循环读取键值。如果要通过for…of循环，获取数组的索引，可以借助数组实例的entries方法和keys方法。 for…of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for…in循环也不一样。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数组去重]]></title>
    <url>%2F2019%2F02%2F21%2Fweb%2Fjs%2Fjs%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[这段时间我就在面试的时候做到了数组去重的题目，回来找一下资料发现，这是不只是一道简单的面试题，还是一道送命题啊。所以我记录一下去重的几种方法ヽ(ーー)ノヽ(ーー)ノヽ(ー_ー)ノ||。 使用Array.prototype.indexOf()方法 方法一 12345678910function uniq1 (arr) &#123; var n = []; //一个新的临时数组 for(var i = 0; i &lt; arr.length; i++) //遍历当前数组 &#123; //如果当前数组的第i已经保存进了临时数组，那么跳过， //否则把当前项push到临时数组里面 if (n.indexOf(arr[i]) === -1) n.push(arr[i]); &#125; return n;&#125; 方法二 12345678910function uniq2() &#123; var n = [this[0]]; //结果数组 for(var i = 1; i &lt; this.length; i++) //从第二项开始遍历 &#123; //如果当前数组的第i项在当前数组中第一次出现的位置不是i， //那么表示第i项是重复的，忽略掉。否则存入结果数组 if (this.indexOf(this[i]) == i) n.push(this[i]); &#125; return n;&#125; 这两个方法都用到了数组的indexOf方法。目的是寻找存入参数在数组中第一次出现的位置。很显然，js引擎在实现这个方法的时候会遍历数组直到找到目标为止。所以此函数会浪费掉很多时间。（这就是这道题的坑了） 使用对象key来去重这种方法效率最好 123456789101112function unique(arr) &#123; var ret = []; var len = arr.length; var tmp = &#123;&#125;; for(var i=0; i&lt;len; i++)&#123; if(!tmp[arr[i]])&#123; tmp[arr[i]] = 1; ret.push(arr[i]); &#125; &#125; return ret;&#125; 这种方法是利用了对象（tmp）的key不可以重复的特性来进行去重。但由于对象key只能为字符串，因此这种去重方法有许多局限性： 无法区分隐式类型转换成字符串后一样的值，比如1和’1’ eg: [1, &#39;1&#39;] 无法处理复杂数据类型，比如对象（因为对象作为key会变成[object Object]） `eg: [1, {a:1}, {}] 特殊数据，比如’proto‘会挂掉，因为tmp对象的proto属性无法被重写 对于第一点，有人提出可以为对象的key增加一个类型，或者将类型放到对象的value中来解决： 1234567891011121314function unique(arr) &#123; var ret = []; var len = arr.length; var tmp = &#123;&#125;; var tmpKey; for(var i=0; i&lt;len; i++)&#123; tmpKey = typeof arr[i] + arr[i]; if(!tmp[tmpKey])&#123; tmp[tmpKey] = 1; ret.push(arr[i]); &#125; &#125; return ret;&#125; 该方案也同时解决第三个问题。 而第二个问题，如果像上文所说，在允许对对象进行自定义的比较规则，也可以将对象序列化之后作为key来使用。这里为简单起见，使用JSON.stringify()进行序列化。[1, &#39;1&#39;, {a:1}, {a:1}, function(){}, function(){return 1}]这种情况还是会出现 1234567891011121314function unique(arr) &#123; var ret = []; var len = arr.length; var tmp = &#123;&#125;; var tmpKey; for(var i=0; i&lt;len; i++)&#123; tmpKey = typeof arr[i] + JSON.stringify(arr[i]); if(!tmp[tmpKey])&#123; tmp[tmpKey] = 1; ret.push(arr[i]); &#125; &#125; return ret;&#125; 使用Set123456function unique(arr) &#123;return Array.from(new Set(arr));// return [...new Set(arr)]&#125;unique([1, 2, 3, 3]) //[1, 2, 3]unique([1, 2, 3, 3, &#123;&#125;, &#123;&#125;]) // [1, 2, 3, &#123;&#125;, &#123;&#125;] 引用类型的值 Set里面两个对象总是不相等的。 参考资料：js数组去重的4个方法也谈JavaScript数组去重]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新春快乐]]></title>
    <url>%2F2019%2F02%2F05%2Fblog%2F2019%E6%96%B0%E6%98%A5%E5%BF%AB%E4%B9%90%2F</url>
    <content type="text"><![CDATA[新春快乐！！！！！新春快乐！！！！！新春快乐！！！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery的extend方法]]></title>
    <url>%2F2019%2F01%2F14%2Fweb%2Fjs%2FjQuery%2FjQuery%E7%9A%84extend%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[jQuery的extend方法可以说是jQuery最核心的方法了，这几天复习js的基础，参考了JavaScript 复制对象【Object.assign方法无法实现深复制】这篇文章看了一下jQuery的extend方法的源码。 jQuery.extend || jQuery.fn.extend$.extend方法的一些特点 没有任何参数时，直接返回一个空对象 当只有一个参数时（这个参数可以任何数据类型（Null、Undefined、Boolean、String、Number、Object）），会返回this对象，这里会分为两种情况。如果用$.extend，会返回jQuery对象；如果用$.fn.extend，会返回jQuery的原型对象。 当接收两个参数时，并且第一个参数是Boolean值时，也会返回一个空对象。如果第一个参数不是Boolean值，那么会将源对象复制到目标对象 当接收三个参数以上时，可以分为两种情况。如果第一个参数是Boolean值表示深浅复制，那么目标对象会移动到第二个参数，源对象会移动到第三个参数。（目标对象、源对象和Object.assign方法中的相同）。如果第一个参数不是Boolean值，那么用法与Object.assign方法常规的复制相同。 在循环源对象的过程中，任何数据类型为Null、Undefined或者源对象是一个空对象时，在复制的过程中都会被忽略。 如果源对象和目标对象具有同名的属性，则源对象的属性会覆盖掉目标对象中的属性。如果同名属性是一个对象的话，则会在deep=true等其他条件下向目标对象的该同名对象添加属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091jQuery.fn = jQuery.prototype;jQuery.extend = jQuery.fn.extend = function() &#123;// 声明和初始化变量var options, name, src, copy, copyIsArray, clone, target = arguments[ 0 ] || &#123;&#125;, // 使用||运算符，排除隐式强制类型转换为false的数据类型 如'', 0, undefined, null, false等 // 如果target为以上的值，则设置target = &#123;&#125; i = 1, length = arguments.length, deep = false;// 当typeof target === 'boolean'时// 则将deep设置为target的值// 然后将target移动到第二个参数if ( typeof target === "boolean" ) &#123; deep = target; target = arguments[ i ] || &#123;&#125;; i++;&#125;// Handle case when target is a string or something (possible in deep copy)// 将typeof不为object或function的数据类型 全部转换为一个空对象if ( typeof target !== "object" &amp;&amp; !isFunction( target ) ) &#123; target = &#123;&#125;;&#125;// Extend jQuery itself if only one argument is passed 只用一个元素时添加到this上// 如果arguments.length === 1 或// typeof arguments[0] === 'boolean', 且存在arguments[1]，if ( i === length ) &#123; // this的指向哪个对象需要看是使用$.fn.extend还是$.extend target = this; // i-- 表示不进入for循环 i--;&#125;for ( ; i &lt; length; i++ ) &#123; // Only deal with non-null/undefined values if ( ( options = arguments[ i ] ) != null ) &#123; console.log(options, "11111111111" ,target, i) // Extend the base object for ( name in options ) &#123; console.log(name) src = target[ name ]; // src用于判断target对象是否存在name属性 copy = options[ name ]; // 需要复制的属性 当前源对象的name属性 // console.log(target) console.log(src) console.log(copy) // Prevent never-ending loop 防止永不结束的循环 // 防止对象的一个属性引用对象本身造成死循环 // eg： var a = [1,2]； a.push(a) if ( target === copy ) &#123; continue; &#125; // 如果是深复制且copy是一个对象或数组 // 则需要递归jQuery.extend() // 直到copy成为一个基本数据类型为止 if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) || ( copyIsArray = Array.isArray( copy ) ) ) ) &#123; if ( copyIsArray ) &#123; copyIsArray = false; // 如果目标对象存在name属性且是一个数组 // 则使用目标对象的name属性，否则重新创建一个数组，用于复制 clone = src &amp;&amp; Array.isArray( src ) ? src : []; &#125; else &#123; // 如果目标对象存在name属性且是一个对象 // 则使用目标对象的name属性，否则重新创建一个对象，用于复制 clone = src &amp;&amp; jQuery.isPlainObject( src ) ? src : &#123;&#125;; &#125; console.log(clone) // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // Don't bring in undefined values &#125; else if ( copy !== undefined ) &#123; // 一级拷贝的情况 console.log(name) target[ name ] = copy; &#125; &#125; &#125;&#125;// Return the modified objectreturn target;&#125;; 例子12345678let obj1 = $.extend();console.log(obj1); // 返回一个空对象 &#123;&#125;let obj2 = $.extend(undefined);console.log(obj2); //返回jQuery对象，Object.assign传入undefined会报错let obj3 = $.extend('123');console.log(obj3); // 返回jQuery对象，Object.assign传入'123'会返回字符串的String对象 扩展 深拷贝与浅拷贝浅拷贝（shallow copy）只复制指向某个对象的指针，而不复制对象本身，新旧对象共享一块内存深拷贝（deep copy）复制并创建一个一摸一样的对象，不共享内存，修改新对象，旧对象保持不变 实现深拷贝的方法 使用递归 递归去复制所有层级属性 使用JSON对象的parse和stringify 1234567let obj1 = &#123; a: 1， b：&#123; a:1 &#125;&#125;let obj2 = JSON.parse(JSON.stringify(obj1)); jQuery的extend方法 第一个参数设置为true 使用 Object.assign ES6新增的Object.assign()，Object.assign方法用于对象的合并，将源对象（source）的所有可枚举（（[[emuerable]] === true））属性，复制到目标对象（target）。Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。跟jQuery的extend方法很像，都是用于扩展已有的Object对象。但区别还是挺大的。 注意点 针对深拷贝，需要使用其他方法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值 如果目标对象与源对象有同名属性，则后面的属性会覆盖前面的属性 如果只有一个参数，则直接返回该参数。即Object.assign(obj) === obj 如果第一个参数不是对象，而是基本数据类型（Null、Undefined除外），则会调用对应的基本包装类型 如果第一个参数是Null和Undefined，则会报错；如果Null和Undefined不是位于第一个参数，则会略过该参数的复制 slice()，concat()，Array.from() 这几个到底是深拷贝还是浅拷贝（我纠结了很久，ヽ(ー_ー)ノ），跟Object.assign()差不多，那到底是深拷贝还是浅拷贝呢？我觉得用浅拷贝更合适一点，不过我们要记住它们仅适用于对不包含引用对象的一维数组的深拷贝。 一些小问题 为什么我们通常会写Object.assign()的一个参数为{}空对象 我们知道Object.assign方法用于对象的合并，如果是实现对象的复制的话，就需要将一个空对象传入，切断与目标对象的引用。 123456789var test1 = &#123;a:1&#125;;var test2 = &#123;b:1,a:2&#125;;var res = Object.assign(test1, test2); // res和test1同一个引用res.c = 233;console.log(test1); // &#123;a: 2, b: 1, c: 233&#125;var res = Object.assign(&#123;&#125;, test1, test2); // res和test1不同引用res.c = 666;console.log(test1); // &#123;a: 2, b: 1, c: 233&#125;console.log(res); // &#123;a: 2, b: 1, c: 666&#125; 参考链接：JavaScript 复制对象【Object.assign方法无法实现深复制】javascript中的深拷贝和浅拷贝？深拷贝与浅拷贝的区别，实现深拷贝的几种方法]]></content>
      <categories>
        <category>JavaScript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webGL初了解]]></title>
    <url>%2F2019%2F01%2F14%2Fweb%2FwebGL%2F</url>
    <content type="text"><![CDATA[WebGLWebGL (Web图形库 Web Graphics Library) 是一种JavaScript API，用于在任何兼容的Web浏览器中呈现交互式3D和2D图形，而无需使用插件。WebGL通过引入一个与OpenGL ES 2.0紧密相符合的API，可以在HTML5 &lt;canvas&gt; 元素中使用。 WebGL框架three.js（这个比较火）、Babylon.jS OpenGL ESOpenGL ES (OpenGL for Embedded Systems) 是 OpenGL 三维图形 API 的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。该API由Khronos集团定义推广，Khronos是一个图形软硬件行业协会，该协会主要关注图形和多媒体方面的开放标准。 现在主要使用的两个版本：OpenGL ES 2.0 和 OpenGL ES 3.0 OpenGLOpenGL是用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口（API）。它为我们提供了大量的功能,我们可以使用它来处理图形和图像。准确来说，OpenGL本身并不是一个API，只是一个规范，由Khronos组织开发和维护。OpenGL规范描述了绘制2D和3D图形的抽象API。 这套接口是Khronos这个组织在维护，怎么维护呢?就是写一个规范，指导各个GPU厂家，如果他们要支持OpenGL的话，要怎么实现一个具体的OpenGL库。Khronos说要实现glDrawArray这个接口，那么厂家就得在他的库里实现这个接口。如果不实现，那么就不算支持OpenGL。也有一些接口不一定要实现。 参考资料：WebGLThree.js和其它webgl框架OpenGL是什么?]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件测试基本概念]]></title>
    <url>%2F2019%2F01%2F13%2FSoftwareEngineering%2FsoftwareTest%2F</url>
    <content type="text"><![CDATA[什么是软件测试是为了度量和提高被测软件质量，是对被测软件进行工程设计、实施和维护的整个生命周期的过程。 软件测试的目的 测试以发现缺陷为目的 最大可能找出最多错误 执行有限测试用例并发现错误 检查软件是否满足定义的各种需求 执行测试用例，发现至今未发现错误即为成功的测试 软件研发模型软件研发模型是软件生产过程中分析、设计、研发活动所遵循的框架模式。采取合适的研发模型将会提高软件研发效率，降低研发成本，提高质量。目前较为流行的研发模型主要有：瀑布模型、原型模型、螺旋模型、RUP模型、敏捷模型和DevOps。 瀑布模型瀑布模型将软件生命周期划分为开发计划、需求分析、设计、编码、测试和运行维护这6个基本活动过程。 需求测试（Requirement Testing）需求测试是在需求分析阶段开始就搞。需求测试的重点是：检查规格说明书中是否存在描述不正确、定义模糊、需求用例不正确、语言存在二义性等问题。完整性、正确性、无二义性、可测试性、一致性。 敏捷模型敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。在敏捷开发中，软件项目在构建初期被切分成多个子项目，各个子项目的成果都经过测试，具备可视、可集成和可运行使用的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。（来自百度百科!!!∑(ﾟДﾟノ)ノ） 持续集成（CI）/ 持续交付（CD）/ 持续部署（CD） 持续集成（Continuous Integration） 是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。为什么要持续集成 持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。 持续交付（Continuous Delivery） 持续交付（Continuous delivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。定时地、自动地将过去一个稳定的发布版本部署到生产环境里。持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。出于业务考虑，可以选择不部署。如果要实施持续部署，必须先实施持续交付。 持续部署（Continuous Deployment） 持续部署（continuous deployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。 持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。 持续部署的前提是能自动化完成测试、构建、部署等步骤。 持续部署则是在持续交付的基础上，把部署到生产环境的过程自动化。 参考：https://blog.csdn.net/peterxiaoq/article/details/73648732 持续集成（CI）/持续部署（CD）/持续交付https://www.zhihu.com/question/23444990 如何理解持续集成、持续交付、持续部署？http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html 持续集成是什么？ DevOpsDevOps（Development和Operations的组合词）是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。它是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。 DevOps生命周期 DevOps生命周期的哪个阶段使用哪些工具 参考：http://www.sohu.com/a/283593991_115128https://www.zhihu.com/question/58702398https://blog.csdn.net/dtttyc/article/details/72921607 软件测试级别单元测试 集成测试 系统测试 验证测试 验收测试（Alpha测试 Beta测试 UAT测试） 软件测试类型功能测试 性能测试 负载测试 压力测试 安全性测试 兼容性测试 确认测试 冒烟测试 回归测试 软件测试模型及流程v模型 w模型 测试用例测试用例（Test Case）是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序路径或核实是否满足某个特定需求。 常见的软件测试方法 黑盒测试黑盒测试又称功能测试、数据驱动测试或基于需求规格说明书的功能测试。该测试方法验证被测对象使用质量及外部质量表现。黑盒测试的测试方法有：等价类划分、边界值分析法、猜错法、随机数法、因果图。 白盒测试 白盒测试，又称为结构测试、逻辑驱动测试或基于程序代码内部构成的测试。 白盒测试的测试方法有：代码检查法、程序变异、静态结构分析法、静态质量度量法、符号测试法、逻辑覆盖法、域测试、Z路径覆盖和基本路径测试法。 灰盒测试 灰盒测试就是白盒测试加黑盒测试，性能测试和自动化测试就采用了灰盒测试的方法。 静态测试 不执行被测对象的程序代码、不运行被测对象而实施的测试活动，发现缺陷的过程。 静态测试包含阅读程序代码、文档资料等。 动态测试动态测试运行被测对象的程序代码，执行测试用例，检查系统软件运行结果与预期结果的差异。 手工测试 自动化测试 工具测试用例管理工具 TestLink 缺陷管理工具BugFree 自动化测试工具QTP 性能测试工具Loadrunner 软件测试网]]></content>
      <tags>
        <tag>Software Testing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的运算符和运算符优先级]]></title>
    <url>%2F2019%2F01%2F11%2Fweb%2Fjs%2F%E5%9F%BA%E7%A1%80%2Fjs%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[12345var a = &#123;n:1&#125;;var b = a;a.x = a = &#123;n:2&#125;;console.log(a.x);// --&gt; undefinedconsole.log(b.x);// --&gt; &#123;n: 2&#125; 记录一下这道经典的面试题引发的惨案。今天去面试了，面试时没有做出来，回过神来我才发现原来我以前做过这道面试题(⇀‸↼‶)！！考的是引用类型和运算符优先级。 参考链接：运算符优先级JS指针理解之引用类型（含有运算符表格）JavaScript基础之运算符及全面的运算符优先级总结]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[toString 与 valueOf]]></title>
    <url>%2F2019%2F01%2F10%2Fweb%2Fjs%2F%E5%9F%BA%E7%A1%80%2FtoString%E4%B8%8EvalueOf%2F</url>
    <content type="text"><![CDATA[在 ECMAScript 中，Object 类型是所有它的实例的基础。换句话说，Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。在 ECMAScript 中 Object 是所有对象的基础，因此所有对象都具有 Object 基本的属性和方法。toString() 与 valueOf()就是 Object 基本的方法，也是最常用到的两个方法。其他的属性和方法请自行查阅资料。 toString() 和 valueOf() 红宝书上是这样描述的，我看完之后还是懵逼啊。toString() ：返回对象的字符串表示。valueOf() ：返回对象的字符串、数值或布尔值表示。通常与 toString() 方法的返回值相同。（尤其是这个描述，事实上通常与toString()返回值不一样的啊。） 我在查阅了相关资料：valueOf偏向于运算，toString偏向于显示。1、 在进行强转字符串类型时将优先调用toString方法，强转为数字时优先调用valueOf。2、 在有运算操作符的情况下，valueOf的优先级高于toString。3、 在数值运算中，优先调用了valueOf，字符串运算中，优先调用了toString。 参考链接：Javascript中的valueOf与toString 原生构造函数的 toString() 和 valueOf() 原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。一般这些原生构造函数重写了 toString() 和 valueOf() 方法，返回结果会不一样。所以一般不会直接访问到Object的 toString() 和 valueOf() 上的方法。我在这里整理一下。 配置 toSting() valueOf() Object 返回一个 [object NativeConstructorName] 格式的字符串 对象本身。这是默认情况 Array 将 Array 的元素转换为字符串（调用toSting()）。结果字符串由逗号分隔，且连接起来。Array的toString()跟没有其他参数的join()方法的一样，toString 好像是调用 join 的，当重写（或者delete）Array.prototype.join 再去调用toString()会返回[object Array] 返回数组本身 Date toString()方法通常返回带有时区信息的日期和时间（浏览器不一样，结果会不同） 返回日期的毫秒表示 Boolean 返回 “true”。否则，返回 “false” 返回boolean值 Number 返回数字的字符串表示。toString() 可以方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式。 返回数字 String 返回对象所表示的基本字符串值 返回对象所表示的基本字符串值 Function 返回一个函数的字符串。内置函数一般这种格式 function functionname( ) { [native code] }，自己声明定义的函数 [native code] 会变成代码的。。 返回函数本身 RegExp 返回正则表达式的字面量的字符串表示 返回正则表达式的字面量 Error 返回一个包含相关错误消息的字符串。 返回本身 JS类型转换（强制与隐式）简单描述一下 强制转换（只详细列出了Number()）通过手动进行类型转换，Javascript提供了以下转型函数： 转换为数值类型：Number(mix)、parseInt(string,radix)、parseFloat(string)转换为字符串类型：toString(radix)、String(mix)转换为布尔类型：Boolean(mix) Number(mix)函数，可以将任意类型的参数mix转换为数值类型。其规则为：（1）如果是布尔值，true和false分别被转换为1和0 （2）如果是数字值，返回本身。 （3）如果是null，返回0. （4）如果是undefined，返回NaN。 （5）如果是字符串，遵循以下规则： 1、如果字符串中只包含数字，则将其转换为十进制（忽略前导0） 2、如果字符串中包含有效的浮点格式，将其转换为浮点数值（忽略前导0） 3、如果是空字符串，将其转换为0 4、如果字符串中包含非以上格式，则将其转换为NaN （6）如果是对象，则调用对象的valueOf()方法，然后依据前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，再次依照前面的规则转换返回的字符串值。 隐式转换ECMA-262 描述了一组用于操作数据值的操作符，包括算术操作符（如加号和减号）、位操作符、关系操作符和相等操作符。ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字符串、数字值、布尔值，甚至对象。不过，在应用于对象时，相应的操作符通常都会调用对象的 valueOf()和（或）toString() 方法，以便取得可以操作的值。 隐式类型转换就在这些时候出现了！（大部分是数值转的）这里我列出几个比较特殊情况的。（详细规则请参考红宝书第三章操作符） 一元加操作符（+）（-）对非数值应用一元加操作符时，该操作符会像 Number() 转型函数一样对这个值执行转换。 乘性操作符（*）如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值。 加性操作符 加法运算是自左向右的只有一个操作数是字符串，则将另一个操作数转换为字符串。如果有一个操作数是对象、数值或布尔值，则调用它们的 toString() 方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于 undefined 和 null ，则分别调用 String() 函数并取得字符串 “undefined” 和 “null” 。 《Effective JavaScript》P11：当+用在连接字符串时，当一个对象既有toString方法又有valueOf方法时候，JS通过盲目使用valueOf方法来解决这种含糊。对象通过valueOf方法强制转换为数字，通过toString方法强制转换为字符串 12console.log(1 + &#123;&#125;) // 1[object Object]console.log('' + &#123;toString:()=&gt;'S',valueOf:()=&gt;'J'&#125;) // J +连接一个字符串或者是数字的时候，如果我们没有重新定义valueOf和toString，其隐式转换会调用默认的toString()方法，将函数本身内容作为字符串返回;如果我们自己重新定义toString/valueOf方法，那么其转换会按照我们的定义来，其中valueOf比toString优先级更高!!! 关系操作符 小于（&lt;）、大于（&gt;）、小于等于（&lt;=）和大于等于（&gt;=）如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。 参考链接：JS类型转换（强制和自动的规则）JS 中可以提升幸福度的小技巧一篇文章搞懂toString() 和 valueOf()]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js检测类型]]></title>
    <url>%2F2019%2F01%2F09%2Fweb%2Fjs%2F%E5%9F%BA%E7%A1%80%2Fjs%E6%A3%80%E6%B5%8B%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[简单总结一下红宝书中检测数据类型方法。 typeOf 操作符 要检测一个变量是不是基本数据类型？typeof 操作符是最佳的工具。说得更具体一点， typeof 操作符是确定一个变量是字符串、数值、布尔值，还是 undefined 的最佳工具。 ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型—— typeof 就是负责提供这方面信息的操作符。对一个值使用 typeof 操作符可能返回下列某个字符串： “undefined” —— 如果这个值未定义； “boolean” —— 如果这个值是布尔值； “string” —— 如果这个值是字符串； “number” —— 如果这个值是数值； “object” —— 如果这个值是对象或 null； “function” —— 如果这个值是函数。 12345678910var message = "hello";alert(typeof message); // "string"alert(typeof(message)); // "string"alert(typeof 233); // "number"alert(typeof null); // "object"var msg; // 未初始化变量alert(typeof msg); //"undefind"// 未声明的变量alert(typeof ms); //"undefind" instanceof 操作符虽然在检测基本数据类型时 typeof 是非常得力的助手，但在检测引用类型的值时，这个操作符的用处不大。通常，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript提供了 instanceof 操作符，其语法如下所示： result = variable instanceof constructor variable 变量是给定引用类型（根据它的原型链来识别）的实例，那么 instanceof 操作符就会返回 true 。所有引用类型的值都是 Object 的实例。因此，在检测一个引用类型值和 Object 构造函数时(variable instanceof Object)， instanceof 操作符始终会返回 true 。 总结确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用instanceof 操作符。 安全的类型检测 使用 Object 原生的 toString() 方法在任何值上调用 Object 原生的 toString() 方法，都会返回一个 [object NativeConstructorName] 格式的字符串。每个类在内部都有一个 [[Class]] 属性，这个属性中就指定了上述字符串中的构造函数名。 1alert(Object.prototype.toString.call([1,2,3])); //"[object Array]" 检测原生 JSON 对象这一技巧也广泛应用于检测原生 JSON 对象。 Object 的 toString() 方法不能检测非原生构造函数的构造函数名。因此，开发人员定义的任何构造函数都将返回[object Object]。有些 JavaScript 库会包含与下面类似的代码。 1var isNativeJSON = window.JSON &amp;&amp; Object.prototype.toString.call(JSON) == "[object JSON]"; 使用 constructor 属性1console.log([].constructor); // ƒ Array() &#123; [native code] &#125; 实例的 proto 指针指向构造函数的原型对象。Object.getPrototypeOf()与proto相同，用来获取一个对象的prototype对象。 通过proto指针访问到是那个构造函数的原型对象，然后通过这个原型对象的 constructor（所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。）可以知道是什么引用类型了。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新年快乐！]]></title>
    <url>%2F2019%2F01%2F01%2Fblog%2F2019%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Comet]]></title>
    <url>%2F2018%2F12%2F31%2Fweb%2FComet%2F</url>
    <content type="text"><![CDATA[Comet 是 Alex Russell 发明的一个词儿，指的是一种更高级的 Ajax 技术（经常也有人称为“服务器推送”）。 Ajax 是一种从页面向服务器请求数据的技术，而 Comet 则是一种服务器向页面推送数据的技术。 Comet 能够让信息近乎实时地被推送到页面上，非常适合处理体育比赛的分数和股票报价。 两种实现 Comet 的方式： 长轮询和流长轮询长轮询把短轮询颠倒了一下。页面发起一个到服务器的请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据之后，浏览器关闭连接，随即又发起一个到服务器的新请求。这一过程在页面打开期间一直持续不断。 长轮询和短轮询的区别长轮询是传统轮询（也称为短轮询）的一个翻版，即浏览器定时向服务器发送请求，看有没有更新的数据。 两者最大的区别 在于服务器如何发送数据。短轮询是服务器立即发送响应，无论数据是否有效，而长轮询是等待发送响 应。轮询的优势是所有浏览器都支持，因为使用 XHR 对象和 setTimeout()就能实现。而你要做的就 是决定什么时候发送请求。 HTTP 流流不同于上述两种轮询，因为它在页面的整个生命周期内只使用一个 HTTP 连接。具体来说，就是浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据。 1234567891011121314for($j = 1; $j &lt;= 10; $j++) &#123; echo $j." "; ob_flush();flush(); // flush()刷新缓冲区的内容，输出。这一步会使缓冲区新增的内容被挤出去，显示到浏览器上 sleep(1); //等1秒钟&#125; for ($i=10; $i&gt;2; $i--)&#123; echo $i.'&lt;br /&gt;'; ob_flush(); flush(); sleep(1);&#125;ob_end_flush(); 所有服务器端语言都支持打印到输出缓存然后刷新（将输出缓存中的内容一次性全部发送到客户端）的功能。而这正是实现 HTTP 流的关键所在。 通过侦听 readystatechange 事件及检测 readyState 的值是否为 3，就可以利用 XHR 对象实现 HTTP 流。在上述这些浏览器中，随着不断从服务器接收数据， readyState 的值会周期性地变为 3。 SSE（Server-Sent Events，服务器发送事件） SSE（Server-Sent Events，服务器发送事件）是围绕只读 Comet 交互推出的 API 或者模式。 SSE API用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。服务器响应的 MIME 类型必须是 text/event-stream，而且是浏览器中的 JavaScript API 能解析格式输出。 SSE 支持短轮询、长轮询和 HTTP 流，而且能在断开连接时自动确定何时重新连接。 SSE API要预订新的事件流，首先要创建一个新的 EventSource 对象，并传进一个入口点： 1var source = new EventSource("myevents.php") // 注意，传入的 URL 必须与创建对象的页面同源（相同的 URL 模式、域及端口）。 EventSource 的实例有一个 readyState 属性，值为 0 表示正连接到服务器，值为 1 表示打开了连接，值为 2 表示关闭了连接。 还有以下三个事件。 open：在建立连接时触发。 message：在从服务器接收到新事件时触发。 error：在无法建立连接时触发。 close() 强制立即断开连接默认情况下， EventSource 对象会保持与服务器的活动连接。如果连接断开，还会重新连接。这就意味着 SSE 适合长轮询和 HTTP 流。如果想强制立即断开连接并且不再重新连接，可以调用 close() 方法。 1source.close(); 事件流所谓的服务器事件会通过一个持久的 HTTP 响应发送，这个响应的 MIME 类型为 text/event-stream。响应的格式是纯文本，最简单的情况是每个数据项都带有前缀 data:。 通过 id:前缀可以给特定的事件指定一个关联的 ID，这个 ID 行位于 data:行前面或后面皆可：data: fooid: 1设置了 ID 后， EventSource 对象会跟踪上一次触发的事件。如果连接断开，会向服务器发送一个包含名为 Last-Event-ID 的特殊 HTTP 头部的请求，以便服务器知道下一次该触发哪个事件。在多次连接的事件流中，这种机制可以确保浏览器以正确的顺序收到连接的数据段。 Web Sockets Web Sockets 的目标是在一个单独的持久连接上提供全双工、双向通信。在 JavaScript 中创建了 Web Socket 之后，会有一个 HTTP 请求发送到浏览器以发起连接。在取得服务器响应后，建立的连接会使用 HTTP 升级从 HTTP 协议交换为 Web Socket 协议。也就是说，使用标准的 HTTP 服务器无法实现 Web Sockets，只有支持这种协议的专门服务器才能正常工作。 Web Sockets API要创建 Web Socket，先实例一个 WebSocket 对象并传入要连接的 URL：12// 注意，必须给 WebSocket 构造函数传入绝对 URL。同源策略对 Web Sockets 不适用，因此可以通过它打开到任何站点的连接。至于是否会与某个域中的页面通信，则完全取决于服务器。var socket = new WebSocket("ws://www.example.com/server.php"); 与 XHR 类似， WebSocket 也有一个表示当前状态的 readyState 属性。不过，这个属性的值与 XHR 并不相同，而是如下所示。 WebSocket.OPENING (0)：正在建立连接。 WebSocket.OPEN (1)：已经建立连接。 WebSocket.CLOSING (2)：正在关闭连接。 WebSocket.CLOSE (3)：已经关闭连接。 WebSocket 没有 readystatechange 事件；不过，它有其他事件，对应着不同的状态。readyState的值永远从 0 开始。要关闭 Web Socket 连接，可以在任何时候调用 close()方法。 1socket.close(); 调用了 close()之后， readyState 的值立即变为 2（正在关闭），而在关闭连接后就会变成 3 发送和接收数据Web Socket 打开之后，就可以通过连接发送和接收数据。要向服务器发送数据，使用 send()方法并传入任意字符串。 123var socket = new WebSocket("ws://www.example.com/12.php");socket.send("Hello world!"); 因为 Web Sockets 只能通过连接发送纯文本数据，所以对于复杂数据结构，在通过连接发送之前，必须进行序列化。服务器要读取其中的数据，就要解析接收到的 JSON 字符串. 事件WebSocket 对象几个事件，在连接生命周期的不同阶段触发。 message：当服务器向客户端发来消息时触发 open：在成功建立连接时触发。 error：在发生错误时触发，连接不能持续。 close：在连接关闭时触发。 WebSocket 对象不支持 DOM 2 级事件侦听器，因此必须使用 DOM 0 级语法分别定义每个事件处理程序。 只有 close 事件的 event 对象有额外的信息。这个事件的事件对象有三个额外的属性： wasClean、 code 和 reason。其中，wasClean 是一个布尔值，表示连接是否已经明确地关闭；code 是服务器返回的数值状态码；reason 是一个字符串，包含服务器发回的消息。 参考资料：JavaScript高级程序设计]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript动态解析和执行字符串]]></title>
    <url>%2F2018%2F12%2F28%2Fweb%2Fjs%2F%E5%9F%BA%E7%A1%80%2FJavaScript%E5%8A%A8%E6%80%81%E8%A7%A3%E6%9E%90%E5%92%8C%E6%89%A7%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[在JavaScript中eval和new Function都可以动态解析和执行字符串。但两者有一定的区别。我这里总结一下自己了解的相关知识点。 eval()整个ECMAScript语言中最强大的一个方法eval()。eval()方法就像是一个完整的 ECMAScript 解析器，它只接受一个参数，即要执行的ECMAScript（或 JavaScript）字符串。 1eval("alert('Hello World!')"); 当解析器发现代码中调用 eval() 方法时，它会将传入的参数当作实际的 ECMAScript 语句来解析，然后把执行结果插入到原位置。通过 eval() 执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过 eval() 执行的代码可以引用在包含环境中定义的变量。案例 Function 构造函数使用 Function 构造函数定义函数的方式。 Function 构造函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数。 1var test = new Function("arg1", "arg2", "return arg1 + arg2"); eval和new Function在JavaScript中动态解析和执行字符串时我们可以用到eval和new Function。 123var data = '&#123;a:1,b:2&#125;'；console.log(eval('('+data+')'));console.log((new Function('return' + data))()); eval和new Function的区别。eval中的代码执行时的作用域为当前作用域。它可以访问到函数中的局部变量。new Function中的代码执行时的作用域为全局作用域，不论它的在哪个地方调用的。 123456789var x = 'global';function a() &#123; var x = 'local' eval('console.log(x)') ;(new Function('console.log(x)'))()&#125;a()// local// global 问题：eval(‘(‘+jsondata+’)’)为什么还要加’(‘和’)’由于json是以”{}“的方式来开始以及结束的，在JS中，它会被当成一个语句块来处理，所以必须强制性的将它转换成一种表达式。加上圆括号的目的是迫使eval函数在处理JavaScript代码的时候强制将括号内的表达式（expression）转化为对象，而不是作为语句（statement）来执行。 扩展 function与感叹号平时我们可能对使用感叹号 (!) 或者添加括号来调用匿名函数： 123!function()&#123;alert('iifksp')&#125;() // true(function()&#123;alert('iifksp')&#125;())(function()&#123;alert('iifksp')&#125;)() 其实无论是括号，还是感叹号，让整个语句合法做的事情只有一件，就是让一个函数声明语句变成了一个表达式。 使用括号包裹定义函数体，解析器将会以函数表达式的方式去调用定义函数。也就是说，任何能将函数变成一个函数表达式的作法，都可以使解析器正确的调用定义函数。而 ! 就是其中一个，而 + - || 等都有这样的功能。 参考：https://swordair.com/function-and-exclamation-mark/]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx（六）进阶 高级模块 （secure_link和geoip）]]></title>
    <url>%2F2018%2F12%2F26%2Fnginx%2FNginx6%2F</url>
    <content type="text"><![CDATA[secure_link_module 模块ngx_http_secure_link_module模块用于检查请求链接的真伪，保护资源免受未经授权的访问，并限制链接的寿命。 该模块提供两种备选操作模式。第一种模式由secure_link_secret指令启用，用于检查请求链接的真实性以及保护资源免受未经授权的访问。第二种模式由secure_link和secure_link_md5指令启用， 可以用于限制链接的生命周期。 默认情况下不构建此模块，应使用–with-http_secure_link_module 配置参数启用它。 制定并允许检查请求的链接的真实性以及保护资源避遭未经授权的访问 限制链接生效周期 123456789101112131415161718location /s/ &#123; #资源链接由后端生成，请求中传递的MD5哈希值以base64url编码。 # secure_link定义一个包含变量的字符串，从中提取链接的校验和值和生命周期。 secure_link $arg_md5,$arg_expires; # $secure_link_expiress是请求中传递的链接的生命周期;仅用于secure_link_md5指令。 secure_link_md5 &quot;$secure_link_expires$uri$remote_addr secret&quot;; # 将从字符串中提取的校验和值与secure_link_md5指令定义的表达式的MD5哈希值进行比较。如果校验和不同，则将$secure_link变量设置为空字符串。如果校验和相同，则检查链路生存期。请求中传递的MD5哈希值以base64url编码。 if ($secure_link = &quot;&quot;) &#123; return 403; &#125; if ($secure_link = &quot;0&quot;) &#123; return 410; &#125; ...&#125; geoip_module 模块http_geoip_module模块会机遇IP地址匹配MaxMind GeoIP二进制文件，读取IP所在地域信息。 默认情况下不构建此模块，应使用–with-http_geoip_module 配置参数启用它。 使用场景 区别国内外作HTTP访问规则 区别国内城市地域作HTTP访问规则 Centos 进行安装使用geoip_module yum安装 （记得配置nginx的源，安装nginx前应该已经配置好了） yum install nginx-module-geoip 安装完成到 /etc/nginx/modules 目录可以看到geoip_module相关文件 在nginx配置文件中动态加载geoip_module 12load_module &quot;module/ngx_http_geoip_module.so&quot;;load_module &quot;module/ngx_stream_geoip_module.so&quot;; 到 MaxMind 下载IP地域文件（GeoLite2 City和GeoLite2 Country） 解压 注意：MaxMind从2018年4月1日起停止更新GeoLite Legacy数据库。GeoLite Legacy数据库不再可供下载。尝试下载GeoLite Legacy数据库文件将导致错误：”找不到数据库版本”。现在只能下载GeoLite2数据库了,GeoLite2数据库是GeoLite Legacy地理定位数据库的免费，更现代的版本。 在配置文件中配置geoip_module的 geoip_country 和 geoip_city 指令 （两个指令都在http块配置） 12geoip_country /yourPath/GeoLite2-Country.mmdb;geoip_city /yourPath/GeoLite2-City.mmdb; 现在已经可以读取客户端的IP所在地域信息啦，详细参数请到这里查看 $geoip_country_code 两个字母的国家/地区代码 $geoip_country_code3 三个字母的国家/地区代码 $geoip_country_name 国家/地区名称 $geoip_city 城市名称]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[File API]]></title>
    <url>%2F2018%2F12%2F20%2Fweb%2Fjs%2FFileAPI%2F</url>
    <content type="text"><![CDATA[在HTML5中新增了File API，用于表示Web应用程序中的文件对象，以及以编程方式选择它们并访问它们的数据。做一下简单的总结。有兴趣的可以访问网站详细了解。 FileListFileList 对象针对表单的 file 控件。当用户通过 file 控件选取文件后，这个控件的 files 属性值就是 FileList 对象。 123456&lt;input type='file' multiple id="fileInput" /&gt;&lt;script&gt; document.getElementById('fileInput').onchange = function() &#123; console.log(this.files) &#125;&lt;/script&gt; 除了用 file 控件，采用[拖放方式]，也可以得到 FileList 对象。 1234567891011var dropZone = document.getElementById('drop_zone');dropZone.addEventListener('drop', handleFileSelect, false);function handleFileSelect(evt) &#123; evt.stopPropagation(); evt.preventDefault(); var files = evt.dataTransfer.files; // FileList object. // ...&#125; 上面代码的 handleFileSelect 是拖放事件的回调函数，它的参数evt是一个事件对象，该参数的dataTransfer.files属性就是一个FileList对象，里面包含了拖放的文件。 FileFile对象可以用来获取某个文件的信息，还可以用来读取这个文件的内容。通常情况下，File对象是来自用户在一个 &lt;input/&gt;元素上选择文件后返回的FileList对象，也可以是来自由拖放操作生成的DataTransfer对象。 File 对象含有以下属性值： name：文件名，该属性只读 size：文件大小，单位为字节，该属性只读 type：文件的 MIME 类型，如果分辨不出类型，则为空字符串，该属性只读 lastModified：文件的上次修改时间，格式为时间戳 lastModifiedDate：文件的上次修改时间，格式为 Date 对象实例 BlobFile 对象是继承自 Blob 对象的。Blob（Binary Large Object）对象代表了一段二进制数据，提供了一系列操作接口。其他操作二进制数据的 API（比如 File 对象），都是建立在 Blob 对象基础上的，继承了它的属性和方法。 Blob构造函数，接受两个参数。第一个参数是一个包含实际数据的数组第二个参数是数据的类型，这两个参数都不是必需的。数组元素可以是任意多个的ArrayBuffer，ArrayBufferView (typed array)， Blob，或者 DOMString对象。 生成 Blob 对象有两种方法：一种是使用 Blob 构造函数，另一种是对现有的 Blob 对象使用 slice 方法切出一部分。 Blob 对象有两个只读属性： size：二进制数据的大小，单位为字节。（文件上传时可以在前端判断文件大小是否合适） type：二进制数据的 MIME 类型，全部为小写，如果类型未知，则该值为空字符串。（文件上传时可以在前端判断文件类型是否合适） 123var arr = ['hello world'];var blob = new Blob(arr, &#123; "type" : "text/plain" &#125;); // the blobconsole.log(blob); FileReaderFileReader对象用于读取文件，即把文件内容读入内存。它的参数是 File 对象或 Blob 对象。对于不同类型的文件，FileReader 提供不同的方法读取文件。 readAsBinaryString(Blob|File)：返回二进制字符串，该字符串每个字节包含一个0到255之间的整数。 readAsText(Blob|File, encode)：返回文本字符串。默认情况下，文本编码格式是 UTF-8，可以通过可选的格式参数，指定其他编码格式的文本 readAsDataURL(Blob|File)：返回一个基于 Base64 编码的 data-uri 对象（可用于 &lt;img&gt; 标签中的 src 属性，从而达到上传图片预览的效果） readAsArrayBuffer(Blob|File)：返回一个 ArrayBuffer 对象 FileReader 对象采用异步方式读取文件，内置回调函数。 onabort 方法：读取中断或调用 reader.abort() 方法时触发。 onerror 方法：读取出错时触发。 onload 方法：读取成功后触发。 onloadend 方法：读取完成后触发，不管是否成功。触发顺序排在 onload 或 onerror 后面。 onloadstart 方法：读取将要开始时触发。 onprogress 方法：读取过程中周期性触发。（可以用来获取文件读取的进度） 1234567891011var reader = new FileReader();reader.onload = function(e) &#123; console.log(reader.result) console.log(e.target.result) var text = reader.result;&#125;var arr = ['hello world'];var blob = new Blob(arr, &#123; "type" : "text/plain" &#125;); // the blob// console.log(blob);var encoding = 'UTF-8'reader.readAsText(blob, encoding); URL 除了可以使用base64字符串作为内容的DataURI将一个文件嵌入到另外一个文档里，还可以使用URL对象。URL对象用于生成指向File对象或Blob对象的URL。 1window.URL URL.createObjectURL() 该方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。 1objectURL = URL.createObjectURL(blob); URL.revokeObjectURL() 该方法用来释放一个之前通过调用 URL.createObjectURL() 创建的已经存在的 URL 对象。当你结束使用某个 URL 对象时，应该通过调用这个方法来让浏览器知道不再需要保持这个文件的引用了。 12// objectURL 是一个 DOMString，表示通过调用 URL.createObjectURL() 方法产生的 URL 对象window.URL.revokeObjectURL(objectURL); FormData用 FormData 对象,我们可以通过JavaScript用一些键值对来模拟一系列表单控件,我们还可以使用XMLHttpRequest的send()方法来异步的提交这个”form”.比起普通的ajax,使用FormData的最大优点就是我们可以异步上传一个二进制文件。 1new FormData (form? : HTMLFormElement) form 参数可选，是一个HTML表单元素，可以包含任何形式的表单控件,包括文件输入框。 方法append() 给当前FormData对象添加一个键/值对 1 void append(DOMString 键, Blob 值, [可选] DOMString 文件名);2 void append(DOMString 键, DOMString 值); name 字段名称 value 字段值，可以是Blob value，或者一个字符串，如果全都不是，则该值会被自动转换成字符串 参考链接：JavaScript进阶学习（三）—— 基于html5 File API的文件操作Html5——File、FileReader、Blob、Fromdata对象文件和二进制数据的操作https://developer.mozilla.org/zh-CN/docs/Web/API/FormData FormData]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx（五）进阶 Rewrite]]></title>
    <url>%2F2018%2F12%2F14%2Fnginx%2FNginx5%2F</url>
    <content type="text"><![CDATA[动静分离 通过中间件将动态请求和静态请求分离分离资源，减少不必要的请求消耗，减少请求延时。 Rewrite 重写规则场景 URL访问跳转，支持开发设计（页面跳转、兼容性支持、展示效果等） SEO优化 维护（后台维护、流量转发等） 安全（伪静态） 常用配置语法 ngx_http_rewrite_modulerewrite 指令123456789Syntax: rewrite regex（正则） replacement（替换成的） [flag];Default: —Context: server, location, if# flag 参数# last 停止rewrite检测 并开始搜索与更改的URI匹配的新位置# break 停止rewrite检测，停止处理当前的指令集# redirect 返回302临时重定向，地址栏会显示跳转后的地址# permanent 返回301永久重定向，地址栏会显示跳转后的地址 if 指令123Syntax: if (condition) &#123; ... &#125;Default: —Context: server, location 如果变量的值为空字符串或”0”，则为false ; 使用”=”和”!=”运算符比较变量和字符串; 使用”~”（对于区分大小写的匹配）和”~“（对于不区分大小写的匹- 配）运算符，将变量与正则表达式进行匹配。正则表达式可以包含可供以后在$1.. $9变量中重用的捕获。负操作符”!~”和”!~“也可用。如果正则表达式包含”}”或”;”字符，则整个表达式应包含在单引号或双引号中。 使用”-f”和”!-f”运算符检查文件是否存在; 使用”-d”和”!-d”运算符检查目录是否存在; 使用”-e”和”!-e”运算符检查文件，目录或符号链接是否存在; 使用”-x”和”!-x”运算符检查可执行文件。 123if (!-e $request_filename)&#123; rewrite ^(.*)$ /index.php?s=$1 last; break;&#125; return 指令停止处理并将指定的内容返回code给客户端。非标准代码444在不发送响应头的情况下关闭连接。 Syntax: return code [text]; return code URL; return URL; Default: — Context: server, location, if 123location / &#123; return 200 &apos;233&apos;;&#125; set 指令设置一个变量，该变量的value可以包含文本，变量，文本和变量的组合。 Syntax: set $variable value; Default: — Context: server, location, if Rewrite 规则优先级 执行server块的rewrite指令 执行location匹配 执行location块的rewrite指令]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当初就不该学PHP]]></title>
    <url>%2F2018%2F12%2F12%2FPHP%2F%E5%BD%93%E5%88%9D%E5%B0%B1%E4%B8%8D%E8%AF%A5%E5%AD%A6PHP%2F</url>
    <content type="text"><![CDATA[舍友推荐的一首歌，真的扎心了。这里附上他的博客 有兴趣的去逛一逛哈。 当初就不该学php – 黄灰红 词 : 黄绿蓝 曲 : 黄绿蓝 2013的某一天 他认识了PHP 可他从不敢相信 那是噩梦的开启 2015的某一天 加班到无法休息 忙里偷闲打开微信 却没人发消息 2017的某一天 面试之前认真复习 上上知乎问问建议 当初就不该学PHP 他们说用Python的 看不起用Java的啊 Java的也只能骂PHP啦 就算你们都是用Python的呀 Python3和Python2也势不两立啊 用AS的看不起用Eclipse的啊 可苹果也看不起做Android的 Vim和Emacs吵个不停啦 还天天骂Sublime的智障吗 用React的看不起用Angular的 Git用户天天骂SVN傻瓜 Docker用户说 Puppet是上个世纪的吗 用图形界面不用命令 智商不够用吗 用Debian的瞧不起用Ubuntu的 用MBP的说用win没钱吗 BAT的说小公司也算公司吗 独角兽说我分十亿你分得起吗 黑轴茶轴天天纠缠不休啊 难怪双飞燕的妹子插不上话 坐Aeron的看不起坐办公椅的 站着打代码的说你俩会长胖的 985的看不起211的啊 他们还天天骂北大青鸟呢 考计算机二级是有病吗 Gayhub没有一千星星别来丢人啦 啊别再骂啦 女朋友呢 找到了吗]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx（四）常见Nginx架构场景]]></title>
    <url>%2F2018%2F12%2F10%2Fnginx%2FNginx4%2F</url>
    <content type="text"><![CDATA[常见Nginx中间件架构 静态资源web服务 代理服务 负载均衡调度器SLB 动态缓存 静态资源web服务 （优化配置之类的）ngx_http_core_module 模块的 Directive sendfile “零拷贝” ngx_http_core_module sendfile系统调用在两个文件描述符之间直接传递数据(完全在内核中操作)，从而避免了数据在内核缓冲区和用户缓冲区之间的拷贝，操作效率很高，被称之为零拷贝。 Syntax：sendfile on | off; Default：sendfile off; Context：http，server，location，if in location tcp_nopush 仅在使用sendfile时才启用这个选项。提高网络包的传输效率。 Syntax：sendfile on | off; Default：sendfile off; Context：http，server，location，if in location tcp_nodelay keep-alive连接下，提高网络包的传输实时性。 Syntax: tcp_nodelay on | off; Default: tcp_nodelay on; Context: http, server, location ngx_http_gzip_module 压缩模块的 Directive （详细指令语法，参考官方文档） gzip 压缩压缩 Syntax: gzip on | off; Default: gzip off; Context: http, server, location, if in location 扩展Nginx压缩模块 http_gzip_static_module - 预读gzip功能（访问预先压缩好的文件。） http_gunzip_module - 应用支持gunzip的压缩方式（兼容不支持gzip的浏览器） 浏览器缓存校验是否过期Expires(HTTP1.0)、Cache-Control(HTTP1.1) 没有过期直接在从缓存中读取，不会请求服务端，下面两个头信息会请求服务端判断是否修改了文件协议中的Eta头信息校验EtagLast—Modified头信息校验Last—Modified ngx_http_headers_module 模块允许将”Expires”和”Cache-Control”头字段和任意字段添加到响应头！！。 Syntax: expires [modified] time; expires epoch | max | off; Default: expires off; Context: http, server, location, if in location 跨域访问 CORS (Access-Control-Allow-Origin) 注意 CSRF 攻击哦 12add_header Access-Control-Allow-Origin *;add_header Access-Control-Allow-Methods GET,POST,PUT; 防盗链 目的：防止资源被盗用 基于http_referer防盗链配置模块valid_referers 指定将嵌入$invalid_referer变量设置为空字符串的&quot;Referer&quot;请求头字段值。否则，变量将设置为&quot;1&quot;(无效的话 变量设置为1，再去判断返回403)。搜索匹配不区分大小写。 Syntax: valid_referers none(可以为空) | blocked(可以不带协议信息) | server_names(服务器名称) | string ... | 正则(eg: ~/aaa/g); Default: — Context: server, location 代理服务ngx_http_proxy_module proxy proxy proxy (列几个常用的指令配置，详细请看官网) 缓存服务（代理缓存） 12345eg: location / &#123; proxy_pass http://localhost:8000; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; # 设置真实的IP请求头信息（X-Real-IP） &#125; proxy_pass 代理地址 Syntax: proxy_pass URL; Default: — Context: location, if in location, limit_except proxy_set_header 设置（发给后端的）请求头信息 Syntax: proxy_set_header field value; Default: proxy_set_header Host $proxy_host; Context: http, server, location proxy_buffering 缓冲区 on | off proxy_next_upstream 指定应将请求传递到下一个服务器 Syntax: proxy_next_upstream error | timeout | invalid_header | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | http_429 | non_idempotent | off ...; Default: proxy_next_upstream error timeout; Context: http, server, location 负载均衡 SLB GSLB: Global Server Load Balance(全局负载均衡)SLB: Server Load Balance(负载均衡)四层（OSI第四层就是传输层）负载均衡，也就是主要通过报文中的目标地址（ip）和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。七层（OSI第七层就是应用层）负载均衡，也称为”内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。 Nginx配置 upstream 实现负载均衡 ngx_http_upstream_module123456789101112131415161718192021upstream backend &#123; server backend1.example.com weight=5; server backend2.example.com:8080; server unix:/tmp/backend3; server backup1.example.com:8080 backup; server backup2.example.com:8080 backup; # server 参数设置 # weight 设置服务器的权重（加权轮询），默认为1 （默认是轮询） 两个都不好，如果在有缓存的情况下用户每次都会访问到不一致的内容。（解决方法看下面的 hash） # down 当前的server展示不参与SLB # backup 预留的备份服务器 # max_fails 允许请求失败的次数 # fail_timeout 经过max_fail失败后，服务暂停的时间（等待响应时间） # max_conns 限制最大的接受的连接数（根据服务器配置按需设置）默认值为零，表示没有限制&#125;server &#123; location / &#123; proxy_pass http://backend; &#125;&#125; upstream Syntax: upstream name { ... } Default: — Context: http hash 指定服务器组的负载平衡方法，其中client-server映射基于散列key值。推荐使用这种方式 Syntax: hash key [consistent]; Default: — Context: upstream ip_hash 每个请求按访问IP的hash结果分配，这样来自同一个IP的固定访问一个后端服务器 缺点：客户端请求将被传递到另一个服务器。最有可能的是，它也将始终是同一台服务器，而非真实的IP。 Syntax: ip_hash; Default: — Context: upstream 缓存服务（代理缓存） 客户端缓存 代理缓存 服务端缓存（redis memcached） Nginx代理缓存配置语法proxy_cache_path 设置缓存的路径和其他参数。Syntax: proxy_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size] [manager_files=number] [manager_sleep=time] [manager_threshold=time] [loader_files=number] [loader_sleep=time] [loader_threshold=time] [purger=on|off] [purger_files=number] [purger_sleep=time] [purger_threshold=time]; Default: — Context: http # 上面部分参数的作用 # path 代理缓存存储路径 # levels 目录层次结构级别 eg: levels=1:2 # keys_zone 所有的活性密钥和关于数据的信息被存储在共享存储器区，其name与size设置，配置keys_zone的参数。1M字节zone可以存储大约8000个密钥。 在proxy_cache配置会用到zone的name。eg: keys_zone=one:10m; # inactive 指定的时间内未访问的缓存数据 将从缓存中删除，无论其新鲜度如何。默认情况下，inactive设置为10分钟。 # max_size 设置的最大缓存大小。超过此大小时，它会删除最近最少使用的数据。 # use_temp_path 临时文件的目录 eg: use_temp_path=off 命令指示NGINX将在缓存这些文件时将它们写入同一个目录下。(并不是关闭临时文件存储) proxy_cache 定义用于缓存的共享内存区域。Syntax: proxy_cache zone | off; Default: proxy_cache off; Context: http, server, location proxy_cache_valid 设置不同响应状态码的缓存时间。eg: proxy_cache_valid 200 302 10m; proxy_cache_valid 404 1m; proxy_cache_valid any 1h; # any 指定缓存任何响应 proxy_cache_valid 5m; # 只缓存200,301和302的响应。 Syntax: proxy_cache_valid [code ...] time; Default: — Context: http, server, location proxy_no_cache 定义不将响应保存到缓存的条件。 如果字符串参数的至少一个值不为空且不等于”0”，则不会保存响应 Syntax: proxy_no_cache string ...; Default: — Context: http, server, location 清理指定代理缓存 rm -rf 删除缓存目录内容 使用第三方扩展模块ngx_cache_purge 大文件分片请求]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx（三）Nginx官方模块]]></title>
    <url>%2F2018%2F12%2F08%2Fnginx%2FNginx3%2F</url>
    <content type="text"><![CDATA[Nginx模块分类 Nginx官方模块 第三方模块 Nginx官方模块(部分) Modules reference 使用nginx -V 可以看到模块（module）相关的编译参数 –with-XXXXX_module。 ngx_http_stub_status_module 模块提供对基本状态信息的访问 默认情况下不构建此模块，应使用–with-http_stub_status_module 配置参数启用它 Directives：stub_status Syntax：stub_status; Default：- Context：server， location ngx_http_random_index_module 模块处理以斜杠字符（’/‘）结尾的请求，并在目录中选择一个随机文件作为索引文件 默认情况下不构建此模块，应使用–with-http_random_index_module 配置参数启用它 。 Directives：random_index Syntax: random_index on | off; Default: random_index off; Context: location ngx_http_sub_module 模块是一个过滤器，它通过将一个指定的字符串替换为另一个字符串（HTTP内容替换） 默认情况下不构建此模块，应使用–with-http_sub_module 配置参数启用它 。 Directives： sub_filter 设置要替换的字符串和替换字符串。 sub_filter_last_modified 允许在替换期间保留原始响应中的&quot;Last-Modified”头字段，以便于响应缓存。default： sub_filter_last_modified off; sub_filter_once 设置替换一次还是全部替换 default： sub_filter_once on;（替换一次） sub_filter_types 除了&quot;text/html&quot;之外，还在具有指定MIME类型的响应中启用字符串替换。特殊值&quot;*&quot;匹配任何MIME类型。default：sub_filter_types text/html; Syntax: sub_filter string(替换的字符) replacement(替换成的字符); Default: — Context: http, server, location 请求限制模块 连接限制 ngx_http_limit_conn_module limit_conn_zone 设置共享内存区域的参数，该区域将保留各种key的状态。 Syntax: limit_conn_zone key zone=name:size; Default: — Context: http limit_conn 设置共享内存区域和给定键值的最大允许连接数 Syntax: limit_conn zone number; Default: — Context: http, server, location 请求限制 ngx_http_limit_req_module limit_req_zone Syntax: limit_req_zone key zone=name:size rate=rate（请求处理速率） [sync]; Default: — Context: http eg: limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s; limit_req 设置共享内存区域和请求的最大并发。 Syntax: limit_req zone=name [burst=number](限制并发数，默认为0) [nodelay | delay=number](延迟执行); Default: — Context: http, server, location 访问控制模块 基于客户端地址IP的访问控制-ngx_http_access_module Syntax: allow允许|deny拒绝 address | CIDR | unix: | all; Default: — Context: http, server, location, limit_except 局限性 通过其他的中间件（Nginx, 7lay LSB, CDN等）才到达服务端。 采用X-Forwarded-For。 结合geo模块。 通过HTTP自定义变量传递。 基于用户的信任登录-ngx_http_auth_basic_module 打开页面需要填写用户名和密码 Directives: auth_basic auth_basic_user_file 局限性 1.用户信息依赖文件方式 2.操作光临机械，效率低下 解决方法 Nginx结合LUA实现高效验证 Nginx和LDAP打通，利用nginx-auth-ladp模块]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx（二） 默认配置]]></title>
    <url>%2F2018%2F12%2F07%2Fnginx%2FNginx2%2F</url>
    <content type="text"><![CDATA[笔记可能有点乱 最好到官方文档查看相关配置 Nginx 的主配置文件 （一部分主要的配置）默认路径 `/etc/nginx/nginx.conf` (主配置文件) Nginx 的默认配置语法全局块 配置 作用 user 设置nginx服务使用用户 worker_processes 工作进程数（一般设置为和cpu核数一样） error_log 错误日记的目录error_log /var/log/nginx/error.log [info warn notice(级别)] pid 启动时候的pid目录 events块 配置 作用 worker_connections 每个进程允许最大链接数 use I/O多路复用的具体的实现 select, poll, epoll http块 server块 location块 error_page 定义指定错误显示的URI Example: error_page 404 /404.html; error_page 500 502 503 504 /50x.html; Syntax: error_page code ... [=[response]] uri; Default: — Context: http, server, location, if in location location块Syntax: location [ = | ~ | ~* | ^~ ] uri { ... } location @name { ... } Default: — Context: server, location = 修饰符可以定义URI和位置的精确匹配。(优先级从上到下) ^~ 不检查正则表达式，前缀配置 ~ 开头表示区分大小写的正则匹配 ~* 开头表示不区分大小写的正则匹配 !~ 和 !~* 分别为区分大小写不匹配及不区分大小写不匹配的正则 / 通用匹配，任何请求都会匹配到。 日记相关的配置 error_log and access_log 详细到官网查看 log_format 指定日志格式 Syntax: log_format name(规则名) [escape=default|json|none] string ...; Default: log_format combined &quot;...&quot;; Context: http （log_format只在http块的配置） &gt; Nginx变量 &gt; 1. HTTP请求变量 $arg_PARAMETER 请求行的参数 PARAMETER为要获取的那个key值 $http_HEADER 任意请求头字段; HEADER分是字段名称转换为小写，短划线由下划线替换 $sent_http_HEADER 任意响应头字段; HEADER分是字段名称转换为小写，短划线由下划线替换 &gt; 2. 内置变量 Nginx内置的 （太多了，详细看[Embedded Variables](http://nginx.org/en/docs/http/ngx_http_core_module.html#var_status)） &gt; 3. 自定义变量 access.log 记录每一次http请求访问 Syntax: access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]]; access_log off; Default: access_log logs/access.log combined; Context: http, server, location, if in location, limit_except root 和 alias root 设置请求的根目录。 如果必须修改URI， 则应使用alias指令。定义指定路径的替换。 error_page定义将为指定错误显示的URI。uri值可以包含变量。 Syntax: error_page code ... [=[response]] uri; Default: — Context: http, server, location, if in location 会导致内部重定向到指定uri 的客户端请求方法更改为“GET”（对于除“GET”和“HEAD” 之外的所有方法）。此外，可以使用“=response”语法将响应代码更改为另一个，例如： 1error_page 404 =200 /empty.gif（相对路径，相对root的路径）;]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 系统]]></title>
    <url>%2F2018%2F12%2F06%2Flinux%2FLinux%20%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Linux 系统基本上分两大类常用的Linux 系统基本上分两大类 Debian: Ubuntu、Debian 等 RedHat: Centos、Redhat 等 Debian系列 常见的安装包格式 deb 包，安装 deb 包的命令是“dpkg -参数” dpkg(Debian Packager) 包管理工具 apt-get 会解决和安装模块的依赖问 dpkg是用来安装.deb文件,但不会解决模块的依赖关系,且不会关心ubuntu的软件仓库内的软件,可以用于安装本地的deb文件。 apt-get会解决和安装模块的依赖问题,并会咨询软件仓库, 但不会安装本地的deb文件, apt是建立在dpkg之上的软件管理工具。 dpkg(Debian Packager) 用法 (常用的啊) dpkg -i 安装一个包，最好用apt-get啦 dpkg -r 删除软件包（保留其配置信息） dpkg -P 删除一个包（包括配置信息）(⇀‸↼‶) 小心点用 dpkg -S 搜索指定包里面的文件（模糊查询）ヾ(ﾟ∀ﾟゞ) dpkg -s 报告指定包的状态信息 dpkg -L 显示一个包安装到系统里面的文件目录信息 dpkg -l 示所有已经安装的Deb包，同时显示版本号以及简短说明 参考链接 RedHat 系列 常见的安装包格式 rpm 包，安装rpm包的命令是“rpm -参数” 包管理工具 yum, yum是rpm的前端程序，主要目的是设计用来自动解决rpm的依赖关系 rpm用法 (常用) rpm -ivh name.rpm #i表示安装，v表示显示安装过程，h表示显示进度 rpm -Uvh name.rpm 升级 rpm -e NAME 删除 rpm -q NAME 查询（-q query） rpm -ql NAME 列出rpm包的文件内容(文件路径) ヾ(ﾟ∀ﾟゞ) rpm -qi NAME 列出已安装的这个包的标准详细信息 安装软件yum安装的优缺点优点：安装东西，方便快捷，特别是不用考虑包依赖缺点：安装过程，人为无法干预，不能按需，安装。源里面有什么就安装什么，安装的版本也比较低。 源码包安装的优缺点优点：编译安装过程，可以设定参数，按照需求，进行安装，并且安装的版本，可以自己选择，灵活性比较大缺点：由于安装包过新或者是其他问题，导致依赖的包没有，或者版本过低。这个时候就要解决包的依赖问题，linux系统中有的包，一个依赖一个，可能装一个小东西，就要解决一堆包的依赖问题，花很多时间解决包的依赖问题，得不尝失。 参考链接：make 和 make install 的区别Linux通过源码编译安装程序；yum和源码安转软件包的区别 Linux操作系统版本 查看内核版本命令cat /proc/version uname 查看Linux版本 lsb_release -a 参考：https://blog.csdn.net/shuaigexiaobo/article/details/78030008https://www.cnblogs.com/wzk-0000/p/7483262.html 基本目录/usr, /etc, /var, /home, /root /usr (UNIX software resource) 与软件安装/执行相关 /etc 配置文件 /var (variable) 与系统运行有关 （一些） /var/log/ 登录文件放置目录（日记记录等） /var/cache/ 应用程序本身运行过程中产生的缓存文件 /var/lib/ 程序执行过程中产生的数据文件放置的目录， eg: MySQL的数据库放置到/var/lib/mysql /home 系统默认的用户主目录 /root 系统管理员的主目录 脚本目录 /bin 存放系统的一些脚本指令 /sbin 一般是指超级用户脚本指令 /usr/bin 后期安装的一些软件的运行脚本 /usr/sbin 系统管理员必备的运行脚本 /etc/init.d 是 /etc/rc.d/init.d 的软链接(soft link) 服务脚本 eg: service nginx [start|stop|restart|reload|..]]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx（一）安装、相关目录与编译参数]]></title>
    <url>%2F2018%2F12%2F06%2Fnginx%2FNginx1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Nginx (engine x) 是一个高性能的HTTP和反向代理服务，也是一个IMAP/POP3/SMTP服务。我使用的是CentOS 6系统，Nginx1.14.2的版本。 Nginx优势 [I/O多路复用]epoll I/O multiplexing 这里面的 multiplexing 指的其实是在**单个线程**通过记录跟踪每一个Sock(I/O流)的状态(对应空管塔里面的Fight progress strip槽)来同时管理多个I/O流。 ngnix会有很多链接进来， epoll会把他们都监视起来，然后像拨开关一样，谁有数据就拨向谁，然后调用相应的代码处理。 select, poll, epoll 都是I/O多路复用的具体的实现。epoll 可以说是I/O 多路复用最新的一个实现，epoll 修复了poll 和select绝大部分问题。 轻量级 功能模块少 代码模块化 CPU亲和性(affinity) sendfile: Linux中的”零拷贝” Linux系统安装Nginx window系统直接到官网下载，配置一下环境变量就可以用啦 版本 Mainline version 开发板 Stable version 稳定版 Legacy version 历史版本 使用yum安装 增加yum源 /etc/yum.repos.d/nginx.repo123456# 替换"OS"成"rhel"或"centos"，，"OSRELEASE"成"6"或"7"，分别为6 x或7.x的版本。[nginx]name=nginx repobaseurl=http://nginx.org/packages/OS/OSRELEASE/$basearch/gpgcheck=0enabled=1 文件目录 ( 使用 rpm -ql nginx || dpkg -S nginx 查看 ) eg：注意版本不同可能会有区别 (￣▽￣)~*，下面是使用1.14.2版本的 路径 类型 作用 /etc/logrotate.d/nginx 配置文件 Nginx日记轮转，用于logrotate服务的日记切割 /etc/nginx/nginx.conf(主配置文件)/etc/nginx/nginx.d/default.conf /etc/nginx/nginx.d/ 目录、配置文件 Nginx主配置文件 /etc/nginx/fastcgi_params/etc/nginx/uwsgi_params/etc/nginx/scgi_params 配置文件 cgi配置，fastcgi配置 /etc/nginx/mime.types 配置文件 设置http协议的Content-Type与扩展名对应关系 /lib/systemd/system/nginx.service 配置文件 用于配置系统守护进程(daemon)管理器管理方式 /usr/share/nginx/modules/etc/nginx/modules-available/etc/nginx/modules-enabled 目录 Nginx模块目录 /usr/sbin/nginx 命令 Nginx服务的启动管理命令 /usr/share/doc/usr/share/man/man8/nginx.8.gz 文件、目录 手册和帮助文件 /var/lib/nginx 目录 Nginx的缓存目录？Nginx缓存服务 /var/log/nginx 目录 Nginx的日记目录 Nginx日记 nginx 安装编译参数 (nginx -V查看) eg：版本不同可能会有区别 (￣▽￣)~*，我使用的是1.14.2版本 编译选项 作用 –prefix=/usr/share/nginx–conf-path=/etc/nginx/nginx.conf–http-log-path=/var/log/nginx/access.log–error-log-path=/var/log/nginx/error.log–lock-path=/var/lock/nginx.lock–pid-path=/run/nginx.pid–modules-path=/usr/lib/nginx/modules 有什么作用，看看就懂了 –http-client-body-temp-path=/var/lib/nginx/body–http-fastcgi-temp-path=/var/lib/nginx/fastcgi–http-proxy-temp-path=/var/lib/nginx/proxy–http-scgi-temp-path=/var/lib/nginx/scgi–http-uwsgi-temp-path=/var/lib/nginx/uwsgi 执行对应模块是，nginx所产生保留的临时性文件 nginx 常用命令 (help)123456# nginx -V 显示版本和配置选项# nginx -t 测试配置# nginx -c 用来指定启动Nginx服务使用的配置文件（默认值：/etc/nginx/nginx.conf）# nginx -p prefix路径 用来改变Nginx的安装路径，常用在平滑升级Nginx服务器的场合# nginx -g 'directives' 用来补充Nginx配置文件，向Nginx服务指定启动时应用于全局的配置。eg: nginx -g 'daemon off'# nginx -s signal 用来向Nginx服务的主进程发送信号 stop, quit, reopen, reload]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker 学习笔记]]></title>
    <url>%2F2018%2F11%2F26%2FTechnologyStack%2Fdocker%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近在搞小程序，已经好久没写博客了。本以为很小的一个项目，居然做现在(⇀‸↼‶)，不得不说小程序的坑真多。先缓一下了，学习一下最近很火的docker容器技术，随便做一下笔记。 虚拟机与docker docker commands (常用)容器生命周期管理 run 创建一个新的容器并运行一个命令 (没有的镜像会自动下载) -d(daemon): 后台运行容器，并返回容器ID； -i(interactive): 以交互模式运行容器，通常与 -t 同时使用;( • ̀ω•́ )✧ -p: 端口映射，格式为：主机(宿主)端口:容器端口 -v(vulome): 实现挂载功能 1.容器目录 2.主机目录(window的目录记得将\改成/):容器目录 … –vulomes-from: --vulomes-from name|id(容器的vulome)挂载到其他容器 将一个容器的挂载附加到另一个容器上（差不多这个意思 在容器终端用mount命令看一下） -t(terminal): 伪终端 –name: –name “name” 为容器指定一个名称 –rm: 指定容器停止后自动删除容器(不支持以docker run -d启动的容器) start/stop/restart 启动/停止/重启容器(可多个) create 创建一个新的容器但不启动它（区别于run命np令） rm 删除一个或多少容器 docker rm $(docker ps -aq) 删除所有容器 exec ：在运行的容器中执行命令 -v: 实现挂载功能 容器操作 ps 列出容器 -a: 显示所有的容器，包括未运行的。-q: 静默模式，只显示容器编号。 inspect 获取容器/镜像的元数据 inspect [OPTIONS] NAME|ID logs 获取容器的日志 -f: 跟踪日志输出-t: 显示时间戳 本地镜像管理 images 列出本地镜像。(mirror) rmi 删除本地一个或多少镜像。 build 命令用于使用 Dockerfile 创建镜像。 –tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；-f :指定要使用的Dockerfile路径； tag 标记本地镜像，将其归入某一仓库。 镜像仓库(registry) pull 从镜像仓库中拉取或者更新指定镜像 -a :拉取所有 tagged 镜像 push 将本地的镜像上传到镜像仓库, 要先登陆到镜像仓库 docker push myapache:v1 search 从Docker Hub查找镜像 Dockerfile FROM FROM &lt;image&gt;/&lt;image&gt;:&lt;tag&gt;/&lt;image&gt;:&lt;digest&gt;指定基础镜像，并且必须是第一条指令。如果不以任何镜像为基础，那么写法为：FROM scratch。 RUN 运行指定的命令(区别于CMD) 两种格式 RUN &lt;command&gt; RUN [&quot;executable&quot;(可执行文件/command), &quot;param1&quot;, &quot;param2&quot;] 一定要用双引号 CMD 容器启动时要运行的命令 写法同RUN命令一个dockerfile至多只能有一个cmd，如果有多个，只有最后一个生效。如果docker run没有指定任何的执行命令或者dockerfile里面也没有entrypoint，那么，就会使用cmd指定的默认的执行命令执行。 RUN &amp; CMD &amp; ENTRYPOINTRUN是构件容器时就运行的命令以及提交运行结果CMD是容器启动时执行的命令，在构件时并不运行 MAINTAINER 指定作者 MAINTAINER &lt;name&gt; EXPOSE 暴漏容器运行时的监听端口给外部 EXPOSE并不会使容器访问主机的端口如果想使得容器与主机的端口有映射关系，必须在容器启动的时候(docker run)加上 -P 参数 ENV 设置环境变量 语法有两种: ENV &lt;key&gt; &lt;value&gt; 设置一个 ENV &lt;key&gt;=&lt;value&gt; ... 可设置多个 ADD 一个复制命令，把文件（可以是远程的）复制到景象中。(区别COPY) ADD &lt;src&gt; &lt;dest&gt; COPY 复制本地文件到容器 ENTRYPOINT 启动时的默认命令 写法同RUN命令格式ENTRYPOINT 指令和CMD类似，它也可用户指定容器启动时要执行的命令，但如果dockerfile中也有CMD指令，CMD中的参数会被附加到ENTRYPOINT 指令的后面。如果这时docker run命令带了参数，这个参数会覆盖掉CMD指令的参数，并也会附加到ENTRYPOINT 指令的后面。 VOLUME 实现挂载功能，可以将内地文件夹或者其他容器种得文件夹挂在到这个容器中 USER 启动容器的用户，可以是用户名或UID WORKDIR 设置工作目录 Docker ComposeCompose是一个用于定义和运行多容器Docker应用程序的工具 window/MAC 安装时会自带 Linux需要独立安装一遍 docker-compose.yml commandsdocker-compost stop #停止容器 docker-compose rm #删除容器 docker-compose build #重新建立 docker-compose up -d #启动运行’‘ 遇到的问题记录 window下使用git bash 执行 docker run -it nginx bash 出现 the input device is not a TTY. If you are using mintty, try prefixing the command with &#39;winpty&#39; 解决： 根据提示使用winpty docker run -it nginx bash]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>容器技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass 学习笔记]]></title>
    <url>%2F2018%2F11%2F08%2Fweb%2Fcss%2Fsass%2F</url>
    <content type="text"><![CDATA[简单记录一下 sass 内容 （超简单的部分啊） CSS 预处理器语言Sass（SCSS, LESS, Stylus, Turbine, Swithch CSS, CSS CacheerDT CSS 进入 SASSSass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。 使用变量sass使用$符号来标识变量 变量名用中划线还是下划线分隔; sass的变量名可以与css中的属性名和选择器名称相同，包括中划线和下划线。 在sass的大 多数地方，中划线命名的内容和下划线命名的内容是互通的，除了变量，也包括对混合器和Sass函数的命名。但是在sass中纯css部分不互通，比如类名、ID或属性名。12345678$link-color: blue;a &#123;color: $link_color;&#125;//编译后a &#123;color: blue;&#125; 默认变量值 !default 一般情况下，你反复声明一个变量，只有最后一处声明有效且它会覆盖前边的值。 Sass的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可。 12345678910111213141516171819@import 'red.scss'; // $link-color: red;$link-color: blue;a &#123;color: $link_color;&#125;//编译后a &#123;color: blue;&#125;@import './test.scss'; // $link-color: red;$link-color: blue !default;a &#123;color: $link_color;&#125;// 编译后a &#123;color: red;&#125; 导入SASS文件使用SASS部分文件那些专门为@import命令而编写的sass文件，并不需要生成对应的独立css文件，这样的sass文件称为局部文件。对此，sass有一个特殊的约定来命名这些文件。sass局部文件的文件名以下划线开头(_test.scss)。这样，sass就不会在编译时单独编译这个文件输出css，而只把这个文件用作导入。当你@import一个局部文件时，还可以不写文件的全名，即省略文件名开头的下划线。举例来说，你想导入themes/_night-sky.scss这个局部文件里的变量，你只需在样式表中写@import “themes/night-sky”;。 嵌套导入sass允许@import命令写在css规则内。这种导入方式下，生成对应的css文件时，局部文件会被直接插入到css规则内导入它的地方。 原生的CSS导入被导入文件的名字以.css结尾；被导入文件的名字是一个URL地址（比如http://www.sass.hk/css/css.css），由此可用谷歌字体API提供的相应服务；被导入文件的名字是CSS的url()值。 混合器@mixin@include 继承 @extend使用sass的时候，最后一个减少重复的主要特性就是选择器继承。基于Nicole Sullivan面向对象的css的理念，选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过@extend语法实现。混合器主要用于展示性样式的重用，而类名用于语义化样式的重用。因为继承是基于类的（有时是基于其他类型的选择器），所以继承应该是建立在语义化的关系上。 基本用法 12345678910111213141516171819202122232425262728293031323334353637383940414243.error &#123; border: 1px solid red; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125;// compiled.error, .seriousError &#123; border: 1px solid red; background-color: #fdd;&#125;.seriousError &#123; border-width: 3px;&#125;--------------------------------------------// .seriousError不仅会继承.error自身的所有样式，// 跟.error有关的组合选择器样式也会被.seriousError以组合选择器的形式继承.error h1 &#123; color: red; font-weight: 100;&#125;h1.error &#123; font-size: 1.2rem;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125;// compiled.error h1, .seriousError h1 &#123; color: red; font-weight: 100;&#125;h1.error, h1.seriousError &#123; font-size: 1.2rem;&#125;.seriousError &#123; border-width: 3px;&#125;// ...]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Commands]]></title>
    <url>%2F2018%2F11%2F05%2Flinux%2Flinux%2F</url>
    <content type="text"><![CDATA[一些linux的知识点。未分类。未分类。未分类。说三遍。 sh, bash, source, ./- source 用法 `source filename` 可以用`.`来代替。source(或.)命令通常用于重新执行刚修改的初始化文档。（会改变当前process环境） - bash/sh 用法 都是打开一个subshell去读取、执行脚本，subshell里运行的脚本里设置变量，不会影响到父shell的。 - ./ 用法 打开一个subshell去读取、执行脚本，但脚本需要有&quot;执行权限&quot;, 使用chmod +x filename 直接运行./name.sh，首先你会查找脚本第一行是否指定了解释器，如果没指定，那么就用当前系统默认的shell(大多数linux默认是bash)，如果指定了解释器，那么就将该脚本交给指定的解释器。 find / grepfind /PATH -name &quot;*.h&quot; -exec grep -in &quot;helloworld&quot; {} \; service目录/etc/init.d # /etc/init.d 是 /etc/rc.d/init.d 的软链接(soft link) netstat查看网络状态、端口状态&gt; netstat -luntp 查看端口被占用情况 // t 指TCP端口 u 指UDP端口 /etc/profile, /etc/bashrc, ~/.bash_profile, ~/.bashrc（修改之后使用source命令进行初始化） /etc/profile: 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置. /etc/bashrc: 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取. ~/.bash_profile: 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件. ~/.bashrc: 权限控制到用户级别,该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取. tip: alias 一般在这里设置永久生效 参考链接:linux用户登录启动配置文件关于“.bash_profile”和“.bashrc”区别的总结 变量相关 在linux下声明一个变量的方法：变量名=变量值，=左右不能有空格，使用$变量名调用变量。 set命令可以查看所有变量，包括普通变量和环境变量 unset删除变量 将命令的执行结果赋值给变量有两种方法，方法一：使用包住执行的命令，方法二：将命令放入$()内执行 压缩 and 解压 tar命令 tar -czvf a.tar.gz a.jpg // c 压缩, z 有gzip属性的, v 显示所有过程, f 使用档案名字,这个参数是最后一个参数，后面只能接档案名。 tar -xf file.tar -C ./file // x 解压, -C 解压时指定释放的路径。 tar -cjf a.tar.bz2 a.jp // j 有bz2属性的 其他命令 zip/unzip rar/unrar rar a a.rar a.jpg gzip -d/gunzip mount命令是经常会使用到的命令,它用于挂载Linux系统外的文件。vim 常用操作- 翻页 123456789# ctrl+f forward向前翻一页# ctrl+b backward向后翻一页# ctlr+u up向上翻半页# ctrl+d down向下翻半页# zz 让光标所在的行居屏幕中央# zt 让光标所在的行居屏幕最上一行 t=top# zb 让光标所在的行居屏幕最下一行 b=bottomE - 搜索 ?.. 在光标之前搜索 /.. 在光标之后搜索，按 n/N 分别是向后，向前 - 替换 1# `:n1,n2(填$s时表示文件末尾)/替换的字符/替换成为的/g` - 定位： gg: 命令将光标移动到文档开头 G: 移动的这个文件的最后一行 输入冒号(:)，打开命令输入框 输入命令：1或者0 输入冒号(:)，打开命令输入框 输入命令：$ /dev/null 空设备&gt; /dev/null属于字符特殊文件，它属于空设备，是一个特殊的设备文件，它会丢弃一切写入其中的数据，写入它的内容都会永远丢失，而且没有任何可以读取的内容。 &gt; &gt; `cat $filename &gt;/dev/null` 与 `cat $filename 1&gt;/dev/null`一样。其中 1：表示标准输出（stdout）（默认值）， 0：表示标准输入流（stdin）， 2：表示标准错误输出（stderr） head 和 tail&gt; head 显示文件开头部分内容，默认10行 -n 显示行数 &gt; tail 显示文件结尾部分内容，默认10行 -f 监听文件 -n 显示行数 iptables 防火墙&gt; [参考链接](https://www.cnblogs.com/jtestroad/p/8031850.html) - 命令行方式 1. 开放端口命令： /sbin/iptables -I INPUT -p tcp --dport 8080(端口) -j ACCEPT(开放)|DROP(关闭) 2. 保存：/etc/rc.d/init.d/iptables save 3. 重启服务：/etc/init.d/iptables restart 4. 查看端口是否开放：iptables -L -n - 编辑/etc/sysconfig/iptables文件 1. 编辑/etc/sysconfig/iptables文件：vim /etc/sysconfig/iptables 加入内容并保存：-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 8080(开放的端口) -j ACCEPT 1. 重启服务：/etc/init.d/iptables restart 2. 查看端口是否开放：/sbin/iptables -L -n &gt; 注意： Centos升级到7之后，内置的防火墙已经从iptables变成了firewalld。所以，端口的开启还是要从两种情况来说明的，即iptables和firewalld。参考链接：https://www.cnblogs.com/moxiaoan/p/5683743.html ps 查看进程 用于显示当前进程 (process) 的状态。1. 常用参数 -a 显示同一终端下的所有程序 -A 显示所有进程 （等价于-e） -w 显示加宽可以显示较多的资讯 -au 显示较详细的资讯 -aux 显示所有包含其他使用者的进程 c 显示进程的真实名称 -C&lt;命令&gt; 列出指定命令的状况 显示一个名为getty的进程的信息 ps -C getty -d 显示所有进程，但省略所有的会话引线(utility) -e 等于&quot;-A&quot; e 显示环境变量 -f 全部列出，通常和其他选项联用。如：ps -fa or ps -fx and so on. f 显示程序间的关系(树形结构 pstree命令也是显示树形结构) x 显示所有程序，不以终端机来区分。 -x 显示没有控制终端的进程，同时显示各个命令的具体路径。dx不可合用。（utility） 2. ps aux 和ps -ef 两者的输出结果差别不大，但展示风格不同。aux是BSD风格，-ef是System V风格。这是次要的区别，一个影响使用的区别是aux会截断command列，而-ef不会。当结合grep时这种区别会影响到结果。 举例请参考：http://www.2cto.com/os/201303/197697.html Linux下查看和添加环境变量 PATH$PATH 变量$PATH：决定了shell将到哪些目录中寻找命令或程序，PATH的值是一系列目录，当您运行一个程序时，Linux在这些目录下进行搜寻编译链接。格式: PATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:------:&lt;PATH N&gt;可以自己加上指定的路径，中间用冒号隔开。环境变量更改后，在用户下次登陆时生效，如果想立刻生效，则可执行下面的语句：$ source .bash_profile 查看PATH 使用 export 命令查看PATH值 echo $PATH 添加环境变量 临时添加PATH环境变量 1[yonjim@localhost ~]$ export PATH=/binPath/bin:$PATH 永久添加环境变量(仅影响当前用户) 编辑~/.bashrc或者~/.bash_profile文件 vim ~/.bash_profile 在文档最后，添加:export PATH=&quot;/binPath/bin:$PATH&quot;保存，退出 使用修改内容生效 source ~/.bash_profile 永久添加环境变量(影响所有用户) 编辑/etc/profile文件 vim /etc/profile 在文档最后，添加:export PATH=&quot;/binPath/bin:$PATH&quot;保存，退出 使用修改内容生效 source /etc/profile 参考链接：https://www.cnblogs.com/aaronLinux/p/5837702.html nohup 和 &amp; 和 daemonlinux下的常见信号在了解nohup 和 &amp; 和 daemon之前，我们要先简单了解一下linux下的信号。 信号本质软中断信号（signal，又简称为信号）用来通知进程发生了异步事件。在软件层次上是对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。 Linux支持的信号（这里只列了SIGHUP和SIGINT信号，详细了解请到Linux信号（signal) 机制分析） SIGHUP：终端挂起或者控制进程终止 SIGHUP会在以下3种情况下被发送给相应的进程： 1、终端关闭时，该信号被发送到session首进程以及作为job提交的进程（即用 &amp; 符号提交的进程） 2、session首进程退出时，该信号被发送到该session中的前台进程组中的每一个进程 3、若父进程退出导致进程组成为孤儿进程组，且该进程组中有进程处于停止状态（收到SIGSTOP或SIGTSTP信号），该信号会被发送到该进程组中的每一个进程。 系统对SIGHUP信号的默认处理是终止收到该信号的进程。所以若程序中没有捕捉该信号，当收到该信号时，进程就会退出。 SIGINT： 程序中止信号，在用户键入INTR字符（通常是Ctrl+C）时发出。 nohup（不挂起）用途：不挂断地运行命令。语法：nohup Command [Arg…] [&amp;]描述：nohup 命令运行由 Command 参数和任何相关的 Arg 参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的nohup 命令，添加&amp;（表示”and”的符号）到命令的尾部。 &amp;就是将程序放在后台运行。对于shell来说，通过&amp; 可以把一个程序放在后台运行。其就是作为一个job来运行的。此时如果终端断开，程序还是会被SIGHUP信号导致退出的。即上面SIGHUP信号的第一种场景。 nohup与&amp; 使用&amp;后台运行程序： 结果会输出到终端 使用Ctrl + C发送SIGINT信号，程序免疫 关闭session发送SIGHUP信号，程序关闭 使用nohup运行程序： 结果默认会输出到nohup.out 使用Ctrl + C发送SIGINT信号，程序关闭 关闭session发送SIGHUP信号，程序免疫 平日线上经常使用nohup和&amp;配合来启动程序： 同时免疫SIGINT和SIGHUP信号 daemonDaemon进程也就是守护进程，linux大多数的服务进程都是通过守护进程实现的。比如0号进程(调度进程) ，1号进程(init进程)。从其名字守护看出其一般就是机器启动就运行，关机才停止。所以其应该不会受到终端的影响。同时其实在后台运行的。 参考链接：Linux信号（signal) 机制分析linux 的nohup &amp; 和daemon 总结一分钟了解nohup和&amp;的功效 ln命令 软链接12# 常用来设置软链接ln -s 源目标 目标文件 注意：路径的问题，用绝对路径没那么多问题，相对路径的话。。 了解更多：http://www.runoob.com/linux/linux-comm-ln.html]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令整合</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 hexo 标签插件]]></title>
    <url>%2F2018%2F11%2F03%2Fblog%2Fhexo%2FtagPlugins%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;hexo的标签插件和markdown的原生语法的作用差不多，但还是有挺大的区别的，写个博客记录一下。 引用资源123&#123;% asset_path 11.png %&#125;&#123;% asset_img 11.png This is an example image %&#125;&#123;% asset_link 11.png This is an example image %&#125; 插入图片 Image在文章中插入指定大小的图片（也可以用img标签实现）1&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125; 插入图片 Link在文章中插入链接，并自动给外部链接添加 target=”_blank” 属性。1&#123;% link text url [external] [title] %&#125; 代码块简单的写法，它使用三个反引号来包裹。123``` [language] [title] [url] [link text] code snippet``` 在文章中插入代码。123&#123;% codeblock [title 说明] [lang:language 指定语言（原生语法也可以指定语言）] [url 网址] [link text 连接显示的文本] %&#125;code snippet&#123;% endcodeblock %&#125; 附加说明和网址（多了的）1234&#123;% codeblock _.compact http://underscorejs.org/#compact Underscore.js %&#125;_.compact([0, 1, false, 2, '', 3]);=&gt; [1, 2, 3]&#123;% endcodeblock %&#125; 使用效果：_.compactUnderscore.js12_.compact([0, 1, false, 2, '', 3]);=&gt; [1, 2, 3] 引用块在文章中插入引言，可包含作者、来源和标题。（跟 &gt; 差不多，区别在于它提供了一个标准格式，可以很方便地插入引言，可包含作者、来源和标题。）123&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote %&#125; 效果：content YongJianmyBlog 插入 Swig 标签如果您想在文章中插入 Swig 标签，可以尝试使用 Raw 标签，以免发生解析异常。 123456&#123;% raw %&#125; &#123;% set foo = [1,2,3] %&#125; &#123;% for bar in foo %&#125; &#123;% bar %&#125; &#123;% endfor %&#125;&#123;% endraw %&#125; NexT主题的内置标签Bootstrap Callout123&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125;#其中，class_name 可以是以下列表中的一个值：default, primary, success, info, warning, danger 文本居中的引用123456789&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class="blockquote-center" 是必须的 --&gt;&lt;blockquote class="blockquote-center"&gt;blah blah blah&lt;/blockquote&gt;&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[glup 自动化构建学习笔记]]></title>
    <url>%2F2018%2F11%2F01%2Fweb%2Fglup%2F</url>
    <content type="text"><![CDATA[gulp.js 4.0以上的版本 gulp.js基于流的自动化构建工具 自动化构建工具 ant ant是一个非常流行的自动化构建工具，类似于make，用Java编写并使用XML文件格式。 Maven 它可用来做依赖管理和构建，并且主要用于Java项目。 Gradle 它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，抛弃了基于XML的各种繁琐配置。 前端构建工具 webpack和browserify，gulp和grunt webpack和browserify 前端模块化方案 预编译模块的方案 webpack 是一个模块打包器。 Browserify 可以让你使用类似于 node 的 require() 的方式来组织浏览器端的 Javascript 代码。 gulp和grunt 前端自动化构建的工具 压缩css、js、编译less、sass等等 gulp Api (部分，有需要再更新)gulp.task (gulp4 只支持两个参数)123456789101112131415// 两个参数，分别是任务名和运行任务的函数。 // 也可以直接传入一个普通函数。gulp.task能把函数名转成任务名。// 注意因为gulp4没有了第二个参数deps(前置依赖)，所以你懂的。// default表示默认执行的任务。gulp.task('default', function() &#123; console.log(1111);&#125;);// 可以给任务定义描述 gulp --tasks查看function styles()&#123;...&#125;styles.displayName = "displayName"; // 取一个新名字？styles.description = "This is so cool";gulp.task(styles);// 添加描述 不能传第二个参数gulp.task('default').description = "Does Default Stuff"; 异步任务支持 执行的是同步任务，在Gulp3中不需要写任何其他代码，但是在Gulp4中就不能如此轻松了：现在也你必须运行done回调。 你执行的是异步任务，你则有三个选择来确保Gulp能够检测到你的任务真的完成了，方法如下： 接受一个 callback 123456789// 你可以在你的任务函数的参数中提供一个回调函数并且在你的任务完成后调用它：var del = require('del');gulp.task('clean', function(done) &#123; del(['.build/'], done);&#125;);// del() 会返回一个Promise对象 也就是方法三gulp.task('clean', function(done) &#123; return del(['.build/']); &#125;); 返回一个 stream 你也可以返回一个流，通常通过gulp.src或vinyl-source-stream这个库来创建。这一般也是最常用的方式： 12345gulp.task('somename', function() &#123; return gulp.src('client/**/*.js') .pipe(minify()) .pipe(gulp.dest('build'));&#125;); 返回一个 promise 123456789var Q = require('q');gulp.task('somename', function() &#123;var deferred = Q.defer();// 执行异步的操作setTimeout(function() &#123; deferred.resolve();&#125;, 1);return deferred.promise;&#125;); gulp.watch gulp.watch(glob [, opts], tasks) 或 gulp.watch(glob [, opts, cb]) gulp.watch将像之前一样会返回一个的“观察”对象，不过你可以对它添加各种事件监听(glup3 好像只会在change时触发), 不用再使用 gulp-watch 了 1234var watcher = gulp.watch(String or Array)watcher.on('all/changle/add/unlink', (event) =&gt; &#123; console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');&#125;) gulp.series 和 gulp.parallel (gulp4新增,都会返回一个函数) 都可以接受数个函数或任务名作为参数 (以,间隔起来 或者 一个数组) gulp.series会返回一个函数用来串行执行它所接受的任务/函数 gulp.parallel返回的函数则会并行的运行它们 这两个的api使我们不再需要其他的第三方依赖（如：run-sequence） gulp.dest能被 pipe 进来，并且将会写文件。并且重新输出（emits）所有数据，因此你可以将它 pipe 到多个文件夹。如果某文件夹不存在，将会自动创建它。 gulp.src(globs[, options]) 输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的 stream 它可以被 piped 到别的插件中。 globs参数 类型： String 或 Array options参数 类型： Object 传递给选项的值必须是预期的类型，否则将被忽略。 gulp.lastRun gulp.lastRun(name,timePrecision) name: 任务名 timePrecision： 时间精度 eg: 1000/10 扩展CoffeeScriptCoffeeScript是一套JavaScript的转译语言,CoffeeScript 会将类似 Ruby 语法的代码编译成 JavaScript，而且大部分结构都相似，但不同的是 CoffeeScript 拥有更严格的语法。在gulp中使用 gulp-coffee 参考链接: 【译】相对完整的Gulp4升级指南]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客]]></title>
    <url>%2F2018%2F10%2F31%2Fblog%2Fblog-buliding%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;一直想搭个博客，也可以学习一下markdown。折腾了一天终于将第一个博客搭起来了，简单记录一下这个过程。 搭建博客的选择 选择网上流行的论坛或者社区平台 这里列出常见的几个： 简书, 掘金, 知乎,博客园,CSDN,SegmentFault等。相信这里面总有一个你见过的,我就直接进入主题吧。 选择自己搭建 现在网上常见的几个方法： 使用WordPress （PHP语言开发的博客平台，也可以当一个CMS来使用）搭建。 （要氪金）需要配置服务器，域名，数据库等。如果你熟悉PHP和web知识可以选择这个哦。 hexo/jekyll + Github Pages/Coding Pages（氪金，不存在的！）hexo和jekyll都是静态博客框架，在本地生成静态html后上传到Github或者Coding等代码托管平台。可以简单快捷搭建出一个静态博客，我就是用了hexo + Github Pages搭建的。 Hexo + Github Pages 博客搭建准备环境 Hexo 官网 https://hexo.io/docs/ 详细步骤请参考在Hexo的官网，我在这里简单描述一下几个重要的步骤。 先安装一下应用程序 Node.js Git 安装 hexo 1$ npm install -g hexo-cli 初始化项目 $ hexo init &lt;folder&gt; $ cd &lt;folder&gt; $ npm install 启动服务器 1$ hexo s 打开浏览器访问 http://localhost:4000 你会发现博客已在本地搭建成功。 详细配置请到官网查看。 推送到GitHub 首先你得要有一个GitHub账号，注册过程非常简单，我就不展示了。 新建一个仓库，仓库命名格式为 (你的github账号名称).github.io。 使用ssh密钥方式推送（也可以使用https的方式） 生成秘钥（window用户需要使用Git Bash输入），按回车三下，即生成成功。 1ssh-keygen -t rsa 命令行输入cat ~/.ssh/id_rsa.pub，将显示的内容复制。 1cat ~/.ssh/id_rsa.pub 添加到 github。 点击Add SHH key按钮。就ok了。 测试是否成功添加。 命令行输入ssh git@github.com。 若出现Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access.，恭喜你，添加成功了。请跳过下面的步骤。 若出现ssh: connect to host github.com port 22: Connection refused。 进入用户的.ssh目录cd ~/.ssh(windwo用户进入C:\Users\Administrator\.ssh)，新建config文件touch config 输入配置信息 123456Host github.com User 这里填写你注册时使用的邮箱 Hostname ssh.github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa Port 443 Hexo 部署（详细可以到hexo官网查看） 安装 hexo-deployer-git。 1npm i hexo-deployer-git --save 修改配置（初始化目录下的_config.yml）。 1234deploy: type: git repo: git@github.com:你的github账号名称/你的github账号名称.github.io.git branch: master 推送到github上之前，不要忘记执行hexo g命令生成静态文件。 1hexo g 执行hexo d命令 1hexo d 最后出现INFO Deploy done: git，表示已经推送到github上了。 您的Hexo博客已经搭建好啦~~ 打开浏览器输入https://你的github账号名称.github.io。 更换主题 如果你想要更换主题可以到https://hexo.io/themes/，找到你喜欢的主题。 把下载的主题放到初始化目录的themes目录下，修改初始化目录的_config.yml 12345# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/# theme: landscapetheme: 下载的主题文件夹名称 执行命令 1$ hexo s 你会发现主题已经更换成功了！ 我使用的是next的主题，附上主题文档]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World！]]></title>
    <url>%2F2018%2F10%2F31%2Findex%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Awesome</title>
      <link href="/2019/07/14/bookmarks/"/>
      <url>/2019/07/14/bookmarks/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>个人技术收藏集</strong><br><strong>一些平时用到的库，常用，有趣的网站和小工具。</strong></p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><ul><li><a href="https://github.com/hammerjs/hammer.js" target="_blank" rel="noopener">hammer</a> 移动端手势库</li><li><a href="https://github.com/xx45/dayjs" target="_blank" rel="noopener">dayjs</a> 一个轻量级类 API 时间库 moment.js</li><li><a href="https://github.com/hotoo/pinyin" target="_blank" rel="noopener">pinyin</a> 汉字拼音转换</li><li><a href="https://github.com/transloadit/uppy" target="_blank" rel="noopener">uppy</a> 一款时尚的模块化JavaScript文件上传器</li><li><a href="https://github.com/pqina/filepond" target="_blank" rel="noopener">Filepond</a> 一个小巧灵活而有趣的JavaScript文件上传库</li><li><a href="https://regex101.com/" target="_blank" rel="noopener">Regular Expressions</a> 在线正则网站 挺好用的</li><li><a href="https://jex.im/regulex/" target="_blank" rel="noopener">jex</a> 正则可视化网站，可以导出图片，配合上面的 Regular Expressions，写正则方便很多</li><li><a href="https://github.com/sindresorhus/awesome-nodejs" target="_blank" rel="noopener">awesome-nodejs</a> Node.js包和资源</li><li><a href="https://github.com/PrismJS/prism" target="_blank" rel="noopener">primjs</a> 让页面支持代码高亮 pre标签 code标签</li><li><a href="https://github.com/highlightjs/highlight.js" target="_blank" rel="noopener">highlight.js</a> Javascript语法高亮</li><li><a href="https://github.com/RevillWeb/img-2" target="_blank" rel="noopener">img-2</a> 一个提高图片加载性能和体验的库，懒加载、web worker、模糊预览</li><li><a href="https://github.com/transloadit/uppy" target="_blank" rel="noopener">uppy</a> 浏览器上传器</li><li><a href="https://github.com/h5bp/html5-boilerplate" target="_blank" rel="noopener">html5-boilerplate</a> 一个专业的前端模板，用于构建快速，健壮且适应性强的Web应用程序或站点</li></ul><h3 id="Css"><a href="#Css" class="headerlink" title="Css"></a>Css</h3><ul><li><a href="http://apps.eky.hk/css-triangle-generator/" target="_blank" rel="noopener">CSS triangle generator</a> 帮你快速用 css 做出三角形</li><li><a href="http://www.cssarrowplease.com/" target="_blank" rel="noopener">cssarrowplease</a> 帮你做对话框三角的</li><li><a href="http://bennettfeely.com/clippy/" target="_blank" rel="noopener">clippy</a> 在线帮你使用 css clip-path 做出各种形状的</li><li><a href="https://www.toptal.com/developers/css/sprite-generator" target="_blank" rel="noopener">sprite-generator</a> 生成雪碧图</li></ul><h3 id="一些前端开发中可能会用到的"><a href="#一些前端开发中可能会用到的" class="headerlink" title="一些前端开发中可能会用到的"></a>一些前端开发中可能会用到的</h3><ul><li><a href="https://github.com/WickyNilliams/headroom.js" target="_blank" rel="noopener">Headroom.js</a>  Hide your header until you need it. 控制header的显示隐藏</li><li><a href="https://github.com/greensock/GreenSock-JS" target="_blank" rel="noopener">gsap</a> JavaScript动画库</li><li><a href="https://github.com/mattboldt/typed.js" target="_blank" rel="noopener">typed.js</a> 打字机效果</li><li><a href="https://github.com/Browsersync/browser-sync" target="_blank" rel="noopener">browser-sync</a> 浏览器同步测试工具</li><li><a href="https://github.com/rstacruz/nprogress" target="_blank" rel="noopener">NProgress</a> 进度</li><li><a href="https://github.com/defunkt/jquery-pjax" target="_blank" rel="noopener">jquery-pjax</a> pjax是一个jQuery插件，它使用ajax和pushState通过真实的永久链接，页面标题和工作后退按钮提供快速浏览体验。</li><li><a href="https://css.loli.net/" target="_blank" rel="noopener">css.loli.net</a> 常用前端公共库 CDN 服务  Google 公共库、字体库</li><li><a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">fastclick</a> 解决移动端浏览器在派发点击事件的时候会出现300ms左右的延迟</li><li><a href="https://github.com/fancyapps/fancybox" target="_blank" rel="noopener">fancyBox</a> JQ图片预览的插件</li><li><a href="https://github.com/julianshapiro/velocity" target="_blank" rel="noopener">velocity</a> 非常火的一个动画库</li><li><a href="https://github.com/zenorocha/clipboard.js/" target="_blank" rel="noopener">clipboard.js</a> 前端复制粘贴的库</li></ul><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><ul><li><a href="https://github.com/baianat/vee-validate" target="_blank" rel="noopener">vee-validate</a> 基于 vue 的验证</li><li><a href="https://github.com/shentao/vue-multiselect" target="_blank" rel="noopener">vue-multiselect</a> select 组件</li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li><a href="https://obfuscator.io/" target="_blank" rel="noopener">JavaScript Obfuscator Tool</a> js 代码混淆工具</li><li><a href="https://www.hipdf.cn/" target="_blank" rel="noopener">hipdf</a> 一站式在线 PDF 解决方案</li><li><a href="https://github.com/RelaxedJS/ReLaXed" target="_blank" rel="noopener">ReLaXed</a> 一个将 document html 转成 PDF 的工具</li><li><a href="https://tinypng.com" target="_blank" rel="noopener">tinypng</a> 压缩图片</li><li><a href="https://picsum.photos/" target="_blank" rel="noopener">Lorem Picsum</a> 提供免费的占位图 相比dummyimage的图片是很好看的</li><li><a href="https://sm.ms/" target="_blank" rel="noopener">sm.ms</a> 免费图床</li><li><a href="https://colorkitty.com/" target="_blank" rel="noopener">colorkitty</a> 从你的图片中提取配色</li><li><a href="https://devhints.io/" target="_blank" rel="noopener">devhints.io</a> cheatsheets  开发者语言速查</li><li><a href="https://github.com/gre/bezier-easing" target="_blank" rel="noopener">bezier-easing</a> JavaScript动画缓动的cubic-bezier实现</li><li><a href="https://github.com/gkajs/gka" target="_blank" rel="noopener">gka</a> 一款高效、高性能的帧动画生成工具</li><li><a href="https://github.com/joshbuchea/HEAD" target="_blank" rel="noopener">HEAD</a> 放在文档head标签的所有内容列表</li></ul><h2 id="Chrome拓展"><a href="#Chrome拓展" class="headerlink" title="Chrome拓展"></a>Chrome拓展</h2><ul><li><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">Tampermonkey</a> 油猴 最强的浏览器插件</li><li><a href="https://chrome.google.com/webstore/detail/extension-manager/gjldcdngmdknpinoemndlidpcabkggco/related?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">扩展管理器</a> 一键管理所有扩展，快速开启/禁用、批量闪电管理，智能排序，右键卸载、锁定、选项配置，角标提醒，大小布局随心配。快捷、简单、安全。</li><li><a href="https://chrome.google.com/webstore/detail/the-great-suspender/klbibkeccnjlkjkiokjodocebajanakg" target="_blank" rel="noopener">The Great Suspender</a> chrome 太吃内存了，当页面开的很多时候会很卡，它就完美的解决了这个问题。我就经常放着一大堆网页没有关闭，对我帮助很大。多标签爱好者福音,临时冻结不用网页。</li><li><a href="https://chrome.google.com/webstore/detail/infinity-new-tab-pro/nnnkddnnlpamobajfibfdgfnbcnkgngh?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">infinity</a> 非常实用的chrome新标签页</li><li><a href="https://chrome.google.com/webstore/detail/adblock-plus-free-ad-bloc/cfhdojbkjhnklbpkdaibdccddilifddb" target="_blank" rel="noopener">Adblock Plus</a> 免费广告拦截程序 装机必备</li><li><a href="https://chrome.google.com/webstore/detail/save-all-resources/abpdnfjocnmdomablahdcfnoggeeiedb" target="_blank" rel="noopener">Save All Resources</a> 可以直接下载浏览器sources资源 安装完DevTools会多了一个ResourceSaver，之后就是下载了</li><li><a href="https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad" target="_blank" rel="noopener">WEB 前端助手</a> 包含多个独立小应用，比如：Json工具、代码美化工具、代码压缩、二维码工具、markdown工具、网页油猴工具、便签笔记工具、信息加密与解密、随机密码生成、Crontab等等！</li><li><a href="https://chrome.google.com/webstore/detail/json-handle/iahnhfdhidomcpggpaimmmahffihkfnj" target="_blank" rel="noopener">JSON-handle</a> 对JSON格式的内容进行浏览和编辑，以树形图样式展现JSON文档，并可实时编辑。</li><li><a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc" target="_blank" rel="noopener">Octotree</a> github 上看代码显示目录结构</li><li><a href="https://github.com/npmhub/npmhub" target="_blank" rel="noopener">npmhub</a>在 README 下方显示 npm 依赖信息 可能快速找到相应依赖的代码库</li><li><a href="https://www.crx4chrome.com/crx/37241/" target="_blank" rel="noopener">hostAdmin App</a> 修改host的应用 安装方式：修改下载的crx为zip解压 然后加载chrome的扩展程序中点击加载已解压的扩展程序按钮</li></ul><h2 id="好玩"><a href="#好玩" class="headerlink" title="好玩"></a>好玩</h2><ul><li><a href="https://github.com/Blankj/awesome-comment" target="_blank" rel="noopener">awesome-comment</a> 里面收集了很多有趣的代码注释</li><li><a href="https://hitokoto.cn/" target="_blank" rel="noopener">hitokoto</a> 提供一句话服务。</li><li><a href="http://www.alloyteam.com/" target="_blank" rel="noopener">alloyteam</a> 腾讯全端 AlloyTeam 团队 里面有很多有意思的项目</li></ul><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><ul><li><a href="https://github.com/kentcdodds/cross-env" target="_blank" rel="noopener">cross-env</a> 解决跨平台设置NODE_ENV的问题</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>事件冒泡和默认事件</title>
      <link href="/2019/03/09/web/js/%E5%9F%BA%E7%A1%80/%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6/"/>
      <url>/2019/03/09/web/js/%E5%9F%BA%E7%A1%80/%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天又遇到事件冒泡的问题，专门找时间整理一下相关的资料，记录一下。ヽ(ー_ー)ノ</p><h1 id="事件冒泡（event-bubbling）"><a href="#事件冒泡（event-bubbling）" class="headerlink" title="事件冒泡（event bubbling）"></a>事件冒泡（event bubbling）</h1><p>我们先来理解一下事件冒泡是什么。（事件捕获与之相反我这里就不展开了）(<em>^▽^</em>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html onclick=<span class="string">"alert('h')"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Event Bubbling Example&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body onclick=<span class="string">"alert('b')"</span>&gt;</span><br><span class="line">    &lt;div onclick=<span class="string">"alert('d')"</span> id=<span class="string">"myDiv"</span>&gt;Click Me&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>如果你单击了页面中的 <code>&lt;div&gt;</code> 元素, click 事件首先在 <code>&lt;div&gt;</code> 元素上发生，而这个元素就是我们单击的元素。然后， click事件沿 DOM 树向上传播，在每一级节点上都会发生，直至传播到 document 对象。 这就是事件冒泡</p><p><img src="微信图片_20190309160135.png" width="30%" height="30%"></p><h1 id="阻止事件冒泡-默认事件"><a href="#阻止事件冒泡-默认事件" class="headerlink" title="阻止事件冒泡/默认事件"></a>阻止事件冒泡/默认事件</h1><p>一般我们处理事件时出现奇怪的现像，大多数都是由事件冒泡引起的，或者我们想阻止一下默认事件（也可以叫默认行为，eg：链接的默认行为就是在被单击时会导航到其 href 特性指定的 URL，表单提交等），接下来我们来看一下怎么解决吧！</p><h2 id="return-false"><a href="#return-false" class="headerlink" title="return false"></a>return false</h2><p>为什么我要第一个讲它，因为在网上找<code>阻止事件冒泡和默认事件</code>的方法会出现<code>return false</code>这个方法，这里我要点一下的是在<code>JQuery！JQuery！JQuery！</code>封装的事件函数中<code>return false</code>确实是可以<code>阻止事件冒泡和默认事件</code>的（这就是我挖到的坑ko(╥﹏╥)o，原理我还没去看），但在原生的事件处理程序里可以用来阻止<code>默认事件，只有阻止默认事件</code>！</p><h2 id="stopPropagation-preventDefault"><a href="#stopPropagation-preventDefault" class="headerlink" title="stopPropagation()/preventDefault()"></a>stopPropagation()/preventDefault()</h2><p>这两个方法是<code>DOM事件对象</code>的，<code>stopPropagation()</code>用来阻止事件冒泡（如果事件对象的bubbles为true ，则可以使用这个方法），<code>preventDefault()</code>用来取消事件的默认行为（如果事件对象的cancelable为true ，则可以使用这个方法）。</p><h3 id="stopImmediatePropagation"><a href="#stopImmediatePropagation" class="headerlink" title="stopImmediatePropagation()"></a>stopImmediatePropagation()</h3><p>stopImmediatePropagation()方法是DOM3级事件中新增的取消事件的进一步捕获或冒泡，并且阻止相同事件的其他侦听器被调用。</p><p><code>如果有多个相同类型事件的事件监听函数绑定到同一个元素</code>，当该类型的事件触发时，它们会按照被添加的顺序执行。如果其中某个监听函数执行了event.stopImmediatePropagation() 方法，则当前元素剩下的监听函数将不会被执行。（注意区别 event.stopPropagation()）</p><h2 id="cancelBubble-returnValue"><a href="#cancelBubble-returnValue" class="headerlink" title="cancelBubble/returnValue"></a>cancelBubble/returnValue</h2><p>这两个属性是<code>IE事件对象</code>的，<code>cancelBubble</code>属性（默认值为false）用来阻止事件冒泡（与 DOM 中的 <code>stopPropagation()</code>方法作用相同），<code>returnValue</code>属性（默认值为true）用来取消事件的默认行为（相当 DOM 中的 <code>preventDefault()</code>方法）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="undefined">        height: 200px;</span></span><br><span class="line"><span class="undefined">        width: 600px;</span></span><br><span class="line"><span class="undefined">        margin: 0 auto;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> <span class="selector-tag">a</span>&#123;</span></span><br><span class="line"><span class="undefined">        display: block;</span></span><br><span class="line"><span class="undefined">        height: 50%;</span></span><br><span class="line"><span class="undefined">        width: 50%;</span></span><br><span class="line"><span class="undefined">        background: red;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">onclick</span>=<span class="string">"alert('body')"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"link"</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>1111111111<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/3.3.1/jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementsByClassName(<span class="string">"box"</span>)[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">                alert(<span class="string">'box'</span>)</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'link'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">                alert(<span class="string">'link'</span>)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">                event.stopPropagation(); <span class="comment">// 阻止事件冒泡</span></span></span><br><span class="line"><span class="actionscript">                <span class="comment">// event.preventDefault() // 阻止默认行为，页面不会跳转</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">                <span class="comment">// event.returnValue = false // 阻止默认行为</span></span></span><br><span class="line"><span class="actionscript">                <span class="comment">// event.cancelBubble = true // 阻止事件冒泡</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 阻止默认行为 会将returnValue变成true</span></span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件流和事件处理程序</title>
      <link href="/2019/03/09/web/js/%E5%9F%BA%E7%A1%80/%E4%BA%8B%E4%BB%B6%E6%B5%81%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/"/>
      <url>/2019/03/09/web/js/%E5%9F%BA%E7%A1%80/%E4%BA%8B%E4%BB%B6%E6%B5%81%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h1><p>JavaScript的<code>事件流</code>（事件流描述的是从页面中接收事件的顺序）有三种，分别是：事件冒泡、事件捕获、DOM事件流。</p><ol><li>IE 的事件流叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）</li><li>Netscape Communicator团队提出的另一种事件流叫做事件捕获（event capturing）。事件捕获的思想<br>是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在<br>事件到达预定目标之前捕获它。</li><li>“DOM2级事件”规定的事件流包括三个阶段：<a href="/2019/03/09/web/js/基础/事件冒泡和事件捕获/">事件捕获阶段、处于目标阶段和事件冒泡阶段。</a></li></ol><blockquote><p>IE9、Opera、Firefox、Chrome 和 Safari 都支持 DOM 事件流；IE8 及更早版本不支持 DOM 事件流。</p></blockquote><h1 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h1><p>事件就是用户或浏览器自身执行的某种动作。诸如 click 、 load 和 mouseover ，都是事件的名字。而响应某个事件的函数就叫做<code>事件处理程序</code>（或<code>事件侦听器</code>）。事件处理程序的名字以 “on” 开头，因此click 事件的事件处理程序就是 onclick …</p><h2 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h2><p>某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的<code>HTML 特性</code>来指定。这个特性的值应该是能够执行的 JavaScript 代码。例如，要在按钮被单击时执行一些 JavaScript，可以像下面这样编写代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"Click Me"</span> onclick=<span class="string">"alert('Clicked')"</span> /&gt;</span><br></pre></td></tr></table></figure><p>缺点：  </p><ol><li>样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。不同 JavaScript引擎遵循的标识符解析规则略有差异，很可能会在访问非限定对象成员时出错。</li><li>HTML 与 JavaScript 代码紧密耦合。如果要更换事件处理程序，就要改动两个地方：HTML 代码和 JavaScript 代码。</li></ol><h2 id="DOM0-级事件处理程序（事件处理程序会在事件流的冒泡阶段被处理）"><a href="#DOM0-级事件处理程序（事件处理程序会在事件流的冒泡阶段被处理）" class="headerlink" title="DOM0 级事件处理程序（事件处理程序会在事件流的冒泡阶段被处理）"></a>DOM0 级事件处理程序（事件处理程序会在事件流的冒泡阶段被处理）</h2><p>通过 JavaScript 指定事件处理程序的传统方式，就是<code>将一个函数赋值给一个事件处理程序属性</code>。这种为事件处理程序赋值的方法是在第四代 Web 浏览器中出现的，而且至今仍然<code>为所有现代浏览器所支持</code>。原因一是简单，二是具有跨浏览器的优势。<code>以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。~~</code></p><p>每个元素（包括 window 和 document ）都有自己的事件处理程序属性，这些属性通常全部小写，例如 onclick 。将这种属性的值设置为一个函数，就可以指定事件处理程序，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"Clicked"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>缺点：  </p><ol><li>一个元素只能添加一个事件处理程序。</li></ol><h3 id="移除-DOM0-级方法指定的事件处理程序"><a href="#移除-DOM0-级方法指定的事件处理程序" class="headerlink" title="移除 DOM0 级方法指定的事件处理程序"></a>移除 DOM0 级方法指定的事件处理程序</h3><p>只要像下面这样将事件处理程序属性的值设置为 null 即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="literal">null</span>; <span class="comment">//删除事件处理程序</span></span><br></pre></td></tr></table></figure><h2 id="DOM2-级事件处理程序-（可以设置事件在捕获还是冒泡处理）"><a href="#DOM2-级事件处理程序-（可以设置事件在捕获还是冒泡处理）" class="headerlink" title="DOM2 级事件处理程序 （可以设置事件在捕获还是冒泡处理）"></a>DOM2 级事件处理程序 （可以设置事件在捕获还是冒泡处理）</h2><p><code>“DOM2级事件”</code>定义了两个方法，用于处理指定和删除事件处理程序的操作： <code>addEventListener()</code>和 <code>removeEventListener()</code> 。所有 DOM 节点中都包含这两个方法，并且它们都接受 3 个参数：要处理的事件名（没有on）、作为事件处理程序的函数和一个布尔值。<code>最后这个布尔值参数如果是 true ，表示在捕获阶段调用事件处理程序；如果是 false ，表示在冒泡阶段调用事件处理程序</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="移除-DOM2-级事件处理程序"><a href="#移除-DOM2-级事件处理程序" class="headerlink" title="移除 DOM2 级事件处理程序"></a>移除 DOM2 级事件处理程序</h3><p>传入 removeEventListener() 中的事件处理程序函数必须与传入addEventListener() 中的相同才可以移除！！！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;;</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, handler, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 这里省略了其他代码</span></span><br><span class="line">btn.removeEventListener(<span class="string">"click"</span>, handler, <span class="literal">false</span>); <span class="comment">// 有效！</span></span><br></pre></td></tr></table></figure><blockquote><p>IE9、Firefox、Safari、Chrome和 Opera 支持 DOM2 级事件处理程序。</p></blockquote><h2 id="IE事件处理程序-（只支持事件冒泡）"><a href="#IE事件处理程序-（只支持事件冒泡）" class="headerlink" title="IE事件处理程序 （只支持事件冒泡）"></a>IE事件处理程序 （只支持事件冒泡）</h2><p>IE 实现了与 DOM 中类似的两个方法： <code>attachEvent() 和 detachEvent()</code>。这两个方法接受相同的两个参数：事件处理程序名称（<code>以 &quot;on&quot; 开头的, 区别DOM</code>）与事件处理程序函数。由于 IE8 及更早版本只支持事件冒泡，所以通过attachEvent() 添加的事件处理程序都会被添加到冒泡阶段。 移除跟 DOM2 级事件处理程序一样参数必须相同！</p><p>要使用 attachEvent() 为按钮添加一个事件处理程序，可以使用以下代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"Clicked"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h3><p>在 IE 中使用 attachEvent() 与使用 DOM0 级方法的主要区别在于事件处理程序的作用域。在使用 DOM0 级方法的情况下，事件处理程序会在其所属元素的作用域内运行；<code>在使用 attachEvent() 方法的情况下，事件处理程序会在全局作用域中运行，因此 this 等于 window 。</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">//true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>支持 IE 事件处理程序的浏览器有 IE 和 Opera。</p></blockquote><p>整理自<code>JavaScript高级程序设计</code>。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flex Layout 弹性盒子模型 的 flex属性</title>
      <link href="/2019/03/06/web/css/flex%E5%B1%9E%E6%80%A7/"/>
      <url>/2019/03/06/web/css/flex%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近都在忙着实习的事情，好久没写过博客了。。。o(╥﹏╥)o，来复习一下flex布局吧。。<br>Flex布局的基本使用我这里就不赘述了，可以去看阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="noopener">Flex 布局教程：语法篇</a>这篇文章。这里我主要介绍一下Flex布局中的项目的属性的flex属性。</p><h1 id="flex-属性"><a href="#flex-属性" class="headerlink" title="flex 属性"></a>flex 属性</h1><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。</p><h2 id="flex-的写法"><a href="#flex-的写法" class="headerlink" title="flex 的写法"></a>flex 的写法</h2><ol><li>当 flex 取值为 none，则计算值为 0 0 auto</li><li>当 flex 取值为 auto，则计算值为 1 1 auto</li><li>当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%</li><li>当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1，有如下等同情况（注意 0% 是一个百分比而不是一个非负数字）</li><li>当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%</li><li>当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1 </li></ol><h1 id="flex-grow-flex-shrink-和-flex-basis"><a href="#flex-grow-flex-shrink-和-flex-basis" class="headerlink" title="flex-grow, flex-shrink 和 flex-basis"></a>flex-grow, flex-shrink 和 flex-basis</h1><p>flex-grow, flex-shrink 和 flex-basis三个属性是对剩余空间（就是父容器在主轴的方向上还有多少可用的空间）的操作</p><h2 id="剩余空间"><a href="#剩余空间" class="headerlink" title="剩余空间"></a>剩余空间</h2><p>剩余空间＝父容器空间－子容器1.flex-basis/width - 子容器2.flex-basis/width - …<br><code>flex-basis和width其中有一个是auto，那么另外一个非auto的属性优先级会更高。</code><br><code>flex-basis和width为auto值，那最后的空间就是根据内容多少来定的，内容多占据的水平空间就多。</code></p><p>参考链接：<br><a href="https://www.cnblogs.com/ghfjj/p/6529733.html" target="_blank" rel="noopener">深入理解css3中的flex-grow、flex-shrink、flex-basis （转）</a><br><a href="https://blog.csdn.net/yezitoo/article/details/78326694?locationNum=8&amp;fps=1" target="_blank" rel="noopener">flex-grow、flex-shrink、flex-basis详解、flex:1;详解</a> </p>]]></content>
      
      
      <categories>
          
          <category> Css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jenkins初了解</title>
      <link href="/2019/02/24/TechnologyStack/jenkins/"/>
      <url>/2019/02/24/TechnologyStack/jenkins/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这边文章只是简单了解一下什么是jenkins，详细可以到<a href="https://jenkins.io/zh/" target="_blank" rel="noopener">官网</a>。  </p><h1 id="Jenkins是什么"><a href="#Jenkins是什么" class="headerlink" title="Jenkins是什么?"></a>Jenkins是什么?</h1><p>Jenkins是一款开源CI（持续集成）&amp;CD（持续交付）软件，用于自动化各种任务，包括构建、测试和部署软件.<br>Jenkins支持各种运行方式，可通过系统包,Docker或者通过一个独立的Java程序.</p><h1 id="发布流程设计"><a href="#发布流程设计" class="headerlink" title="发布流程设计"></a>发布流程设计</h1><img src="/2019/02/24/TechnologyStack/jenkins/jenkins.png" title="jekins"><img src="/2019/02/24/TechnologyStack/jenkins/jenkins2.png" title="jekins"><p>参考：<br>jenkins自动化部署及三种构建部署方式 <a href="https://blog.csdn.net/achudk/article/details/78925081" target="_blank" rel="noopener">https://blog.csdn.net/achudk/article/details/78925081</a><br>Jenkins与Docker的自动化CI/CD实战 <a href="https://blog.51cto.com/qiuyt/2163950" target="_blank" rel="noopener">https://blog.51cto.com/qiuyt/2163950</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发中的各种环境</title>
      <link href="/2019/02/23/SoftwareEngineering/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83/"/>
      <url>/2019/02/23/SoftwareEngineering/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录一下开发中的各种环境。</p><p>local：本地开发环境<br>dev：内部开发环境<br>test：供测试人员测试环境<br>stage：试运行环境（新功能部分目标用户使用）<br>production：对外开放的产品环境</p><p><a href="https://segmentfault.com/q/1010000006921696/a-1020000006921997" target="_blank" rel="noopener">https://segmentfault.com/q/1010000006921696/a-1020000006921997</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Software Testing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2019/02/22/TechnologyStack/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/02/22/TechnologyStack/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>说到面向对象肯定会想到三大特性（封装、继承、多态），今天面试被问到了，(〃’▽’〃)却发现回答不上来。。。这里先简答记录一下。</p><h1 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h1><p>面向对象编程的三大特性（封装、继承、多态）</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问</p><p>好处：<br>    a.只能通过规定的方法访问数据<br>    b.隐藏类的实例细节，方便修改和实现（增强安全性和简化编程，使用者不必了解具体的实现细节，而只要通过对外公开的访问方法，来使用类的成员。）</p><p>封装的实现步骤：<br>    1、修改属性的可见性：设为private。<br>    2、创建getter/setter方法，用于属性的读写。<br>    3、在getter/setter方法中加入属性控制语句，对属性值的合法性进行判断。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承：子类拥有父类所有的属性和方法 （修饰符为private则无效） 可以实现代码的复用<br>语法：<code>class 子类  extends  父类{}</code> （创建子类时可以选择 Super class 中的父类）<br>目的：实现代码的复用。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态：相同的事物，调用其相同的方法，参数也相同时，但表现的行为却不同。</p><ol><li><p>引用多态</p><p> 父类的引用可以指向本类的对象<br> 父类的引用可以指向子类的对象</p></li><li><p>方法多态</p><p> 创建本类对象时，调用的方法为本类方法<br> 创建子类对象时，调用的方法为子类重写的方法或者继承的方法</p></li></ol><h3 id="引用类型转换"><a href="#引用类型转换" class="headerlink" title="引用类型转换"></a>引用类型转换</h3><ol><li>向上类型转换（隐式/自动类型转换），是小类型到大类型的转换</li><li>向下类型转换（强制类型转换），是大类型到小类型</li><li>instanceof运算符，来解决引用对象的类型（进行判断），避免类型转换的安全性问题</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> B(); <span class="comment">//这就称父类的引用a 指向了子类的对象new B()，就是这个意思。 B继承A</span></span><br><span class="line"></span><br><span class="line">Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">Animal animal = dog; <span class="comment">//自动类型提升，向上类型转换。</span></span><br><span class="line">Dog dog2 = (Dog)animal; <span class="comment">//父引用转向子类引用 向下类型转换，强制类型转换</span></span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://www.imooc.com/learn/124" title="Java入门第二季" target="_blank" rel="noopener">Java入门第二季</a><br><a href="https://segmentfault.com/a/1190000009141566" title="Java 面向对象编程的三大特性（封装、继承、多态）以及重写和重载" target="_blank" rel="noopener">Java 面向对象编程的三大特性（封装、继承、多态）以及重写和重载</a><br><a href="https://blog.csdn.net/qq_22118507/article/details/51422591" target="_blank" rel="noopener">https://blog.csdn.net/qq_22118507/article/details/51422591</a></p><h1 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h1><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。<br>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。<br>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p><ol><li>抽象类是不可以实例化，也就是抽象类不能被new（不能通过new来生成抽象类的<br>对象），抽象类必须被继承利用，抽象类一定是用来被其它类继承</li><li><p>抽象方法的定义格式：</p><p> <code>[修饰符] abstract 返回值类型 方法名(参数);</code><br> 修饰符：public protected 默认</p></li><li><p>当子类继承抽象类时，一定要覆盖抽象类的抽象方法，否则子类也会是抽象类也需要用abstract修饰</p></li><li>可以把子类对象赋值给抽象类父类的引用，父类引用调用抽象方法将会调用子类的方法</li></ol><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。<br>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。<br>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。<br>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><ol><li><p>常量的定义格式：<br> <code>[public] [static] [final] 数据类型 变量名=值;</code></p><p> 数据类型前面的public static final可以省略</p><p> 使用接口中的常量的格式：接口名.常量名</p></li><li><p>抽象方法的定义格式：<br> <code>[public] [abstract] 返回值类型 方法名(参数);</code></p><p> 返回值类型前面的public abstract可以省略</p></li><li><p>接口中成员都是public的</p></li><li>接口也是不能实例化，也就是不能new接口对象，它用来被继承</li><li><p>一个类可以继承多个接口，其格式：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">implements</span> 接口1,接口2,...</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个类可以继承一个父类，还可以继承多个接口：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 接口1,接口2,...</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当一个子类继承接口时，需要覆盖(实现)接口中的所有抽象方法</p></li><li>可以把子类对象赋值给接口的引用，接口引用调用方法时调用的是子类的方法</li></ol><h2 id="抽象类和接口的异同"><a href="#抽象类和接口的异同" class="headerlink" title="抽象类和接口的异同"></a>抽象类和接口的异同</h2><p>1、接口和抽象类都是不能实例化的，也就是都是不能new<br>2、接口中的方法都是抽象方法，而抽象类中可以有具体的方法<br>3、一个类可以继承多个接口，但只能继承一个抽象类。类：单继承，接口：多继承<br>4、接口不能有构造方法的，但抽象类可以有构造方法<br>5、接口中的成员都是公共的</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js的for...in和for...of</title>
      <link href="/2019/02/21/web/js/%E5%9F%BA%E7%A1%80/js%E7%9A%84for-in%E5%92%8Cfor-of/"/>
      <url>/2019/02/21/web/js/%E5%9F%BA%E7%A1%80/js%E7%9A%84for-in%E5%92%8Cfor-of/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="for…in-用来循环对象"><a href="#for…in-用来循环对象" class="headerlink" title="for…in 用来循环对象"></a>for…in 用来循环对象</h1><p>循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。</p><ol><li>屏蔽了原型中不可枚举属性（即将[[Enumerable]] 标记为 false 的属性）的实例属性也会在 for-in 循环中返回（早版本的IE不会）</li></ol><h1 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h1><p>循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。</p><p>一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。</p><ol><li>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。</li><li>for…in循环读取键名，for…of循环读取键值。如果要通过for…of循环，获取数组的索引，可以借助数组实例的entries方法和keys方法。</li><li>for…of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for…in循环也不一样。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js数组去重</title>
      <link href="/2019/02/21/web/js/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
      <url>/2019/02/21/web/js/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这段时间我就在面试的时候做到了数组去重的题目，回来找一下资料发现，这是不只是一道简单的面试题，还是一道送命题啊。所以我记录一下去重的几种方法ヽ(ー<em>ー)ノヽ(ー</em>ー)ノヽ(ー_ー)ノ||。</p><h1 id="使用Array-prototype-indexOf-方法"><a href="#使用Array-prototype-indexOf-方法" class="headerlink" title="使用Array.prototype.indexOf()方法"></a>使用Array.prototype.indexOf()方法</h1><ol><li><p>方法一</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq1</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = []; <span class="comment">//一个新的临时数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) <span class="comment">//遍历当前数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前数组的第i已经保存进了临时数组，那么跳过，</span></span><br><span class="line">        <span class="comment">//否则把当前项push到临时数组里面</span></span><br><span class="line">        <span class="keyword">if</span> (n.indexOf(arr[i]) === <span class="number">-1</span>) n.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法二</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = [<span class="keyword">this</span>[<span class="number">0</span>]]; <span class="comment">//结果数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.length; i++) <span class="comment">//从第二项开始遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前数组的第i项在当前数组中第一次出现的位置不是i，</span></span><br><span class="line">        <span class="comment">//那么表示第i项是重复的，忽略掉。否则存入结果数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.indexOf(<span class="keyword">this</span>[i]) == i) n.push(<span class="keyword">this</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这两个方法都用到了数组的indexOf方法。目的是寻找存入参数在数组中第一次出现的位置。很显然，js引擎在实现这个方法的时候会遍历数组直到找到目标为止。所以此函数会浪费掉很多时间。（这就是这道题的坑了）</p></li></ol><h1 id="使用对象key来去重"><a href="#使用对象key来去重" class="headerlink" title="使用对象key来去重"></a>使用对象key来去重</h1><p>这种方法效率最好</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = [];</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> tmp = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!tmp[arr[i]])&#123;</span><br><span class="line">            tmp[arr[i]] = <span class="number">1</span>;</span><br><span class="line">            ret.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法是利用了对象（tmp）的key不可以重复的特性来进行去重。但由于对象key只能为字符串，因此这种去重方法有许多局限性：  </p><ol><li>无法区分隐式类型转换成字符串后一样的值，比如1和’1’ <code>eg: [1, &#39;1&#39;]</code></li><li>无法处理复杂数据类型，比如对象（因为对象作为key会变成[object Object]） `eg: [1, {a:1}, {}]</li><li>特殊数据，比如’<strong>proto</strong>‘会挂掉，因为tmp对象的<strong>proto</strong>属性无法被重写</li></ol><p>对于第一点，有人提出可以为对象的key增加一个类型，或者将类型放到对象的value中来解决：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = [];</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> tmp = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> tmpKey;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        tmpKey = <span class="keyword">typeof</span> arr[i] + arr[i];</span><br><span class="line">        <span class="keyword">if</span>(!tmp[tmpKey])&#123;</span><br><span class="line">            tmp[tmpKey] = <span class="number">1</span>;</span><br><span class="line">            ret.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案也同时解决第三个问题。</p><p>而第二个问题，如果像上文所说，在允许对对象进行自定义的比较规则，也可以将对象序列化之后作为key来使用。这里为简单起见，使用JSON.stringify()进行序列化。<code>[1, &#39;1&#39;, {a:1}, {a:1}, function(){}, function(){return 1}]</code>这种情况还是会出现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = [];</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> tmp = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> tmpKey;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        tmpKey = <span class="keyword">typeof</span> arr[i] + <span class="built_in">JSON</span>.stringify(arr[i]);</span><br><span class="line">        <span class="keyword">if</span>(!tmp[tmpKey])&#123;</span><br><span class="line">            tmp[tmpKey] = <span class="number">1</span>;</span><br><span class="line">            ret.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用Set"><a href="#使用Set" class="headerlink" title="使用Set"></a>使用Set</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line"><span class="comment">// return [...new Set(arr)]</span></span><br><span class="line">&#125;</span><br><span class="line">unique([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]) <span class="comment">//[1, 2, 3]</span></span><br><span class="line">unique([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, &#123;&#125;, &#123;&#125;]) <span class="comment">// [1, 2, 3, &#123;&#125;, &#123;&#125;] 引用类型的值 Set里面两个对象总是不相等的。</span></span><br></pre></td></tr></table></figure><p>参考资料：<br><a href="https://blog.csdn.net/chengxuyuan20100425/article/details/8497277" target="_blank" rel="noopener">js数组去重的4个方法</a><br><a href="https://segmentfault.com/a/1190000008031081" target="_blank" rel="noopener">也谈JavaScript数组去重</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新春快乐</title>
      <link href="/2019/02/05/blog/2019%E6%96%B0%E6%98%A5%E5%BF%AB%E4%B9%90/"/>
      <url>/2019/02/05/blog/2019%E6%96%B0%E6%98%A5%E5%BF%AB%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center"> 新春快乐！！！！！新春快乐！！！！！新春快乐！！！！！ </div><br><img src="/asset/images/2019/1.jpg" alt="新年快乐！" title="Pixiv画师: 晴羽Chingyu id: 13730898"><br><img src="/asset/images/2019/2.jpg" alt="新年快乐！" title="Pixiv画师: 晴羽Chingyu id: 13730898"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery的extend方法</title>
      <link href="/2019/01/14/web/js/jQuery/jQuery%E7%9A%84extend%E6%96%B9%E6%B3%95/"/>
      <url>/2019/01/14/web/js/jQuery/jQuery%E7%9A%84extend%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>jQuery的extend方法可以说是jQuery最核心的方法了，这几天复习js的基础，参考了<a href="https://www.cnblogs.com/libin-1/p/6845458.html" target="_blank" rel="noopener">JavaScript 复制对象【Object.assign方法无法实现深复制】</a>这篇文章看了一下jQuery的extend方法的源码。</p><h1 id="jQuery-extend-jQuery-fn-extend"><a href="#jQuery-extend-jQuery-fn-extend" class="headerlink" title="jQuery.extend || jQuery.fn.extend"></a>jQuery.extend || jQuery.fn.extend</h1><p>$.extend方法的一些特点</p><ul><li>没有任何参数时，直接返回一个空对象</li><li>当只有一个参数时（这个参数可以任何数据类型（Null、Undefined、Boolean、String、Number、Object）），会返回this对象，这里会分为两种情况。如果用$.extend，会返回jQuery对象；如果用$.fn.extend，会返回jQuery的原型对象。</li><li>当接收两个参数时，并且第一个参数是Boolean值时，也会返回一个空对象。如果第一个参数不是Boolean值，那么会将源对象复制到目标对象</li><li>当接收三个参数以上时，可以分为两种情况。如果第一个参数是Boolean值表示深浅复制，那么目标对象会移动到第二个参数，源对象会移动到第三个参数。（目标对象、源对象和Object.assign方法中的相同）。如果第一个参数不是Boolean值，那么用法与Object.assign方法常规的复制相同。</li><li>在循环源对象的过程中，任何数据类型为Null、Undefined或者源对象是一个空对象时，在复制的过程中都会被忽略。</li><li>如果源对象和目标对象具有同名的属性，则源对象的属性会覆盖掉目标对象中的属性。如果同名属性是一个对象的话，则会在deep=true等其他条件下向目标对象的该同名对象添加属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn = jQuery.prototype;</span><br><span class="line">jQuery.extend = jQuery.fn.extend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 声明和初始化变量</span></span><br><span class="line"><span class="keyword">var</span> options, name, src, copy, copyIsArray, clone,</span><br><span class="line">    target = <span class="built_in">arguments</span>[ <span class="number">0</span> ] || &#123;&#125;,</span><br><span class="line">    <span class="comment">// 使用||运算符，排除隐式强制类型转换为false的数据类型 如'', 0, undefined, null, false等</span></span><br><span class="line">    <span class="comment">// 如果target为以上的值，则设置target = &#123;&#125;</span></span><br><span class="line">    i = <span class="number">1</span>,</span><br><span class="line">    length = <span class="built_in">arguments</span>.length,</span><br><span class="line">    deep = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当typeof target === 'boolean'时</span></span><br><span class="line"><span class="comment">// 则将deep设置为target的值</span></span><br><span class="line"><span class="comment">// 然后将target移动到第二个参数</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">typeof</span> target === <span class="string">"boolean"</span> ) &#123;</span><br><span class="line">    deep = target; </span><br><span class="line">    target = <span class="built_in">arguments</span>[ i ] || &#123;&#125;;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle case when target is a string or something (possible in deep copy)</span></span><br><span class="line"><span class="comment">// 将typeof不为object或function的数据类型  全部转换为一个空对象</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">typeof</span> target !== <span class="string">"object"</span> &amp;&amp; !isFunction( target ) ) &#123;</span><br><span class="line">    target = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extend jQuery itself if only one argument is passed 只用一个元素时添加到this上</span></span><br><span class="line"><span class="comment">// 如果arguments.length === 1 或</span></span><br><span class="line"><span class="comment">// typeof arguments[0] === 'boolean', 且存在arguments[1]，</span></span><br><span class="line"><span class="keyword">if</span> ( i === length ) &#123;</span><br><span class="line">    <span class="comment">// this的指向哪个对象需要看是使用$.fn.extend还是$.extend</span></span><br><span class="line">    target = <span class="keyword">this</span>;</span><br><span class="line">   <span class="comment">// i-- 表示不进入for循环</span></span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( ; i &lt; length; i++ ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only deal with non-null/undefined values</span></span><br><span class="line">    <span class="keyword">if</span> ( ( options = <span class="built_in">arguments</span>[ i ] ) != <span class="literal">null</span> ) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(options, <span class="string">"11111111111"</span> ,target, i)</span><br><span class="line">        <span class="comment">// Extend the base object</span></span><br><span class="line">        <span class="keyword">for</span> ( name <span class="keyword">in</span> options ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">console</span>.log(name)</span><br><span class="line">            src = target[ name ];   <span class="comment">// src用于判断target对象是否存在name属性</span></span><br><span class="line">            copy = options[ name ]; <span class="comment">// 需要复制的属性  当前源对象的name属性</span></span><br><span class="line">            <span class="comment">// console.log(target)</span></span><br><span class="line">            <span class="built_in">console</span>.log(src)</span><br><span class="line">            <span class="built_in">console</span>.log(copy)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prevent never-ending loop 防止永不结束的循环</span></span><br><span class="line">            <span class="comment">// 防止对象的一个属性引用对象本身造成死循环</span></span><br><span class="line">            <span class="comment">// eg： var a = [1,2]； a.push(a)</span></span><br><span class="line">            <span class="keyword">if</span> ( target === copy ) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是深复制且copy是一个对象或数组</span></span><br><span class="line">            <span class="comment">// 则需要递归jQuery.extend()</span></span><br><span class="line">            <span class="comment">// 直到copy成为一个基本数据类型为止</span></span><br><span class="line">            <span class="keyword">if</span> ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) || ( copyIsArray = <span class="built_in">Array</span>.isArray( copy ) ) ) ) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ( copyIsArray ) &#123;</span><br><span class="line">                    copyIsArray = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// 如果目标对象存在name属性且是一个数组</span></span><br><span class="line">                    <span class="comment">// 则使用目标对象的name属性，否则重新创建一个数组，用于复制</span></span><br><span class="line">                    clone = src &amp;&amp; <span class="built_in">Array</span>.isArray( src ) ? src : [];</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果目标对象存在name属性且是一个对象</span></span><br><span class="line">                    <span class="comment">// 则使用目标对象的name属性，否则重新创建一个对象，用于复制</span></span><br><span class="line">                    clone = src &amp;&amp; jQuery.isPlainObject( src ) ? src : &#123;&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">console</span>.log(clone)</span><br><span class="line">                <span class="comment">// Never move original objects, clone them </span></span><br><span class="line">                target[ name ] = jQuery.extend( deep, clone, copy );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Don't bring in undefined values</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( copy !== <span class="literal">undefined</span> ) &#123;</span><br><span class="line">                <span class="comment">// 一级拷贝的情况</span></span><br><span class="line">                <span class="built_in">console</span>.log(name)</span><br><span class="line">                target[ name ] = copy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the modified object</span></span><br><span class="line"><span class="keyword">return</span> target;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = $.extend();</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// 返回一个空对象 &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = $.extend(<span class="literal">undefined</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">//返回jQuery对象，Object.assign传入undefined会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj3 = $.extend(<span class="string">'123'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj3); <span class="comment">// 返回jQuery对象，Object.assign传入'123'会返回字符串的String对象</span></span><br></pre></td></tr></table></figure><h1 id="扩展-深拷贝与浅拷贝"><a href="#扩展-深拷贝与浅拷贝" class="headerlink" title="扩展 深拷贝与浅拷贝"></a>扩展 深拷贝与浅拷贝</h1><p>浅拷贝（shallow copy）只复制指向某个对象的指针，而不复制对象本身，新旧对象共享一块内存<br>深拷贝（deep copy）复制并创建一个一摸一样的对象，不共享内存，修改新对象，旧对象保持不变</p><h2 id="实现深拷贝的方法"><a href="#实现深拷贝的方法" class="headerlink" title="实现深拷贝的方法"></a>实现深拷贝的方法</h2><ol><li>使用递归 递归去复制所有层级属性</li><li><p>使用JSON对象的parse和stringify</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>，</span><br><span class="line">    b：&#123;</span><br><span class="line">        a:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1));</span><br></pre></td></tr></table></figure></li><li><p>jQuery的extend方法 第一个参数设置为true</p></li><li><p>使用 Object.assign</p><p> ES6新增的Object.assign()，Object.assign方法用于对象的合并，将源对象（source）的所有可枚举（（[[emuerable]] === true））属性，复制到目标对象（target）。Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。跟jQuery的extend方法很像，都是用于扩展已有的Object对象。但区别还是挺大的。</p><p> 注意点</p><ul><li>针对深拷贝，需要使用其他方法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值</li><li>如果目标对象与源对象有同名属性，则后面的属性会覆盖前面的属性</li><li>如果只有一个参数，则直接返回该参数。即Object.assign(obj) === obj</li><li>如果第一个参数不是对象，而是基本数据类型（Null、Undefined除外），则会调用对应的基本包装类型</li><li>如果第一个参数是Null和Undefined，则会报错；如果Null和Undefined不是位于第一个参数，则会略过该参数的复制</li></ul></li></ol><h3 id="一些小问题"><a href="#一些小问题" class="headerlink" title="一些小问题"></a>一些小问题</h3><ol><li><p>为什么我们通常会写Object.assign()的一个参数为<code>{}</code>空对象<br> 我们知道Object.assign方法用于对象的合并，如果是实现对象的复制的话，就需要将一个空对象传入，切断与目标对象的引用。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test1 = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> test2 = &#123;<span class="attr">b</span>:<span class="number">1</span>,<span class="attr">a</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> res = <span class="built_in">Object</span>.assign(test1, test2);  <span class="comment">// res和test1同一个引用</span></span><br><span class="line">res.c = <span class="number">233</span>;</span><br><span class="line"><span class="built_in">console</span>.log(test1); <span class="comment">// &#123;a: 2, b: 1, c: 233&#125;</span></span><br><span class="line"><span class="keyword">var</span> res = <span class="built_in">Object</span>.assign(&#123;&#125;, test1, test2); <span class="comment">// res和test1不同引用</span></span><br><span class="line">res.c = <span class="number">666</span>;</span><br><span class="line"><span class="built_in">console</span>.log(test1); <span class="comment">// &#123;a: 2, b: 1, c: 233&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123;a: 2, b: 1, c: 666&#125;</span></span><br></pre></td></tr></table></figure></li></ol><p>参考链接：<br><a href="https://www.cnblogs.com/libin-1/p/6845458.html" target="_blank" rel="noopener">JavaScript 复制对象【Object.assign方法无法实现深复制】</a><br><a href="https://www.zhihu.com/question/23031215" target="_blank" rel="noopener">javascript中的深拷贝和浅拷贝？</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> jQuery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webGL初了解</title>
      <link href="/2019/01/14/web/webGL/"/>
      <url>/2019/01/14/web/webGL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h1><p>WebGL (Web图形库 Web Graphics Library) 是一种JavaScript API，用于在任何兼容的Web浏览器中呈现交互式3D和2D图形，而无需使用插件。WebGL通过引入一个与OpenGL ES 2.0紧密相符合的API，可以在HTML5 <code>&lt;canvas&gt;</code> 元素中使用。</p><h2 id="WebGL框架"><a href="#WebGL框架" class="headerlink" title="WebGL框架"></a>WebGL框架</h2><p>three.js（这个比较火）、Babylon.jS</p><h1 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a>OpenGL ES</h1><p>OpenGL ES (OpenGL for Embedded Systems) 是 OpenGL 三维图形 API 的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。该API由Khronos集团定义推广，Khronos是一个图形软硬件行业协会，该协会主要关注图形和多媒体方面的开放标准。</p><blockquote><p>现在主要使用的两个版本：OpenGL ES 2.0 和 OpenGL ES 3.0</p></blockquote><h1 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h1><p>OpenGL是用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口（API）。它为我们提供了大量的功能,我们可以使用它来处理图形和图像。准确来说，OpenGL本身并不是一个API，只是一个规范，由<a href="https://www.khronos.org/" target="_blank" rel="noopener">Khronos组织</a>开发和维护。OpenGL规范描述了绘制2D和3D图形的抽象API。</p><p>这套接口是Khronos这个组织在维护，怎么维护呢?就是写一个规范，指导各个GPU厂家，如果他们要支持OpenGL的话，要怎么实现一个具体的OpenGL库。Khronos说要实现glDrawArray这个接口，那么厂家就得在他的库里实现这个接口。如果不实现，那么就不算支持OpenGL。也有一些接口不一定要实现。</p><p>参考资料：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API" target="_blank" rel="noopener">WebGL</a><br><a href="https://blog.csdn.net/qq_30100043/article/details/82014971" target="_blank" rel="noopener">Three.js和其它webgl框架</a><br><a href="https://www.zhihu.com/question/51867884" target="_blank" rel="noopener">OpenGL是什么?</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试基本概念</title>
      <link href="/2019/01/13/SoftwareEngineering/softwareTest/"/>
      <url>/2019/01/13/SoftwareEngineering/softwareTest/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是软件测试"><a href="#什么是软件测试" class="headerlink" title="什么是软件测试"></a>什么是软件测试</h1><p>是为了度量和提高被测软件质量，是对被测软件进行工程设计、实施和维护的整个生命周期的过程。</p><h2 id="软件测试的目的"><a href="#软件测试的目的" class="headerlink" title="软件测试的目的"></a>软件测试的目的</h2><ul><li>测试以发现缺陷为目的</li><li>最大可能找出最多错误</li><li>执行有限测试用例并发现错误</li><li>检查软件是否满足定义的各种需求</li><li>执行测试用例，发现至今未发现错误即为成功的测试</li></ul><h2 id="软件研发模型"><a href="#软件研发模型" class="headerlink" title="软件研发模型"></a>软件研发模型</h2><p>软件研发模型是软件生产过程中分析、设计、研发活动所遵循的框架模式。采取合适的研发模型将会提高软件研发效率，降低研发成本，提高质量。<br>目前较为流行的研发模型主要有：瀑布模型、原型模型、螺旋模型、RUP模型、敏捷模型和DevOps。</p><p><img src="软件开发的演变.jpeg" width="76%" height="76%"><br><!-- 使用这里使用了了相对路径 --></p><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p>瀑布模型将软件生命周期划分为开发计划、需求分析、设计、编码、测试和运行维护这6个基本活动过程。</p><p><img src="瀑布模型.png"></p><h4 id="需求测试（Requirement-Testing）"><a href="#需求测试（Requirement-Testing）" class="headerlink" title="需求测试（Requirement Testing）"></a>需求测试（Requirement Testing）</h4><p>需求测试是在需求分析阶段开始就搞。需求测试的重点是：检查规格说明书中是否存在描述不正确、定义模糊、需求用例不正确、语言存在二义性等问题。完整性、正确性、无二义性、可测试性、一致性。</p><h3 id="敏捷模型"><a href="#敏捷模型" class="headerlink" title="敏捷模型"></a>敏捷模型</h3><p>敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。在敏捷开发中，软件项目在构建初期被切分成多个子项目，各个子项目的成果都经过测试，具备可视、可集成和可运行使用的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。（来自百度百科!!!∑(ﾟДﾟノ)ノ）</p><p><img src="agile.png" width="76%" height="76%"></p><h4 id="持续集成（CI）-持续交付（CD）-持续部署（CD）"><a href="#持续集成（CI）-持续交付（CD）-持续部署（CD）" class="headerlink" title="持续集成（CI）/ 持续交付（CD）/ 持续部署（CD）"></a><a href="https://blog.csdn.net/qq_32261399/article/details/76651376" title="重点" target="_blank" rel="noopener">持续集成（CI）/ 持续交付（CD）/ 持续部署（CD）</a></h4><ol><li><p>持续集成（Continuous Integration）<br> 是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。<a href="https://www.jianshu.com/p/1cd01bcc77f2" target="_blank" rel="noopener">为什么要持续集成</a></p><p> <img src="持续集成.png" width="76%" height="76%"><br> 持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。</p></li><li><p>持续交付（Continuous Delivery）<br> <img src="持续交付.png" width="76%" height="76%"><br> 持续交付（Continuous delivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。定时地、自动地将过去一个稳定的发布版本部署到生产环境里。持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。出于业务考虑，可以选择不部署。如果要实施持续部署，必须先实施持续交付。</p></li><li><p>持续部署（Continuous Deployment）<br> <img src="持续部署.png" width="76%" height="76%"><br> 持续部署（continuous deployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。<br> 持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。<br> 持续部署的前提是能自动化完成测试、构建、部署等步骤。<br> 持续部署则是在持续交付的基础上，把部署到生产环境的过程自动化。</p></li></ol><p>参考：<br><a href="https://blog.csdn.net/peterxiaoq/article/details/73648732" target="_blank" rel="noopener">https://blog.csdn.net/peterxiaoq/article/details/73648732</a> 持续集成（CI）/持续部署（CD）/持续交付<br><a href="https://www.zhihu.com/question/23444990" target="_blank" rel="noopener">https://www.zhihu.com/question/23444990</a> 如何理解持续集成、持续交付、持续部署？<br><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html</a> 持续集成是什么？</p><h3 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h3><p>DevOps（Development和Operations的组合词）是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。它是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。</p><h4 id="DevOps生命周期"><a href="#DevOps生命周期" class="headerlink" title="DevOps生命周期"></a>DevOps生命周期</h4><p><img src="DevOps生命周期.jpeg" width="76%" height="76%"></p><h4 id="DevOps生命周期的哪个阶段使用哪些工具"><a href="#DevOps生命周期的哪个阶段使用哪些工具" class="headerlink" title="DevOps生命周期的哪个阶段使用哪些工具"></a>DevOps生命周期的哪个阶段使用哪些工具</h4><p><img src="DevOps生命周期的哪个阶段使用哪些工具.jpeg" width="76%" height="76%"></p><p>参考：<br><a href="http://www.sohu.com/a/283593991_115128" target="_blank" rel="noopener">http://www.sohu.com/a/283593991_115128</a><br><a href="https://www.zhihu.com/question/58702398" target="_blank" rel="noopener">https://www.zhihu.com/question/58702398</a><br><a href="https://blog.csdn.net/dtttyc/article/details/72921607" target="_blank" rel="noopener">https://blog.csdn.net/dtttyc/article/details/72921607</a></p><h2 id="软件测试级别"><a href="#软件测试级别" class="headerlink" title="软件测试级别"></a>软件测试级别</h2><p>单元测试 集成测试 系统测试 验证测试 验收测试（Alpha测试 Beta测试 UAT测试）</p><h2 id="软件测试类型"><a href="#软件测试类型" class="headerlink" title="软件测试类型"></a>软件测试类型</h2><p>功能测试 性能测试 负载测试 压力测试 安全性测试 兼容性测试 确认测试 冒烟测试 回归测试</p><h1 id="软件测试模型及流程"><a href="#软件测试模型及流程" class="headerlink" title="软件测试模型及流程"></a>软件测试模型及流程</h1><h2 id="v模型"><a href="#v模型" class="headerlink" title="v模型"></a>v模型</h2><p><img src="v.png" width="50%" height="50%"></p><h2 id="w模型"><a href="#w模型" class="headerlink" title="w模型"></a>w模型</h2><p><img src="w.png" width="50%" height="50%"></p><h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><p>测试用例（Test Case）是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序路径或核实是否满足某个特定需求。</p><h2 id="常见的软件测试方法"><a href="#常见的软件测试方法" class="headerlink" title="常见的软件测试方法"></a>常见的软件测试方法</h2><ol><li>黑盒测试<br>黑盒测试又称功能测试、数据驱动测试或基于需求规格说明书的功能测试。该测试方法验证被测对象使用质量及外部质量表现。<br>黑盒测试的测试方法有：等价类划分、边界值分析法、猜错法、随机数法、因果图。</li><li>白盒测试<br> 白盒测试，又称为结构测试、逻辑驱动测试或基于程序代码内部构成的测试。<br> 白盒测试的测试方法有：代码检查法、程序变异、静态结构分析法、静态质量度量法、符号测试法、逻辑覆盖法、域测试、Z路径覆盖和基本路径测试法。</li><li>灰盒测试<br> 灰盒测试就是白盒测试加黑盒测试，性能测试和自动化测试就采用了灰盒测试的方法。</li><li>静态测试<br> 不执行被测对象的程序代码、不运行被测对象而实施的测试活动，发现缺陷的过程。<br> 静态测试包含阅读程序代码、文档资料等。</li><li>动态测试<br>动态测试运行被测对象的程序代码，执行测试用例，检查系统软件运行结果与预期结果的差异。</li><li>手工测试</li><li>自动化测试</li></ol><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="测试用例管理工具"><a href="#测试用例管理工具" class="headerlink" title="测试用例管理工具"></a>测试用例管理工具</h2><p>   TestLink</p><h2 id="缺陷管理工具"><a href="#缺陷管理工具" class="headerlink" title="缺陷管理工具"></a>缺陷管理工具</h2><pre><code>BugFree</code></pre><h2 id="自动化测试工具"><a href="#自动化测试工具" class="headerlink" title="自动化测试工具"></a>自动化测试工具</h2><pre><code>QTP</code></pre><h2 id="性能测试工具"><a href="#性能测试工具" class="headerlink" title="性能测试工具"></a>性能测试工具</h2><pre><code>Loadrunner</code></pre><p><a href="http://www.51testing.com/html/index.html" target="_blank" rel="noopener">软件测试网</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Software Testing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js的运算符和运算符优先级</title>
      <link href="/2019/01/11/web/js/%E5%9F%BA%E7%A1%80/js%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>/2019/01/11/web/js/%E5%9F%BA%E7%A1%80/js%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a.x = a = &#123;<span class="attr">n</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a.x);<span class="comment">// --&gt; undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b.x);<span class="comment">// --&gt; &#123;n: 2&#125;</span></span><br></pre></td></tr></table></figure><p>记录一下这道经典的面试题引发的惨案。今天去面试了，面试时没有做出来，回过神来我才发现原来我以前做过这道面试题(⇀‸↼‶)！！考的是引用类型和运算符优先级。</p><p>参考链接：<br><a href="https://www.jianshu.com/p/09353145e645" target="_blank" rel="noopener">JS指针理解之引用类型（含有运算符表格）</a><br><a href="https://www.cnblogs.com/thinkguo/p/7446880.html" target="_blank" rel="noopener">JavaScript基础之运算符及全面的运算符优先级总结</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>toString 与 valueOf</title>
      <link href="/2019/01/10/web/js/%E5%9F%BA%E7%A1%80/toString%E4%B8%8EvalueOf/"/>
      <url>/2019/01/10/web/js/%E5%9F%BA%E7%A1%80/toString%E4%B8%8EvalueOf/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 ECMAScript 中，Object 类型是所有它的实例的基础。换句话说，Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。在 ECMAScript 中 Object 是所有对象的基础，因此所有对象都具有 Object 基本的属性和方法。<br><code>toString()</code> 与 <code>valueOf()</code>就是 Object 基本的方法，也是最常用到的两个方法。其他的属性和方法请自行查阅资料。</p><h1 id="toString-和-valueOf"><a href="#toString-和-valueOf" class="headerlink" title="toString() 和 valueOf()"></a>toString() 和 valueOf()</h1><blockquote><p>红宝书上是这样描述的，我看完之后还是懵逼啊。<br>toString() ：返回对象的字符串表示。<br>valueOf() ：返回对象的字符串、数值或布尔值表示。通常与 toString() 方法的返回值<br>相同。（尤其是这个描述，事实上通常与toString()返回值不一样的啊。）</p></blockquote><p>我在查阅了相关资料：<br>valueOf偏向于运算，toString偏向于显示。<br>1、 在进行强转字符串类型时将优先调用toString方法，强转为数字时优先调用valueOf。<br>2、 在有运算操作符的情况下，valueOf的优先级高于toString。<br>3、 在数值运算中，优先调用了valueOf，字符串运算中，优先调用了toString。</p><p>参考链接：<a href="https://www.cnblogs.com/peakleo/p/6248242.html" target="_blank" rel="noopener">Javascript中的valueOf与toString</a></p><h1 id="原生构造函数的-toString-和-valueOf"><a href="#原生构造函数的-toString-和-valueOf" class="headerlink" title="原生构造函数的 toString() 和 valueOf()"></a>原生构造函数的 toString() 和 valueOf()</h1><!-- 一般这些原生构造函数的原型（prototype）上对添加一个新的 `toString()` 和 `valueOf()` 方法。 --><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。一般这些原生构造函数重写了 <code>toString()</code> 和 <code>valueOf()</code> 方法，返回结果会不一样。所以一般不会直接访问到Object的 <code>toString()</code> 和 <code>valueOf()</code> 上的方法。我在这里整理一下。</p><table><thead><tr><th>配置</th><th>toSting()</th><th>valueOf()</th></tr></thead><tbody><tr><td>Object</td><td>返回一个 [object NativeConstructorName] 格式的字符串</td><td>对象本身。这是默认情况</td></tr><tr><td>Array</td><td>将 Array 的元素转换为字符串（调用toSting()）。结果字符串由逗号分隔，且连接起来。<br>Array的toString()跟没有其他参数的join()方法的一样，toString 好像是调用 join 的，当重写（或者delete）Array.prototype.join 再去调用toString()会返回[object Array]</td><td>返回数组本身</td></tr><tr><td>Date</td><td>toString()方法通常返回带有时区信息的日期和时间（浏览器不一样，结果会不同）</td><td>返回日期的毫秒表示</td></tr><tr><td>Boolean</td><td>返回 “true”。否则，返回 “false”</td><td>返回boolean值</td></tr><tr><td>Number</td><td>返回数字的字符串表示。toString() 可以方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式。</td><td>返回数字</td></tr><tr><td>String</td><td>返回对象所表示的基本字符串值</td><td>返回对象所表示的基本字符串值</td></tr><tr><td>Function</td><td>返回一个函数的字符串。内置函数一般这种格式 function functionname( ) { [native code] }，自己声明定义的函数 [native code] 会变成代码的。。</td><td>返回函数本身</td></tr><tr><td>RegExp</td><td>返回正则表达式的字面量的字符串表示</td><td>返回正则表达式的字面量</td></tr><tr><td>Error</td><td>返回一个包含相关错误消息的字符串。</td><td>返回本身</td></tr></tbody></table><h1 id="JS类型转换（强制与隐式）"><a href="#JS类型转换（强制与隐式）" class="headerlink" title="JS类型转换（强制与隐式）"></a>JS类型转换（强制与隐式）</h1><p>简单描述一下</p><h2 id="强制转换（只详细列出了Number-）"><a href="#强制转换（只详细列出了Number-）" class="headerlink" title="强制转换（只详细列出了Number()）"></a>强制转换（只详细列出了Number()）</h2><p>通过手动进行类型转换，Javascript提供了以下转型函数：</p><p>转换为数值类型：Number(mix)、parseInt(string,radix)、parseFloat(string)<br>转换为字符串类型：toString(radix)、String(mix)<br>转换为布尔类型：Boolean(mix)</p><h3 id="Number-mix-函数，可以将任意类型的参数mix转换为数值类型。其规则为："><a href="#Number-mix-函数，可以将任意类型的参数mix转换为数值类型。其规则为：" class="headerlink" title="Number(mix)函数，可以将任意类型的参数mix转换为数值类型。其规则为："></a>Number(mix)函数，可以将任意类型的参数mix转换为数值类型。其规则为：</h3><pre><code>（1）如果是布尔值，true和false分别被转换为1和0（2）如果是数字值，返回本身。（3）如果是null，返回0.（4）如果是undefined，返回NaN。（5）如果是字符串，遵循以下规则：        1、如果字符串中只包含数字，则将其转换为十进制（忽略前导0）        2、如果字符串中包含有效的浮点格式，将其转换为浮点数值（忽略前导0）        3、如果是空字符串，将其转换为0        4、如果字符串中包含非以上格式，则将其转换为NaN（6）如果是对象，则调用对象的valueOf()方法，然后依据前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，再次依照前面的规则转换返回的字符串值。</code></pre><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>ECMA-262 描述了一组用于操作数据值的操作符，包括算术操作符（如加号和减号）、位操作符、关系操作符和相等操作符。ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字符串、数字值、布尔值，甚至对象。不过，<code>在应用于对象时，相应的操作符通常都会调用对象的 valueOf()和（或）toString() 方法，以便取得可以操作的值。</code> 隐式类型转换就在这些时候出现了！（大部分是数值转的）这里我列出几个比较特殊情况的。（详细规则请参考红宝书第三章操作符）</p><h3 id="一元加操作符（-）（-）"><a href="#一元加操作符（-）（-）" class="headerlink" title="一元加操作符（+）（-）"></a>一元加操作符（+）（-）</h3><p>对非数值应用一元加操作符时，该操作符会像 Number() 转型函数一样对这个值执行转换。</p><h3 id="乘性操作符（-）"><a href="#乘性操作符（-）" class="headerlink" title="乘性操作符（*）"></a>乘性操作符（*）</h3><p>如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值。</p><h3 id="加性操作符-加法运算是自左向右的"><a href="#加性操作符-加法运算是自左向右的" class="headerlink" title="加性操作符 加法运算是自左向右的"></a>加性操作符 加法运算是自左向右的</h3><p>只有一个操作数是字符串，则将另一个操作数转换为字符串。<br>如果有一个操作数是对象、数值或布尔值，则调用它们的 toString() 方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于 undefined 和 null ，则分别调用 String() 函数并取得字符串 “undefined” 和 “null” 。</p><blockquote><p>《Effective JavaScript》P11：当+用在连接字符串时，当一个对象既有toString方法又有valueOf方法时候，JS通过盲目使用valueOf方法来解决这种含糊。对象通过valueOf方法强制转换为数字，通过toString方法强制转换为字符串</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + &#123;&#125;)  <span class="comment">// 1[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">''</span> + &#123;<span class="attr">toString</span>:<span class="function"><span class="params">()</span>=&gt;</span><span class="string">'S'</span>,<span class="attr">valueOf</span>:<span class="function"><span class="params">()</span>=&gt;</span><span class="string">'J'</span>&#125;)       <span class="comment">// J</span></span><br></pre></td></tr></table></figure><p>+连接一个字符串或者是数字的时候，如果我们没有重新定义valueOf和toString，其隐式转换会调用默认的toString()方法，将函数本身内容作为字符串返回;<br>如果我们自己重新定义toString/valueOf方法，那么其转换会按照我们的定义来，其中valueOf比toString优先级更高!!!</p><h3 id="关系操作符-小于（-lt-）、大于（-gt-）、小于等于（-lt-）和大于等于（-gt-）"><a href="#关系操作符-小于（-lt-）、大于（-gt-）、小于等于（-lt-）和大于等于（-gt-）" class="headerlink" title="关系操作符 小于（&lt;）、大于（&gt;）、小于等于（&lt;=）和大于等于（&gt;=）"></a>关系操作符 小于（&lt;）、大于（&gt;）、小于等于（&lt;=）和大于等于（&gt;=）</h3><p>如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。<br>如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。</p><p>参考链接：<br><a href="https://www.cnblogs.com/Juphy/p/7085197.html" target="_blank" rel="noopener">JS类型转换（强制和自动的规则）</a><br><a href="https://juejin.im/post/5b51e5d3f265da0f4861143c" target="_blank" rel="noopener">JS 中可以提升幸福度的小技巧</a><br><a href="https://blog.csdn.net/x_jagger/article/details/73430959" target="_blank" rel="noopener">一篇文章搞懂toString() 和 valueOf()</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js检测类型</title>
      <link href="/2019/01/09/web/js/%E5%9F%BA%E7%A1%80/js%E6%A3%80%E6%B5%8B%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/01/09/web/js/%E5%9F%BA%E7%A1%80/js%E6%A3%80%E6%B5%8B%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简单总结一下红宝书中检测数据类型方法。</p><h1 id="typeOf-操作符"><a href="#typeOf-操作符" class="headerlink" title="typeOf 操作符"></a>typeOf 操作符</h1><blockquote><p>要检测一个变量是不是基本数据类型？<code>typeof</code> 操作符是最佳的工具。说得更具体一点， <code>typeof</code> 操作符是确定一个变量是字符串、数值、布尔值，还是 undefined 的最佳工具。</p></blockquote><p>ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型—— typeof 就是负责提供这方面信息的操作符。对一个值使用 typeof 操作符可能返回下列某个字符串：</p><ul><li>“undefined” —— 如果这个值未定义；</li><li>“boolean” —— 如果这个值是布尔值；</li><li>“string” —— 如果这个值是字符串；</li><li>“number” —— 如果这个值是数值；</li><li>“object” —— 如果这个值是对象或 null；</li><li>“function” —— 如果这个值是函数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"hello"</span>;</span><br><span class="line">alert(<span class="keyword">typeof</span> message);  <span class="comment">// "string"</span></span><br><span class="line">alert(<span class="keyword">typeof</span>(message)); <span class="comment">// "string"</span></span><br><span class="line">alert(<span class="keyword">typeof</span> <span class="number">233</span>);      <span class="comment">// "number"</span></span><br><span class="line">alert(<span class="keyword">typeof</span> <span class="literal">null</span>);     <span class="comment">// "object"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> msg; <span class="comment">// 未初始化变量</span></span><br><span class="line">alert(<span class="keyword">typeof</span> msg);      <span class="comment">//"undefind"</span></span><br><span class="line"><span class="comment">// 未声明的变量</span></span><br><span class="line">alert(<span class="keyword">typeof</span> ms);       <span class="comment">//"undefind"</span></span><br></pre></td></tr></table></figure><h1 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h1><p>虽然在检测基本数据类型时 <code>typeof</code> 是非常得力的助手，但在检测引用类型的值时，这个操作符的用处不大。通常，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript提供了 <code>instanceof</code> 操作符，其语法如下所示：  </p><p>result = variable instanceof constructor  </p><p>variable 变量是给定引用类型（根据它的原型链来识别）的实例，那么 <code>instanceof</code> 操作符就会返回 true 。所有引用类型的值都是 Object 的实例。因此，在检测一个引用类型值和 Object 构造函数时(<code>variable instanceof Object</code>)， <code>instanceof</code> 操作符始终会返回 true 。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用instanceof 操作符。</p><h1 id="安全的类型检测-使用-Object-原生的-toString-方法"><a href="#安全的类型检测-使用-Object-原生的-toString-方法" class="headerlink" title="安全的类型检测 使用 Object 原生的 toString() 方法"></a>安全的类型检测 使用 Object 原生的 toString() 方法</h1><p>在任何值上调用 Object 原生的 toString() 方法，都会返回一个 [object NativeConstructorName] 格式的字符串。每个类在内部都有一个 [[Class]] 属性，这个属性中就指定了上述字符串中的构造函数名。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.prototype.toString.call([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));  <span class="comment">//"[object Array]"</span></span><br></pre></td></tr></table></figure><h2 id="检测原生-JSON-对象"><a href="#检测原生-JSON-对象" class="headerlink" title="检测原生 JSON 对象"></a>检测原生 JSON 对象</h2><p>这一技巧也广泛应用于检测原生 JSON 对象。 Object 的 toString() 方法不能检测非原生构造函数的构造函数名。因此，开发人员定义的任何构造函数都将返回[object Object]。有些 JavaScript 库会包含与下面类似的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isNativeJSON = <span class="built_in">window</span>.JSON &amp;&amp; <span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">JSON</span>) == <span class="string">"[object JSON]"</span>;</span><br></pre></td></tr></table></figure><h1 id="使用-constructor-属性"><a href="#使用-constructor-属性" class="headerlink" title="使用 constructor 属性"></a>使用 constructor 属性</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([].constructor); <span class="comment">// ƒ Array() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><p>实例的 <strong>proto</strong> 指针指向构造函数的原型对象。Object.getPrototypeOf()与<strong>proto</strong>相同，用来获取一个对象的prototype对象。</p><p>通过<strong>proto</strong>指针访问到是那个构造函数的原型对象，然后通过这个原型对象的 constructor（所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。）可以知道是什么引用类型了。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新年快乐！</title>
      <link href="/2019/01/01/blog/2019/"/>
      <url>/2019/01/01/blog/2019/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/asset/images/2019.jpg" alt="新年快乐！" title="Pixiv画师: Snozaki@篠崎"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Comet</title>
      <link href="/2018/12/31/web/Comet/"/>
      <url>/2018/12/31/web/Comet/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Comet 是 Alex Russell 发明的一个词儿，指的是一种更高级的 Ajax 技术（经常也有人称为“服务器<br>推送”）。 Ajax 是一种从页面向服务器请求数据的技术，而 Comet 则是一种服务器向页面推送数据的技<br>术。 Comet 能够让信息近乎实时地被推送到页面上，非常适合处理体育比赛的分数和股票报价。</p></blockquote><h1 id="两种实现-Comet-的方式：-长轮询和流"><a href="#两种实现-Comet-的方式：-长轮询和流" class="headerlink" title="两种实现 Comet 的方式： 长轮询和流"></a>两种实现 Comet 的方式： 长轮询和流</h1><h2 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h2><p><code>长轮询</code>把短轮询颠倒了一下。页面发起一个到服务器的请求，然后服务器一直保持连接打开，直到<br>有数据可发送。发送完数据之后，浏览器关闭连接，随即又发起一个到服务器的新请求。这一过程在页<br>面打开期间一直持续不断。</p><h3 id="长轮询和短轮询的区别"><a href="#长轮询和短轮询的区别" class="headerlink" title="长轮询和短轮询的区别"></a>长轮询和短轮询的区别</h3><p><code>长轮询</code>是传统轮询（也称为短轮询）的一个翻版，即浏览器定时向服务器发送请求，看有没有更新的数据。</p><ul><li>两者最大的区别<br>  在于服务器如何发送数据。短轮询是服务器立即发送响应，无论数据是否有效，而长轮询是等待发送响<br>  应。轮询的优势是所有浏览器都支持，因为使用 XHR 对象和 setTimeout()就能实现。而你要做的就<br>  是决定什么时候发送请求。</li></ul><h2 id="HTTP-流"><a href="#HTTP-流" class="headerlink" title="HTTP 流"></a>HTTP 流</h2><p>流不同于上述两种轮询，因为它在页面的整个生命周期内只使用一个 HTTP 连接。具体来说，就是浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>($j = <span class="number">1</span>; $j &lt;= <span class="number">10</span>; $j++) &#123;  </span><br><span class="line"><span class="keyword">echo</span> $j.<span class="string">" "</span>;  </span><br><span class="line">ob_flush();</span><br><span class="line">flush(); <span class="comment">// flush()刷新缓冲区的内容，输出。这一步会使缓冲区新增的内容被挤出去，显示到浏览器上   </span></span><br><span class="line">sleep(<span class="number">1</span>); <span class="comment">//等1秒钟</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ($i=<span class="number">10</span>; $i&gt;<span class="number">2</span>; $i--)&#123;</span><br><span class="line">    <span class="keyword">echo</span> $i.<span class="string">'&lt;br /&gt;'</span>;</span><br><span class="line">    ob_flush();</span><br><span class="line">    flush();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ob_end_flush();</span><br></pre></td></tr></table></figure><p>所有服务器端语言都支持打印到输出缓存然后刷新（将输出缓存中的内容一次性全部发送到客户<br>端）的功能。而这正是实现 HTTP 流的关键所在。</p><p>通过侦听 readystatechange 事件及检测 readyState 的值是否为 3，就可以利用 XHR 对象实现 HTTP 流。在上述这些浏览器中，随着不断从服务器接收数据， readyState 的值会周期性地变为 3。</p><h1 id="SSE（Server-Sent-Events，服务器发送事件）"><a href="#SSE（Server-Sent-Events，服务器发送事件）" class="headerlink" title="SSE（Server-Sent Events，服务器发送事件）"></a>SSE（Server-Sent Events，服务器发送事件）</h1><blockquote><p><code>SSE（Server-Sent Events，服务器发送事件）</code>是围绕只读 Comet 交互推出的 API 或者模式。 SSE API<br>用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。服务器响应的 MIME 类型必须是 <code>text/event-stream</code>，而且是浏览器中的 JavaScript API 能解析格式输出。 SSE 支持短轮询、长轮询和 HTTP 流，而且能在断开连接时自动确定何时重新连接。</p></blockquote><h2 id="SSE-API"><a href="#SSE-API" class="headerlink" title="SSE API"></a>SSE API</h2><p>要预订新的事件流，首先要创建一个新的 EventSource 对象，并传进一个入口点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="keyword">new</span> EventSource(<span class="string">"myevents.php"</span>)  <span class="comment">// 注意，传入的 URL 必须与创建对象的页面同源（相同的 URL 模式、域及端口）。</span></span><br></pre></td></tr></table></figure><p>EventSource 的实例有一个 readyState 属性，值为 0 表示正连接到服务器，值为 1 表示打开了连接，值为 2 表示关闭<br>了连接。</p><p>还有以下三个事件。</p><ul><li>open：在建立连接时触发。</li><li>message：在从服务器接收到新事件时触发。</li><li>error：在无法建立连接时触发。</li></ul><h3 id="close-强制立即断开连接"><a href="#close-强制立即断开连接" class="headerlink" title="close() 强制立即断开连接"></a>close() 强制立即断开连接</h3><p>默认情况下， EventSource 对象会保持与服务器的活动连接。如果连接断开，还会重新连接。这就意味着 SSE 适合长轮询和 HTTP 流。如果想强制立即断开连接并且不再重新连接，可以调用 close() 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source.close();</span><br></pre></td></tr></table></figure><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>所谓的服务器事件会通过一个持久的 HTTP 响应发送，这个响应的 MIME 类型为 text/event-stream。响应的格式是纯文本，最简单的情况是每个数据项都带有前缀 data:。</p><p>通过 id:前缀可以给特定的事件指定一个关联的 ID，这个 ID 行位于 data:行前面或后面皆可：<br>data: foo<br>id: 1<br>设置了 ID 后， EventSource 对象会跟踪上一次触发的事件。如果连接断开，会向服务器发送一个<br>包含名为 Last-Event-ID 的特殊 HTTP 头部的请求，以便服务器知道下一次该触发哪个事件。在多次<br>连接的事件流中，这种机制可以确保浏览器以正确的顺序收到连接的数据段。</p><h1 id="Web-Sockets"><a href="#Web-Sockets" class="headerlink" title="Web Sockets"></a>Web Sockets</h1><blockquote><p><code>Web Sockets</code> 的目标是在一个单独的持久连接上提供全双工、双向通信。在 JavaScript 中创建了 <code>Web Socket</code> 之后，会有一个 HTTP 请求发送到浏览器以发起连接。在取得服务器响应后，建立的连接会使用 HTTP 升级从 HTTP 协议交换为 <code>Web Socket</code> 协议。也就是说，使用标准的 HTTP 服务器无法实现 <code>Web Sockets</code>，只有支持这种协议的专门服务器才能正常工作。</p></blockquote><h2 id="Web-Sockets-API"><a href="#Web-Sockets-API" class="headerlink" title="Web Sockets API"></a>Web Sockets API</h2><p>要创建 Web Socket，先实例一个 WebSocket 对象并传入要连接的 URL：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，必须给 WebSocket 构造函数传入绝对 URL。同源策略对 Web Sockets 不适用，因此可以通过它打开到任何站点的连接。至于是否会与某个域中的页面通信，则完全取决于服务器。</span></span><br><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://www.example.com/server.php"</span>);</span><br></pre></td></tr></table></figure></p><p>与 XHR 类似， WebSocket 也有一个表示当前状态的 readyState 属性。不过，这个属性的值与 XHR 并不相同，而是如下所示。</p><ul><li>WebSocket.OPENING (0)：正在建立连接。</li><li>WebSocket.OPEN (1)：已经建立连接。</li><li>WebSocket.CLOSING (2)：正在关闭连接。</li><li>WebSocket.CLOSE (3)：已经关闭连接。</li></ul><p>WebSocket 没有 readystatechange 事件；不过，它有其他事件，对应着不同的状态。readyState的值永远从 0 开始。<br>要关闭 Web Socket 连接，可以在任何时候调用 close()方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.close();</span><br></pre></td></tr></table></figure><p>调用了 close()之后， readyState 的值立即变为 2（正在关闭），而在关闭连接后就会变成 3</p><h2 id="发送和接收数据"><a href="#发送和接收数据" class="headerlink" title="发送和接收数据"></a>发送和接收数据</h2><p>Web Socket 打开之后，就可以通过连接发送和接收数据。要向服务器发送数据，使用 send()方法并传入任意字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://www.example.com/12.php"</span>);</span><br><span class="line">socket.send(<span class="string">"Hello world!"</span>);</span><br></pre></td></tr></table></figure><p>因为 <strong><em>Web Sockets 只能通过连接发送纯文本数据</em></strong>，所以对于复杂数据结构，在通过连接发送之前，必须进行序列化。服务器要读取其中的数据，就要解析接收到的 JSON 字符串.</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>WebSocket 对象几个事件，在连接生命周期的不同阶段触发。</p><ul><li>message：当服务器向客户端发来消息时触发</li><li>open：在成功建立连接时触发。</li><li>error：在发生错误时触发，连接不能持续。</li><li>close：在连接关闭时触发。</li></ul><p>WebSocket 对象不支持 DOM 2 级事件侦听器，因此必须使用 DOM 0 级语法分别定义每个事件处理程序。</p><p>只有 close 事件的 event 对象有额外的信息。这个事件的事件对象有三个额外的属性： <code>wasClean</code>、 <code>code</code> 和 <code>reason</code>。其中，<br>wasClean 是一个布尔值，表示连接是否已经明确地关闭；<br>code 是服务器返回的数值状态码；<br>reason 是一个字符串，包含服务器发回的消息。  </p><blockquote><p>参考资料：JavaScript高级程序设计</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript动态解析和执行字符串</title>
      <link href="/2018/12/28/web/js/%E5%9F%BA%E7%A1%80/JavaScript%E5%8A%A8%E6%80%81%E8%A7%A3%E6%9E%90%E5%92%8C%E6%89%A7%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/12/28/web/js/%E5%9F%BA%E7%A1%80/JavaScript%E5%8A%A8%E6%80%81%E8%A7%A3%E6%9E%90%E5%92%8C%E6%89%A7%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在JavaScript中<code>eval</code>和<code>new Function</code>都可以动态解析和执行字符串。但两者有一定的区别。我这里总结一下自己了解的相关知识点。</p><h1 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h1><p>整个ECMAScript语言中最强大的一个方法<code>eval()</code>。<code>eval()</code>方法就像是一个完整的 ECMAScript 解析器，它只接受一个参数，即要执行的<code>ECMAScript（或 JavaScript）字符串</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">"alert('Hello World!')"</span>);</span><br></pre></td></tr></table></figure><p>当解析器发现代码中调用 <code>eval()</code> 方法时，它会将传入的参数当作实际的 ECMAScript 语句来解析，然后把执行结果插入到原位置。<br>通过 <code>eval()</code> 执行的代码被认为是包含该次调用的<code>执行环境</code>的一部分，因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过 eval() 执行的代码可以引用在包含环境中定义的变量。<a href="#eval和new-Function的区别">案例</a></p><h1 id="Function-构造函数"><a href="#Function-构造函数" class="headerlink" title="Function 构造函数"></a>Function 构造函数</h1><p>使用 Function 构造函数定义函数的方式。 Function 构造函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"arg1"</span>, <span class="string">"arg2"</span>, <span class="string">"return arg1 + arg2"</span>);</span><br></pre></td></tr></table></figure><h1 id="eval和new-Function"><a href="#eval和new-Function" class="headerlink" title="eval和new Function"></a>eval和new Function</h1><p>在JavaScript中动态解析和执行字符串时我们可以用到eval和new Function。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="string">'&#123;a:1,b:2&#125;'</span>；</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">'('</span>+data+<span class="string">')'</span>));</span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'return'</span> + data))());</span><br></pre></td></tr></table></figure><h2 id="eval和new-Function的区别。"><a href="#eval和new-Function的区别。" class="headerlink" title="eval和new Function的区别。"></a>eval和new Function的区别。</h2><p>eval中的代码执行时的作用域为当前作用域。它可以访问到函数中的局部变量。<br>new Function中的代码执行时的作用域为全局作用域，不论它的在哪个地方调用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">'local'</span></span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'console.log(x)'</span>)</span><br><span class="line">    ;(<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'console.log(x)'</span>))()</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br><span class="line"><span class="comment">// local</span></span><br><span class="line"><span class="comment">// global</span></span><br></pre></td></tr></table></figure><h1 id="问题：eval-‘-‘-jsondata-’-’-为什么还要加’-‘和’-’"><a href="#问题：eval-‘-‘-jsondata-’-’-为什么还要加’-‘和’-’" class="headerlink" title="问题：eval(‘(‘+jsondata+’)’)为什么还要加’(‘和’)’"></a>问题：eval(‘(‘+jsondata+’)’)为什么还要加’(‘和’)’</h1><p>由于json是以”<code>{}</code>“的方式来开始以及结束的，在JS中，它会被当成一个语句块来处理，所以必须强制性的将它转换成一种表达式。加上圆括号的目的是迫使eval函数在处理JavaScript代码的时候强制将括号内的表达式（expression）转化为对象，而不是作为语句（statement）来执行。</p><h2 id="扩展-function与感叹号"><a href="#扩展-function与感叹号" class="headerlink" title="扩展 function与感叹号"></a>扩展 function与感叹号</h2><p>平时我们可能对使用感叹号 (!) 或者添加括号来调用匿名函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()  <span class="comment">// true</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;())</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;)()</span><br></pre></td></tr></table></figure><p>其实无论是括号，还是感叹号，让整个语句合法做的事情只有一件，就是让一个函数声明语句变成了一个表达式。</p><p>使用括号包裹定义函数体，解析器将会以函数表达式的方式去调用定义函数。也就是说，任何能将函数变成一个函数表达式的作法，都可以使解析器正确的调用定义函数。而 ! 就是其中一个，而 + - || 等都有这样的功能。</p><blockquote><p>参考：<a href="https://swordair.com/function-and-exclamation-mark/" target="_blank" rel="noopener">https://swordair.com/function-and-exclamation-mark/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx（六）进阶 高级模块 （secure_link和geoip）</title>
      <link href="/2018/12/26/nginx/Nginx6/"/>
      <url>/2018/12/26/nginx/Nginx6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="secure-link-module-模块"><a href="#secure-link-module-模块" class="headerlink" title="secure_link_module 模块"></a><a href="http://nginx.org/en/docs/http/ngx_http_secure_link_module.html" target="_blank" rel="noopener">secure_link_module 模块</a></h1><p>ngx_http_secure_link_module模块用于检查请求链接的真伪，保护资源免受未经授权的访问，并限制链接的寿命。</p><p>该模块提供两种备选操作模式。第一种模式由secure_link_secret指令启用，用于检查请求链接的真实性以及保护资源免受未经授权的访问。第二种模式由secure_link和secure_link_md5指令启用， 可以用于限制链接的生命周期。</p><p>默认情况下不构建此模块，应使用–with-http_secure_link_module 配置参数启用它。</p><ol><li>制定并允许检查请求的链接的真实性以及保护资源避遭未经授权的访问</li><li>限制链接生效周期</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">location /s/ &#123;</span><br><span class="line">    #资源链接由后端生成，请求中传递的MD5哈希值以base64url编码。</span><br><span class="line">    # secure_link定义一个包含变量的字符串，从中提取链接的校验和值和生命周期。</span><br><span class="line">    secure_link $arg_md5,$arg_expires;</span><br><span class="line"></span><br><span class="line">    # $secure_link_expiress是请求中传递的链接的生命周期;仅用于secure_link_md5指令。</span><br><span class="line">    secure_link_md5 &quot;$secure_link_expires$uri$remote_addr secret&quot;;</span><br><span class="line"></span><br><span class="line">    # 将从字符串中提取的校验和值与secure_link_md5指令定义的表达式的MD5哈希值进行比较。如果校验和不同，则将$secure_link变量设置为空字符串。如果校验和相同，则检查链路生存期。请求中传递的MD5哈希值以base64url编码。</span><br><span class="line">    if ($secure_link = &quot;&quot;) &#123;</span><br><span class="line">        return 403;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ($secure_link = &quot;0&quot;) &#123;</span><br><span class="line">        return 410;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="geoip-module-模块"><a href="#geoip-module-模块" class="headerlink" title="geoip_module 模块"></a><a href="http://nginx.org/en/docs/http/ngx_http_geoip_module.html" target="_blank" rel="noopener">geoip_module 模块</a></h1><p>http_geoip_module模块会机遇IP地址匹配MaxMind GeoIP二进制文件，读取IP所在地域信息。</p><p>默认情况下不构建此模块，应使用–with-http_geoip_module 配置参数启用它。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>区别国内外作HTTP访问规则</li><li>区别国内城市地域作HTTP访问规则</li></ol><h2 id="Centos-进行安装使用geoip-module"><a href="#Centos-进行安装使用geoip-module" class="headerlink" title="Centos 进行安装使用geoip_module"></a>Centos 进行安装使用geoip_module</h2><ol><li><p>yum安装 （记得配置nginx的源，安装nginx前应该已经配置好了）</p><pre><code>yum install nginx-module-geoip</code></pre></li><li><p>安装完成到 <code>/etc/nginx/modules</code> 目录可以看到<code>geoip_module</code>相关文件</p></li><li><p>在nginx配置文件中动态加载<code>geoip_module</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load_module &quot;module/ngx_http_geoip_module.so&quot;;</span><br><span class="line">load_module &quot;module/ngx_stream_geoip_module.so&quot;;</span><br></pre></td></tr></table></figure></li><li><p>到 <a href="https://dev.maxmind.com/zh-hans/geoip/geoip2/geolite2/" title="MaxMind" target="_blank" rel="noopener">MaxMind</a> 下载IP地域文件（GeoLite2 City和GeoLite2 Country） 解压</p><blockquote><p>注意：MaxMind从2018年4月1日起停止更新GeoLite Legacy数据库。GeoLite Legacy数据库不再可供下载。尝试下载GeoLite Legacy数据库文件将导致错误：”找不到数据库版本”。<br>现在只能下载GeoLite2数据库了,GeoLite2数据库是GeoLite Legacy地理定位数据库的免费，更现代的版本。</p></blockquote></li><li><p>在配置文件中配置geoip_module的 geoip_country 和 geoip_city 指令 （两个指令都在http块配置）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">geoip_country /yourPath/GeoLite2-Country.mmdb;</span><br><span class="line">geoip_city /yourPath/GeoLite2-City.mmdb;</span><br></pre></td></tr></table></figure></li><li><p>现在已经可以读取客户端的IP所在地域信息啦，详细参数请到<a href="http://nginx.org/en/docs/http/ngx_http_geoip_module.html#geoip_country" target="_blank" rel="noopener">这里</a>查看</p><pre><code>$geoip_country_code 两个字母的国家/地区代码$geoip_country_code3 三个字母的国家/地区代码$geoip_country_name 国家/地区名称$geoip_city 城市名称</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File API</title>
      <link href="/2018/12/20/web/js/FileAPI/"/>
      <url>/2018/12/20/web/js/FileAPI/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>在HTML5中新增了File API，用于表示Web应用程序中的文件对象，以及以编程方式选择它们并访问它们的数据。做一下简单的总结。有兴趣的可以访问<a href="https://www.w3.org/TR/FileAPI/" target="_blank" rel="noopener">网站</a>详细了解。</p></blockquote><h1 id="FileList"><a href="#FileList" class="headerlink" title="FileList"></a>FileList</h1><p>FileList 对象针对表单的 file 控件。<br>当用户通过 file 控件选取文件后，这个控件的 <code>files</code> 属性值就是 <code>FileList 对象</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'file'</span> <span class="attr">multiple</span> <span class="attr">id</span>=<span class="string">"fileInput"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'fileInput'</span>).onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.files)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了用 file 控件，采用[<strong>拖放方式</strong>]，也可以得到 FileList 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dropZone = <span class="built_in">document</span>.getElementById(<span class="string">'drop_zone'</span>);</span><br><span class="line">dropZone.addEventListener(<span class="string">'drop'</span>, handleFileSelect, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleFileSelect</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    evt.stopPropagation();</span><br><span class="line">    evt.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> files = evt.dataTransfer.files; <span class="comment">// FileList object.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的 handleFileSelect 是拖放事件的回调函数，它的参数evt是一个事件对象，该参数的dataTransfer.files属性就是一个FileList对象，里面包含了拖放的文件。</p><h1 id="File"><a href="#File" class="headerlink" title="File"></a>File</h1><p>File对象可以用来获取某个文件的信息，还可以用来读取这个文件的内容。通常情况下，File对象是来自用户在一个 <code>&lt;input/&gt;</code>元素上选择文件后返回的FileList对象，也可以是来自由拖放操作生成的<a href="https://blog.csdn.net/qq_39198420/article/details/78059092" target="_blank" rel="noopener"><strong>DataTransfer对象</strong></a>。  </p><p>File 对象含有以下属性值：</p><ul><li>name：文件名，该属性只读</li><li>size：文件大小，单位为字节，该属性只读</li><li>type：文件的 MIME 类型，如果分辨不出类型，则为空字符串，该属性只读</li><li>lastModified：文件的上次修改时间，格式为时间戳</li><li>lastModifiedDate：文件的上次修改时间，格式为 Date 对象实例</li></ul><h1 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h1><p>File 对象是继承自 <code>Blob</code> 对象的。<br><code>Blob（Binary Large Object）</code>对象代表了一段二进制数据，提供了一系列操作接口。其他操作二进制数据的 API（比如 File 对象），都是建立在 Blob 对象基础上的，继承了它的属性和方法。</p><p>Blob构造函数，接受两个参数。<br>第一个参数是一个包含实际数据的数组<br>第二个参数是数据的类型，这两个参数都不是必需的。数组元素可以是任意多个的ArrayBuffer，ArrayBufferView (typed array)， Blob，或者 DOMString对象。</p><p>生成 Blob 对象有两种方法：一种是使用 Blob 构造函数，另一种是对现有的 Blob 对象使用 slice 方法切出一部分。</p><p>Blob 对象有两个只读属性：</p><ul><li>size：二进制数据的大小，单位为字节。（文件上传时可以在前端判断文件大小是否合适）</li><li>type：二进制数据的 MIME 类型，全部为小写，如果类型未知，则该值为空字符串。（文件上传时可以在前端判断文件类型是否合适）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'hello world'</span>];</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob(arr, &#123; <span class="string">"type"</span> : <span class="string">"text/plain"</span> &#125;); <span class="comment">// the blob</span></span><br><span class="line"><span class="built_in">console</span>.log(blob);</span><br></pre></td></tr></table></figure><h1 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h1><p><code>FileReader</code>对象用于读取文件，即把文件内容读入内存。它的参数是 File 对象或 Blob 对象。<br>对于不同类型的文件，FileReader 提供不同的方法读取文件。</p><ul><li>readAsBinaryString(Blob|File)：返回二进制字符串，该字符串每个字节包含一个0到255之间的整数。</li><li>readAsText(Blob|File, encode)：返回文本字符串。默认情况下，文本编码格式是 UTF-8，可以通过可选的格式参数，指定其他编码格式的文本</li><li>readAsDataURL(Blob|File)：返回一个基于 Base64 编码的 data-uri 对象（可用于 <code>&lt;img&gt;</code> 标签中的 src 属性，从而达到上传图片预览的效果）</li><li>readAsArrayBuffer(Blob|File)：返回一个 ArrayBuffer 对象</li></ul><p><code>FileReader</code> 对象采用异步方式读取文件，内置回调函数。</p><ul><li>onabort 方法：读取中断或调用 reader.abort() 方法时触发。</li><li>onerror 方法：读取出错时触发。</li><li>onload 方法：读取成功后触发。</li><li>onloadend 方法：读取完成后触发，不管是否成功。触发顺序排在 onload 或 onerror 后面。</li><li>onloadstart 方法：读取将要开始时触发。</li><li>onprogress 方法：读取过程中周期性触发。<code>（可以用来获取文件读取的进度）</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reader.result)</span><br><span class="line">  <span class="built_in">console</span>.log(e.target.result)</span><br><span class="line">  <span class="keyword">var</span> text = reader.result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'hello world'</span>];</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob(arr, &#123; <span class="string">"type"</span> : <span class="string">"text/plain"</span> &#125;); <span class="comment">// the blob</span></span><br><span class="line"><span class="comment">// console.log(blob);</span></span><br><span class="line"><span class="keyword">var</span> encoding = <span class="string">'UTF-8'</span></span><br><span class="line">reader.readAsText(blob, encoding);</span><br></pre></td></tr></table></figure><h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><blockquote><p>除了可以使用base64字符串作为内容的DataURI将一个文件嵌入到另外一个文档里，还可以使用URL对象。URL对象用于生成指向File对象或Blob对象的URL。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.URL</span><br></pre></td></tr></table></figure><ul><li>URL.createObjectURL()</li></ul><p>该方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectURL = URL.createObjectURL(blob);</span><br></pre></td></tr></table></figure><ul><li>URL.revokeObjectURL()</li></ul><p>该方法用来释放一个之前通过调用 URL.createObjectURL() 创建的已经存在的 URL 对象。当你结束使用某个 URL 对象时，应该通过调用这个方法来让浏览器知道不再需要保持这个文件的引用了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objectURL 是一个 DOMString，表示通过调用 URL.createObjectURL() 方法产生的 URL 对象</span></span><br><span class="line"><span class="built_in">window</span>.URL.revokeObjectURL(objectURL);</span><br></pre></td></tr></table></figure><h1 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h1><p>用 <code>FormData</code> 对象,我们可以通过JavaScript用一些键值对来模拟一系列表单控件,我们还可以使用XMLHttpRequest的send()方法来异步的提交这个”form”.比起普通的ajax,使用FormData的最大优点就是我们可以异步上传一个二进制文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> FormData (form? : HTMLFormElement)</span><br></pre></td></tr></table></figure><p>form 参数可选，是一个HTML表单元素，可以包含任何形式的表单控件,包括文件输入框。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><code>append() 给当前FormData对象添加一个键/值对</code></p><blockquote><p>1 void append(DOMString 键, Blob 值, [可选] DOMString 文件名);<br>2 void append(DOMString 键, DOMString 值);</p></blockquote><ul><li>name 字段名称</li><li>value 字段值，可以是Blob value，或者一个字符串，如果全都不是，则该值会被自动转换成字符串</li></ul><!-- ```jsvar fd = new FormData(); // 构造FromData对象fd.append('hello', 'hello world');``` --><blockquote><p>参考链接：<br><a href="https://segmentfault.com/a/1190000006600936" target="_blank" rel="noopener">JavaScript进阶学习（三）—— 基于html5 File API的文件操作</a><br><a href="https://blog.csdn.net/mr_wuch/article/details/70141674?utm_source=blogxgwz0" target="_blank" rel="noopener">Html5——File、FileReader、Blob、Fromdata对象</a><br><a href="http://javascript.ruanyifeng.com/htmlapi/file.html" target="_blank" rel="noopener">文件和二进制数据的操作</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/FormData</a> FormData</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx（五）进阶 Rewrite</title>
      <link href="/2018/12/14/nginx/Nginx5/"/>
      <url>/2018/12/14/nginx/Nginx5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h1><blockquote><p>通过中间件将动态请求和静态请求分离<br>分离资源，减少不必要的请求消耗，减少请求延时。</p></blockquote><h1 id="Rewrite-重写规则"><a href="#Rewrite-重写规则" class="headerlink" title="Rewrite 重写规则"></a>Rewrite 重写规则</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol><li>URL访问跳转，支持开发设计（页面跳转、兼容性支持、展示效果等）</li><li>SEO优化</li><li>维护（后台维护、流量转发等）</li><li>安全（伪静态）</li></ol><h2 id="常用配置语法-ngx-http-rewrite-module"><a href="#常用配置语法-ngx-http-rewrite-module" class="headerlink" title="常用配置语法 ngx_http_rewrite_module"></a>常用配置语法 <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" title="ngx_http_rewrite_module" target="_blank" rel="noopener">ngx_http_rewrite_module</a></h2><h3 id="rewrite-指令"><a href="#rewrite-指令" class="headerlink" title="rewrite 指令"></a>rewrite 指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Syntax:rewrite regex（正则） replacement（替换成的） [flag];</span><br><span class="line">Default:—</span><br><span class="line">Context:server, location, <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># flag 参数</span></span><br><span class="line"><span class="comment"># last 停止rewrite检测 并开始搜索与更改的URI匹配的新位置</span></span><br><span class="line"><span class="comment"># break 停止rewrite检测，停止处理当前的指令集</span></span><br><span class="line"><span class="comment"># redirect 返回302临时重定向，地址栏会显示跳转后的地址</span></span><br><span class="line"><span class="comment"># permanent 返回301永久重定向，地址栏会显示跳转后的地址</span></span><br></pre></td></tr></table></figure><h3 id="if-指令"><a href="#if-指令" class="headerlink" title="if 指令"></a>if 指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="keyword">if</span> (condition) &#123; ... &#125;</span><br><span class="line">Default: —</span><br><span class="line">Context: server, location</span><br></pre></td></tr></table></figure><ul><li>如果变量的值为空字符串或”0”，则为false ;</li><li>使用”=”和”!=”运算符比较变量和字符串;</li><li>使用”~”（对于区分大小写的匹配）和”~<em>“（对于不区分大小写的匹- 配）运算符，将变量与正则表达式进行匹配。正则表达式可以包含可供以后在$1.. $9变量中重用的捕获。负操作符”!~”和”!~</em>“也可用。如果正则表达式包含”}”或”;”字符，则整个表达式应包含在单引号或双引号中。</li><li>使用”-f”和”!-f”运算符检查文件是否存在;</li><li>使用”-d”和”!-d”运算符检查目录是否存在;</li><li>使用”-e”和”!-e”运算符检查文件，目录或符号链接是否存在;</li><li>使用”-x”和”!-x”运算符检查可执行文件。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!-e $request_filename)&#123;</span><br><span class="line">    rewrite  ^(.*)$  /index.php?s=$1  last;   break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="return-指令"><a href="#return-指令" class="headerlink" title="return 指令"></a>return 指令</h3><p>停止处理并将指定的内容返回code给客户端。非标准代码444在不发送响应头的情况下关闭连接。</p><pre><code>Syntax: return code [text];        return code URL;        return URL;Default: —Context: server, location, if</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    return 200 &apos;233&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set-指令"><a href="#set-指令" class="headerlink" title="set 指令"></a>set 指令</h3><p>设置一个变量，该变量的value可以包含文本，变量，文本和变量的组合。</p><pre><code>Syntax: set $variable value;Default: —Context: server, location, if</code></pre><h3 id="Rewrite-规则优先级"><a href="#Rewrite-规则优先级" class="headerlink" title="Rewrite 规则优先级"></a>Rewrite 规则优先级</h3><ol><li>执行server块的rewrite指令</li><li>执行location匹配</li><li>执行location块的rewrite指令</li></ol>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当初就不该学PHP</title>
      <link href="/2018/12/12/PHP/%E5%BD%93%E5%88%9D%E5%B0%B1%E4%B8%8D%E8%AF%A5%E5%AD%A6PHP/"/>
      <url>/2018/12/12/PHP/%E5%BD%93%E5%88%9D%E5%B0%B1%E4%B8%8D%E8%AF%A5%E5%AD%A6PHP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>舍友推荐的一首歌，真的扎心了。这里附上他的<a href="http://www.huangzhongxin.cn/" target="_blank" rel="noopener">博客</a> 有兴趣的去逛一逛哈。</p><blockquote><p>当初就不该学php – 黄灰红 词 : 黄绿蓝 曲 : 黄绿蓝</p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=472112352&auto=0&height=66"></iframe><pre><code>2013的某一天他认识了PHP可他从不敢相信那是噩梦的开启2015的某一天加班到无法休息忙里偷闲打开微信却没人发消息2017的某一天面试之前认真复习上上知乎问问建议当初就不该学PHP他们说用Python的看不起用Java的啊Java的也只能骂PHP啦就算你们都是用Python的呀Python3和Python2也势不两立啊用AS的看不起用Eclipse的啊可苹果也看不起做Android的Vim和Emacs吵个不停啦还天天骂Sublime的智障吗用React的看不起用Angular的Git用户天天骂SVN傻瓜Docker用户说Puppet是上个世纪的吗用图形界面不用命令智商不够用吗用Debian的瞧不起用Ubuntu的用MBP的说用win没钱吗BAT的说小公司也算公司吗独角兽说我分十亿你分得起吗黑轴茶轴天天纠缠不休啊难怪双飞燕的妹子插不上话坐Aeron的看不起坐办公椅的站着打代码的说你俩会长胖的985的看不起211的啊他们还天天骂北大青鸟呢考计算机二级是有病吗Gayhub没有一千星星别来丢人啦啊别再骂啦女朋友呢 找到了吗</code></pre><!--         <div id="aplayer-ZphyYnfC" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-ZphyYnfC"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "她的睫毛",              author: "周杰伦",              url: "http://home.ustc.edu.cn/~mmmwhy/%d6%dc%bd%dc%c2%d7%20-%20%cb%fd%b5%c4%bd%de%c3%ab.mp3",              pic: "http://home.ustc.edu.cn/~mmmwhy/jay.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script> –&gt;-->]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx（四）常见Nginx架构场景</title>
      <link href="/2018/12/10/nginx/Nginx4/"/>
      <url>/2018/12/10/nginx/Nginx4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="常见Nginx中间件架构"><a href="#常见Nginx中间件架构" class="headerlink" title="常见Nginx中间件架构"></a>常见Nginx中间件架构</h1><ul><li>静态资源web服务</li><li>代理服务</li><li>负载均衡调度器SLB</li><li>动态缓存</li></ul><h1 id="静态资源web服务-（优化配置之类的）"><a href="#静态资源web服务-（优化配置之类的）" class="headerlink" title="静态资源web服务 （优化配置之类的）"></a>静态资源web服务 （优化配置之类的）</h1><h2 id="ngx-http-core-module-模块的-Directive"><a href="#ngx-http-core-module-模块的-Directive" class="headerlink" title="ngx_http_core_module 模块的 Directive"></a><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html" target="_blank" rel="noopener">ngx_http_core_module</a> 模块的 Directive</h2><ul><li><p>sendfile “零拷贝” <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html" target="_blank" rel="noopener">ngx_http_core_module</a></p><blockquote><p>sendfile系统调用在两个文件描述符之间直接传递数据(完全在内核中操作)，从而避免了数据在内核缓冲区和用户缓冲区之间的拷贝，操作效率很高，被称之为零拷贝。</p></blockquote><p>  Syntax：sendfile on | off;<br>  Default：sendfile off;<br>  Context：http，server，location，if in location</p></li><li><p>tcp_nopush</p><blockquote><p>仅在使用sendfile时才启用这个选项。提高网络包的传输效率。</p></blockquote><p>  Syntax：sendfile on | off;<br>  Default：sendfile off;<br>  Context：http，server，location，if in location</p></li><li><p>tcp_nodelay</p><blockquote><p>keep-alive连接下，提高网络包的传输实时性。</p></blockquote><p>  Syntax: tcp_nodelay on | off;<br>  Default: tcp_nodelay on;<br>  Context: http, server, location</p></li></ul><h2 id="ngx-http-gzip-module-压缩模块的-Directive-（详细指令语法，参考官方文档）"><a href="#ngx-http-gzip-module-压缩模块的-Directive-（详细指令语法，参考官方文档）" class="headerlink" title="ngx_http_gzip_module 压缩模块的 Directive （详细指令语法，参考官方文档）"></a><a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html" target="_blank" rel="noopener">ngx_http_gzip_module</a> 压缩模块的 Directive （详细指令语法，参考官方文档）</h2><ul><li><p>gzip 压缩压缩</p><p>  Syntax: gzip on | off;<br>  Default: gzip off;<br>  Context: http, server, location, if in location</p></li><li><p>扩展Nginx压缩模块</p><ul><li>http_gzip_static_module - 预读gzip功能（访问预先压缩好的文件。）</li><li>http_gunzip_module - 应用支持gunzip的压缩方式（兼容不支持gzip的浏览器）</li></ul></li></ul><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><table><tr><td>校验是否过期</td><td>Expires(HTTP1.0)、Cache-Control(HTTP1.1) <br> 没有过期直接在从缓存中读取，不会请求服务端，下面两个头信息会请求服务端判断是否修改了文件</td></tr><tr><td>协议中的Eta头信息校验</td><td>Etag</td></tr><tr><td>Last—Modified头信息校验</td><td>Last—Modified</td></tr></table><ul><li><p><a href="http://nginx.org/en/docs/http/ngx_http_headers_module.html" target="_blank" rel="noopener">ngx_http_headers_module</a> 模块允许将”Expires”和”Cache-Control”头字段和任意字段添加到响应头！！。</p><p>  Syntax: expires [modified] time;</p><pre><code>expires epoch | max | off;</code></pre><p>  Default: expires off;<br>  Context: http, server, location, if in location</p></li></ul><h2 id="跨域访问-CORS-Access-Control-Allow-Origin"><a href="#跨域访问-CORS-Access-Control-Allow-Origin" class="headerlink" title="跨域访问 CORS (Access-Control-Allow-Origin)"></a>跨域访问 CORS (Access-Control-Allow-Origin)</h2><blockquote><p>注意 CSRF 攻击哦</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_header Access-Control-Allow-Origin *;</span><br><span class="line">add_header Access-Control-Allow-Methods GET,POST,PUT;</span><br></pre></td></tr></table></figure><h2 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h2><blockquote><p>目的：防止资源被盗用</p></blockquote><h3 id="基于http-referer防盗链配置模块"><a href="#基于http-referer防盗链配置模块" class="headerlink" title="基于http_referer防盗链配置模块"></a>基于http_referer防盗链配置模块</h3><pre><code>valid_referers 指定将嵌入$invalid_referer变量设置为空字符串的&quot;Referer&quot;请求头字段值。否则，变量将设置为&quot;1&quot;(无效的话 变量设置为1，再去判断返回403)。搜索匹配不区分大小写。Syntax: valid_referers none(可以为空) | blocked(可以不带协议信息) | server_names(服务器名称) | string ... | 正则(eg: ~/aaa/g);Default: —Context: server, location</code></pre><h1 id="代理服务"><a href="#代理服务" class="headerlink" title="代理服务"></a>代理服务</h1><h2 id="ngx-http-proxy-module-proxy-proxy-proxy-列几个常用的指令配置，详细请看官网"><a href="#ngx-http-proxy-module-proxy-proxy-proxy-列几个常用的指令配置，详细请看官网" class="headerlink" title="ngx_http_proxy_module proxy proxy proxy (列几个常用的指令配置，详细请看官网)"></a><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" title="http_proxy" target="_blank" rel="noopener">ngx_http_proxy_module</a> proxy proxy proxy (列几个常用的指令配置，详细请看官网)</h2><blockquote><p><a href="#缓存服务（代理缓存）">缓存服务（代理缓存）</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eg: location / &#123;</span><br><span class="line">        proxy_pass       http://localhost:8000;</span><br><span class="line">        proxy_set_header Host      <span class="variable">$host</span>;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>; <span class="comment"># 设置真实的IP请求头信息（X-Real-IP）</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>proxy_pass 代理地址</p><pre><code>Syntax: proxy_pass URL;Default: —Context: location, if in location, limit_except</code></pre></li><li><p>proxy_set_header 设置（发给后端的）请求头信息</p><pre><code>Syntax: proxy_set_header field value;Default: proxy_set_header Host $proxy_host;Context: http, server, location</code></pre></li><li><p>proxy_buffering 缓冲区 on | off</p></li><li><p>proxy_next_upstream 指定应将请求传递到下一个服务器</p><pre><code>Syntax: proxy_next_upstream error | timeout | invalid_header |        http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | http_429 | non_idempotent | off ...;Default: proxy_next_upstream error timeout;Context: http, server, location</code></pre></li></ul><h1 id="负载均衡-SLB"><a href="#负载均衡-SLB" class="headerlink" title="负载均衡 SLB"></a>负载均衡 SLB</h1><blockquote><p>GSLB: Global Server Load Balance(全局负载均衡)<br>SLB: Server Load Balance(负载均衡)<br>四层（OSI第四层就是传输层）负载均衡，也就是主要通过报文中的目标地址（ip）和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。<br>七层（OSI第七层就是应用层）负载均衡，也称为”内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p></blockquote><h2 id="Nginx配置-upstream-实现负载均衡-ngx-http-upstream-module"><a href="#Nginx配置-upstream-实现负载均衡-ngx-http-upstream-module" class="headerlink" title="Nginx配置 upstream 实现负载均衡 ngx_http_upstream_module"></a>Nginx配置 upstream 实现负载均衡 <a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html" target="_blank" rel="noopener">ngx_http_upstream_module</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server backend1.example.com       weight=5;</span><br><span class="line">    server backend2.example.com:8080;</span><br><span class="line">    server unix:/tmp/backend3;</span><br><span class="line"></span><br><span class="line">    server backup1.example.com:8080   backup;</span><br><span class="line">    server backup2.example.com:8080   backup;</span><br><span class="line">    # server 参数设置</span><br><span class="line">    # weight 设置服务器的权重（加权轮询），默认为1 （默认是轮询） 两个都不好，如果在有缓存的情况下用户每次都会访问到不一致的内容。（解决方法看下面的 hash）</span><br><span class="line">    # down   当前的server展示不参与SLB</span><br><span class="line">    # backup 预留的备份服务器</span><br><span class="line">    # max_fails 允许请求失败的次数</span><br><span class="line">    # fail_timeout 经过max_fail失败后，服务暂停的时间（等待响应时间）</span><br><span class="line">    # max_conns 限制最大的接受的连接数（根据服务器配置按需设置）默认值为零，表示没有限制</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>upstream</p><pre><code>Syntax: upstream name { ... }Default: —Context: http</code></pre></li><li><p>hash 指定服务器组的负载平衡方法，其中client-server映射基于散列key值。推荐使用这种方式</p><pre><code>Syntax: hash key [consistent];Default: —Context: upstream</code></pre></li><li><p>ip_hash  每个请求按访问IP的hash结果分配，这样来自同一个IP的固定访问一个后端服务器</p><blockquote><p>缺点：客户端请求将被传递到另一个服务器。最有可能的是，它也将始终是同一台服务器，而非真实的IP。</p></blockquote><pre><code>Syntax: ip_hash;Default: —Context: upstream</code></pre></li></ul><h1 id="缓存服务（代理缓存）"><a href="#缓存服务（代理缓存）" class="headerlink" title="缓存服务（代理缓存）"></a>缓存服务（代理缓存）</h1><blockquote><p>客户端缓存 代理缓存 服务端缓存（redis memcached）</p></blockquote><h2 id="Nginx代理缓存配置语法"><a href="#Nginx代理缓存配置语法" class="headerlink" title="Nginx代理缓存配置语法"></a><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_path" title="proxy_cache_path" target="_blank" rel="noopener">Nginx代理缓存配置语法</a></h2><h3 id="proxy-cache-path-设置缓存的路径和其他参数。"><a href="#proxy-cache-path-设置缓存的路径和其他参数。" class="headerlink" title="proxy_cache_path 设置缓存的路径和其他参数。"></a>proxy_cache_path 设置缓存的路径和其他参数。</h3><pre><code>Syntax: proxy_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time]        [max_size=size] [manager_files=number] [manager_sleep=time] [manager_threshold=time]        [loader_files=number] [loader_sleep=time] [loader_threshold=time] [purger=on|off]        [purger_files=number] [purger_sleep=time] [purger_threshold=time];Default: —Context: http# 上面部分参数的作用# path 代理缓存存储路径# levels 目录层次结构级别 eg: levels=1:2# keys_zone 所有的活性密钥和关于数据的信息被存储在共享存储器区，其name与size设置，配置keys_zone的参数。1M字节zone可以存储大约8000个密钥。  在proxy_cache配置会用到zone的name。eg: keys_zone=one:10m;# inactive 指定的时间内未访问的缓存数据 将从缓存中删除，无论其新鲜度如何。默认情况下，inactive设置为10分钟。# max_size 设置的最大缓存大小。超过此大小时，它会删除最近最少使用的数据。# use_temp_path 临时文件的目录 eg: use_temp_path=off 命令指示NGINX将在缓存这些文件时将它们写入同一个目录下。(并不是关闭临时文件存储)</code></pre><h3 id="proxy-cache-定义用于缓存的共享内存区域。"><a href="#proxy-cache-定义用于缓存的共享内存区域。" class="headerlink" title="proxy_cache 定义用于缓存的共享内存区域。"></a>proxy_cache 定义用于缓存的共享内存区域。</h3><pre><code>Syntax: proxy_cache zone | off;Default: proxy_cache off;Context: http, server, location</code></pre><h3 id="proxy-cache-valid-设置不同响应状态码的缓存时间。"><a href="#proxy-cache-valid-设置不同响应状态码的缓存时间。" class="headerlink" title="proxy_cache_valid  设置不同响应状态码的缓存时间。"></a>proxy_cache_valid  设置不同响应状态码的缓存时间。</h3><pre><code>eg: proxy_cache_valid 200 302 10m;    proxy_cache_valid 404      1m;    proxy_cache_valid any 1h;       # any 指定缓存任何响应    proxy_cache_valid 5m;           # 只缓存200,301和302的响应。Syntax: proxy_cache_valid [code ...] time;Default: —Context: http, server, location</code></pre><h3 id="proxy-no-cache-定义不将响应保存到缓存的条件。"><a href="#proxy-no-cache-定义不将响应保存到缓存的条件。" class="headerlink" title="proxy_no_cache 定义不将响应保存到缓存的条件。"></a>proxy_no_cache 定义不将响应保存到缓存的条件。</h3><blockquote><p>如果字符串参数的至少一个值不为空且不等于”0”，则不会保存响应</p></blockquote><pre><code>Syntax: proxy_no_cache string ...;Default: —Context: http, server, location</code></pre><h3 id="清理指定代理缓存"><a href="#清理指定代理缓存" class="headerlink" title="清理指定代理缓存"></a>清理指定代理缓存</h3><ol><li>rm -rf 删除缓存目录内容</li><li>使用第三方扩展模块ngx_cache_purge</li></ol><h3 id="大文件分片请求"><a href="#大文件分片请求" class="headerlink" title="大文件分片请求"></a>大文件分片请求</h3>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx（三）Nginx官方模块</title>
      <link href="/2018/12/08/nginx/Nginx3/"/>
      <url>/2018/12/08/nginx/Nginx3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Nginx模块"><a href="#Nginx模块" class="headerlink" title="Nginx模块"></a>Nginx模块</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li>Nginx官方模块</li><li>第三方模块</li></ol><h3 id="Nginx官方模块-部分-Modules-reference"><a href="#Nginx官方模块-部分-Modules-reference" class="headerlink" title="Nginx官方模块(部分) Modules reference"></a>Nginx官方模块(部分) <a href="http://nginx.org/en/docs/" title="doc" target="_blank" rel="noopener">Modules reference</a></h3><blockquote><p>使用<code>nginx -V</code> 可以看到模块（module）相关的编译参数 –with-XXXXX_module。</p></blockquote><h4 id="ngx-http-stub-status-module-模块提供对基本状态信息的访问"><a href="#ngx-http-stub-status-module-模块提供对基本状态信息的访问" class="headerlink" title="ngx_http_stub_status_module 模块提供对基本状态信息的访问"></a><a href="http://nginx.org/en/docs/http/ngx_http_stub_status_module.html" target="_blank" rel="noopener">ngx_http_stub_status_module</a> 模块提供对基本状态信息的访问</h4><blockquote><p>默认情况下不构建此模块，应使用–with-http_stub_status_module 配置参数启用它</p></blockquote><pre><code>Directives：stub_statusSyntax：stub_status;Default：-Context：server， location</code></pre><h4 id="ngx-http-random-index-module-模块处理以斜杠字符（’-‘）结尾的请求，并在目录中选择一个随机文件作为索引文件"><a href="#ngx-http-random-index-module-模块处理以斜杠字符（’-‘）结尾的请求，并在目录中选择一个随机文件作为索引文件" class="headerlink" title="ngx_http_random_index_module 模块处理以斜杠字符（’/‘）结尾的请求，并在目录中选择一个随机文件作为索引文件"></a><a href="http://nginx.org/en/docs/http/ngx_http_random_index_module.html" target="_blank" rel="noopener">ngx_http_random_index_module</a> 模块处理以斜杠字符（’/‘）结尾的请求，并在目录中选择一个随机文件作为索引文件</h4><blockquote><p>默认情况下不构建此模块，应使用–with-http_random_index_module 配置参数启用它 。</p></blockquote><pre><code>Directives：random_indexSyntax: random_index on | off;Default: random_index off;Context: location</code></pre><h4 id="ngx-http-sub-module-模块是一个过滤器，它通过将一个指定的字符串替换为另一个字符串（HTTP内容替换）"><a href="#ngx-http-sub-module-模块是一个过滤器，它通过将一个指定的字符串替换为另一个字符串（HTTP内容替换）" class="headerlink" title="ngx_http_sub_module 模块是一个过滤器，它通过将一个指定的字符串替换为另一个字符串（HTTP内容替换）"></a><a href="http://nginx.org/en/docs/http/ngx_http_sub_module.html" target="_blank" rel="noopener">ngx_http_sub_module</a> 模块是一个过滤器，它通过将一个指定的字符串替换为另一个字符串（HTTP内容替换）</h4><blockquote><p>默认情况下不构建此模块，应使用–with-http_sub_module 配置参数启用它 。</p></blockquote><pre><code>Directives：sub_filter 设置要替换的字符串和替换字符串。sub_filter_last_modified 允许在替换期间保留原始响应中的&quot;Last-Modified”头字段，以便于响应缓存。default： sub_filter_last_modified off;sub_filter_once 设置替换一次还是全部替换 default： sub_filter_once on;（替换一次）sub_filter_types 除了&quot;text/html&quot;之外，还在具有指定MIME类型的响应中启用字符串替换。特殊值&quot;*&quot;匹配任何MIME类型。default：sub_filter_types text/html;Syntax: sub_filter string(替换的字符) replacement(替换成的字符);Default: —Context: http, server, location</code></pre><h4 id="请求限制模块"><a href="#请求限制模块" class="headerlink" title="请求限制模块"></a>请求限制模块</h4><ul><li><p>连接限制 <a href="http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn_zone" target="_blank" rel="noopener">ngx_http_limit_conn_module</a></p><pre><code>limit_conn_zone 设置共享内存区域的参数，该区域将保留各种key的状态。Syntax: limit_conn_zone key zone=name:size;Default: —Context: httplimit_conn 设置共享内存区域和给定键值的最大允许连接数Syntax: limit_conn zone number;Default: —Context: http, server, location</code></pre></li><li><p>请求限制 <a href="http://nginx.org/en/docs/http/ngx_http_limit_req_module.html" target="_blank" rel="noopener">ngx_http_limit_req_module</a></p><pre><code>limit_req_zoneSyntax: limit_req_zone key zone=name:size rate=rate（请求处理速率） [sync];Default: —Context: httpeg: limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;limit_req 设置共享内存区域和请求的最大并发。Syntax: limit_req zone=name [burst=number](限制并发数，默认为0) [nodelay | delay=number](延迟执行);Default: —Context: http, server, location</code></pre></li></ul><h4 id="访问控制模块"><a href="#访问控制模块" class="headerlink" title="访问控制模块"></a>访问控制模块</h4><ul><li><p>基于客户端地址IP的访问控制-<a href="http://nginx.org/en/docs/http/ngx_http_access_module.html" target="_blank" rel="noopener">ngx_http_access_module</a></p><pre><code>Syntax: allow允许|deny拒绝 address | CIDR | unix: | all;Default: —Context: http, server, location, limit_except</code></pre><ul><li>局限性  通过其他的中间件（Nginx, 7lay LSB, CDN等）才到达服务端。<ol><li>采用X-Forwarded-For。</li><li>结合geo模块。</li><li>通过HTTP自定义变量传递。</li></ol></li></ul></li><li><p>基于用户的信任登录-<a href="http://nginx.org/en/docs/http/ngx_http_auth_basic_module.html" target="_blank" rel="noopener">ngx_http_auth_basic_module</a> 打开页面需要填写用户名和密码</p><pre><code>Directives:    auth_basic    auth_basic_user_file</code></pre><ul><li>局限性 1.用户信息依赖文件方式 2.操作光临机械，效率低下<br>  解决方法<ol><li>Nginx结合LUA实现高效验证</li><li>Nginx和LDAP打通，利用nginx-auth-ladp模块</li></ol></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx（二） 默认配置</title>
      <link href="/2018/12/07/nginx/Nginx2/"/>
      <url>/2018/12/07/nginx/Nginx2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>笔记可能有点乱 最好到<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#error_page" target="_blank" rel="noopener">官方文档</a>查看相关配置</p></blockquote><h1 id="Nginx-的主配置文件-（一部分主要的配置）"><a href="#Nginx-的主配置文件-（一部分主要的配置）" class="headerlink" title="Nginx 的主配置文件 （一部分主要的配置）"></a>Nginx 的主配置文件 （一部分主要的配置）</h1><pre><code>默认路径 `/etc/nginx/nginx.conf` (主配置文件)  </code></pre><!-- 想要修改主配置路径的去修改编译参数 --conf-path --><h1 id="Nginx-的默认配置语法"><a href="#Nginx-的默认配置语法" class="headerlink" title="Nginx 的默认配置语法"></a>Nginx 的默认配置语法</h1><h2 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h2><table><thead><tr><th>配置</th><th>作用</th></tr></thead><tbody><tr><td>user</td><td>设置nginx服务使用用户</td></tr><tr><td>worker_processes</td><td>工作进程数（一般设置为和cpu核数一样）</td></tr><tr><td>error_log</td><td>错误日记的目录<code>error_log /var/log/nginx/error.log [info warn notice(级别)]</code></td></tr><tr><td>pid</td><td>启动时候的pid目录</td></tr></tbody></table><h2 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h2><table><thead><tr><th>配置</th><th>作用</th></tr></thead><tbody><tr><td>worker_connections</td><td>每个进程允许最大链接数</td></tr><tr><td>use</td><td>I/O多路复用的具体的实现 select, poll, epoll</td></tr></tbody></table><h2 id="http块-server块-location块"><a href="#http块-server块-location块" class="headerlink" title="http块 server块 location块"></a>http块 server块 location块</h2><ul><li><p>error_page 定义指定错误显示的URI</p><pre><code>Example:error_page 404             /404.html;error_page 500 502 503 504 /50x.html;Syntax: error_page code ... [=[response]] uri;Default: —Context: http, server, location, if in location</code></pre></li></ul><h3 id="location块"><a href="#location块" class="headerlink" title="location块"></a>location块</h3><pre><code>Syntax: location [ = | ~ | ~* | ^~ ] uri { ... }location @name { ... }Default: —Context: server, location=   修饰符可以定义URI和位置的精确匹配。(优先级从上到下)^~  不检查正则表达式，前缀配置~   开头表示区分大小写的正则匹配~*  开头表示不区分大小写的正则匹配!~ 和 !~* 分别为区分大小写不匹配及不区分大小写不匹配的正则/ 通用匹配，任何请求都会匹配到。</code></pre><h3 id="日记相关的配置-error-log-and-access-log-详细到官网查看"><a href="#日记相关的配置-error-log-and-access-log-详细到官网查看" class="headerlink" title="日记相关的配置 error_log and access_log 详细到官网查看"></a>日记相关的配置 error_log and access_log 详细到<a href="http://nginx.org/en/docs/syslog.html" title="log_config" target="_blank" rel="noopener">官网</a>查看</h3><ul><li><p>log_format  指定日志格式  </p><pre><code>Syntax: log_format name(规则名) [escape=default|json|none] string ...;Default: log_format combined &quot;...&quot;;Context: http （log_format只在http块的配置）&gt; Nginx变量&gt; 1. HTTP请求变量        $arg_PARAMETER      请求行的参数 PARAMETER为要获取的那个key值          $http_HEADER        任意请求头字段; HEADER分是字段名称转换为小写，短划线由下划线替换        $sent_http_HEADER   任意响应头字段; HEADER分是字段名称转换为小写，短划线由下划线替换&gt; 2. 内置变量 Nginx内置的 （太多了，详细看[Embedded Variables](http://nginx.org/en/docs/http/ngx_http_core_module.html#var_status)）&gt; 3. 自定义变量</code></pre></li><li><p>access.log 记录每一次http请求访问</p><pre><code>Syntax: access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]];        access_log off;Default: access_log logs/access.log combined;Context: http, server, location, if in location, limit_except</code></pre></li></ul><h3 id="root-和-alias"><a href="#root-和-alias" class="headerlink" title="root 和 alias"></a>root 和 alias</h3><ol><li>root 设置请求的根目录。</li><li>如果必须修改URI， 则应使用alias指令。定义指定路径的替换。</li></ol><h3 id="error-page"><a href="#error-page" class="headerlink" title="error_page"></a>error_page</h3><p>定义将为指定错误显示的URI。uri值可以包含变量。</p><pre><code>Syntax: error_page code ... [=[response]] uri;Default: —Context: http, server, location, if in location</code></pre><p>会导致内部重定向到指定uri 的客户端请求方法更改为“GET”（对于除“GET”和“HEAD” 之外的所有方法）。<br>此外，可以使用“=response”语法将响应代码更改为另一个，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_page 404 =200 /empty.gif（相对路径，相对root的路径）;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统</title>
      <link href="/2018/12/06/linux/Linux%20%E7%B3%BB%E7%BB%9F/"/>
      <url>/2018/12/06/linux/Linux%20%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux-系统基本上分两大类"><a href="#Linux-系统基本上分两大类" class="headerlink" title="Linux 系统基本上分两大类"></a>Linux 系统基本上分两大类</h1><p>常用的Linux 系统基本上分两大类  </p><ol><li>Debian: Ubuntu、Debian 等</li><li>RedHat: Centos、Redhat 等</li></ol><h1 id="Debian系列"><a href="#Debian系列" class="headerlink" title="Debian系列"></a>Debian系列</h1><ul><li>常见的安装包格式 deb 包，安装 deb 包的命令是“dpkg -参数” dpkg(Debian Packager)</li><li>包管理工具 apt-get 会解决和安装模块的依赖问</li><li>dpkg是用来安装.deb文件,但不会解决模块的依赖关系,且不会关心ubuntu的软件仓库内的软件,可以用于安装本地的deb文件。</li><li>apt-get会解决和安装模块的依赖问题,并会咨询软件仓库, 但不会安装本地的deb文件, apt是建立在dpkg之上的软件管理工具。</li></ul><h2 id="dpkg-Debian-Packager-用法-常用的啊"><a href="#dpkg-Debian-Packager-用法-常用的啊" class="headerlink" title="dpkg(Debian Packager) 用法 (常用的啊)"></a>dpkg(Debian Packager) 用法 (常用的啊)</h2><ul><li><code>dpkg -i</code> 安装一个包，最好用apt-get啦</li><li><code>dpkg -r</code> 删除软件包（保留其配置信息）</li><li><code>dpkg -P</code> 删除一个包（包括配置信息）(⇀‸↼‶) 小心点用</li><li><code>dpkg -S</code> 搜索指定包里面的文件（模糊查询）ヾ(ﾟ∀ﾟゞ)</li><li><code>dpkg -s</code> 报告指定包的状态信息</li><li><code>dpkg -L</code> 显示一个包安装到系统里面的文件目录信息</li><li><code>dpkg -l</code> 示所有已经安装的Deb包，同时显示版本号以及简短说明</li></ul><p><a href="https://blog.csdn.net/lu_embedded/article/details/51994466" title="参考链接" target="_blank" rel="noopener">参考链接</a></p><h1 id="RedHat-系列"><a href="#RedHat-系列" class="headerlink" title="RedHat 系列"></a>RedHat 系列</h1><ul><li>常见的安装包格式 rpm 包，安装rpm包的命令是“rpm -参数”</li><li>包管理工具 yum, yum是rpm的前端程序，主要目的是设计用来自动解决rpm的依赖关系</li></ul><h2 id="rpm用法-常用"><a href="#rpm用法-常用" class="headerlink" title="rpm用法 (常用)"></a>rpm用法 (常用)</h2><ul><li><code>rpm -ivh name.rpm</code>　 #i表示安装，v表示显示安装过程，h表示显示进度</li><li><code>rpm -Uvh name.rpm</code>   升级</li><li><code>rpm -e NAME</code> 删除</li><li><code>rpm -q NAME</code> 查询（-q query）</li><li><code>rpm -ql NAME</code> 列出rpm包的文件内容(文件路径) ヾ(ﾟ∀ﾟゞ)</li><li><code>rpm -qi NAME</code> 列出已安装的这个包的标准详细信息</li></ul><h1 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h1><p>yum安装的优缺点<br>优点：安装东西，方便快捷，特别是不用考虑包依赖<br>缺点：安装过程，人为无法干预，不能按需，安装。源里面有什么就安装什么，安装的版本也比较低。</p><p>源码包安装的优缺点<br>优点：编译安装过程，可以设定参数，按照需求，进行安装，并且安装的版本，可以自己选择，灵活性比较大<br>缺点：由于安装包过新或者是其他问题，导致依赖的包没有，或者版本过低。这个时候就要解决包的依赖问题，linux系统中有的包，一个依赖一个，可能装一个小东西，就要解决一堆包的依赖问题，花很多时间解决包的依赖问题，得不尝失。</p><p>参考链接：<br><a href="https://www.jianshu.com/p/c70afbbf5172" target="_blank" rel="noopener">make 和 make install 的区别</a><br><a href="[https://www.jianshu.com/p/c70afbbf5172">Linux通过源码编译安装程序；yum和源码安转软件包的区别</a></p><h1 id="Linux操作系统版本"><a href="#Linux操作系统版本" class="headerlink" title="Linux操作系统版本"></a>Linux操作系统版本</h1><ol><li>查看内核版本命令<pre><code>cat /proc/versionuname</code></pre></li><li>查看Linux版本 <code>lsb_release -a</code></li></ol><p>参考：<a href="https://blog.csdn.net/shuaigexiaobo/article/details/78030008" target="_blank" rel="noopener">https://blog.csdn.net/shuaigexiaobo/article/details/78030008</a><br><a href="https://www.cnblogs.com/wzk-0000/p/7483262.html" target="_blank" rel="noopener">https://www.cnblogs.com/wzk-0000/p/7483262.html</a></p><h1 id="基本目录"><a href="#基本目录" class="headerlink" title="基本目录"></a>基本目录</h1><h2 id="usr-etc-var-home-root"><a href="#usr-etc-var-home-root" class="headerlink" title="/usr, /etc, /var, /home, /root"></a>/usr, /etc, /var, /home, /root</h2><ul><li>/usr (UNIX software resource) 与软件安装/执行相关</li><li>/etc 配置文件</li><li>/var (variable) 与系统运行有关 （一些）<ul><li>/var/log/     登录文件放置目录（日记记录等）</li><li>/var/cache/    应用程序本身运行过程中产生的缓存文件</li><li>/var/lib/        程序执行过程中产生的数据文件放置的目录， eg: MySQL的数据库放置到/var/lib/mysql</li></ul></li><li>/home 系统默认的用户主目录</li><li>/root 系统管理员的主目录</li></ul><h2 id="脚本目录"><a href="#脚本目录" class="headerlink" title="脚本目录"></a>脚本目录</h2><ul><li>/bin  存放系统的一些脚本指令</li><li>/sbin 一般是指超级用户脚本指令</li><li>/usr/bin　后期安装的一些软件的运行脚本</li><li>/usr/sbin 系统管理员必备的运行脚本</li><li>/etc/init.d 是 /etc/rc.d/init.d 的软链接(soft link) 服务脚本 eg: service nginx [start|stop|restart|reload|..]</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx（一）安装、相关目录与编译参数</title>
      <link href="/2018/12/06/nginx/Nginx1/"/>
      <url>/2018/12/06/nginx/Nginx1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>&emsp;&emsp;Nginx (engine x) 是一个高性能的HTTP和反向代理服务，也是一个IMAP/POP3/SMTP服务。我使用的是CentOS 6系统，Nginx1.14.2的版本。</p></blockquote><h1 id="Nginx优势"><a href="#Nginx优势" class="headerlink" title="Nginx优势"></a>Nginx优势</h1><ol><li><p>[I/O多路复用]epoll  </p><pre><code>I/O multiplexing 这里面的 multiplexing 指的其实是在**单个线程**通过记录跟踪每一个Sock(I/O流)的状态(对应空管塔里面的Fight progress strip槽)来同时管理多个I/O流。ngnix会有很多链接进来， epoll会把他们都监视起来，然后像拨开关一样，谁有数据就拨向谁，然后调用相应的代码处理。select, poll, epoll 都是I/O多路复用的具体的实现。epoll 可以说是I/O 多路复用最新的一个实现，epoll 修复了poll 和select绝大部分问题。</code></pre></li><li>轻量级<ul><li>功能模块少</li><li>代码模块化</li></ul></li><li>CPU亲和性(affinity)</li><li>sendfile: Linux中的”零拷贝”</li></ol><h1 id="Linux系统安装Nginx"><a href="#Linux系统安装Nginx" class="headerlink" title="Linux系统安装Nginx"></a>Linux系统安装<a href="http://nginx.org/en/linux_packages.html#stable" target="_blank" rel="noopener">Nginx</a></h1><blockquote><p>window系统直接到官网下载，配置一下环境变量就可以用啦</p><ol><li>版本<ul><li>Mainline version  开发板</li><li>Stable version    稳定版</li><li>Legacy version    历史版本</li></ul></li><li>使用yum安装<ol><li>增加yum源 /etc/yum.repos.d/nginx.repo<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 替换"OS"成"rhel"或"centos"，，"OSRELEASE"成"6"或"7"，分别为6 x或7.x的版本。</span></span><br><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/OS/OSRELEASE/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure></li></ol></li></ol></blockquote><h1 id="文件目录-使用-rpm-ql-nginx-dpkg-S-nginx-查看-eg：注意版本不同可能会有区别-￣▽￣-，下面是使用1-14-2版本的"><a href="#文件目录-使用-rpm-ql-nginx-dpkg-S-nginx-查看-eg：注意版本不同可能会有区别-￣▽￣-，下面是使用1-14-2版本的" class="headerlink" title="文件目录 ( 使用 rpm -ql nginx || dpkg -S nginx 查看 ) eg：注意版本不同可能会有区别 (￣▽￣)~*，下面是使用1.14.2版本的"></a>文件目录 ( 使用 <code>rpm -ql nginx</code> || <code>dpkg -S nginx</code> 查看 ) eg：注意版本不同可能会有区别 (￣▽￣)~*，下面是使用1.14.2版本的</h1><table><thead><tr><th style="text-align:left">路径</th><th style="text-align:left">类型</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">/etc/logrotate.d/nginx</td><td style="text-align:left">配置文件</td><td style="text-align:left">Nginx日记轮转，用于<br>logrotate服务的日记切割</td></tr><tr><td style="text-align:left">/etc/nginx/nginx.conf(主配置文件)<br>/etc/nginx/nginx.d/default.conf  <br>/etc/nginx/nginx.d/</td><td style="text-align:left">目录、配置文件</td><td style="text-align:left">Nginx主配置文件</td></tr><tr><td style="text-align:left">/etc/nginx/fastcgi_params<br>/etc/nginx/uwsgi_params<br>/etc/nginx/scgi_params</td><td style="text-align:left">配置文件</td><td style="text-align:left">cgi配置，fastcgi配置</td></tr><tr><td style="text-align:left">/etc/nginx/mime.types</td><td style="text-align:left">配置文件</td><td style="text-align:left">设置http协议的Content-Type与扩展名对应关系</td></tr><tr><td style="text-align:left">/lib/systemd/system/nginx.service<br></td><td style="text-align:left">配置文件</td><td style="text-align:left">用于配置系统守护进程(daemon)管理器管理方式</td></tr><tr><td style="text-align:left">/usr/share/nginx/modules/etc<br>/nginx/modules-available<br>/etc/nginx/modules-enabled</td><td style="text-align:left">目录</td><td style="text-align:left">Nginx模块目录</td></tr><tr><td style="text-align:left">/usr/sbin/nginx</td><td style="text-align:left">命令</td><td style="text-align:left">Nginx服务的启动管理命令</td></tr><tr><td style="text-align:left">/usr/share/doc<br>/usr/share/man/man8/nginx.8.gz</td><td style="text-align:left">文件、目录</td><td style="text-align:left">手册和帮助文件</td></tr><tr><td style="text-align:left">/var/lib/nginx</td><td style="text-align:left">目录</td><td style="text-align:left">Nginx的缓存目录？Nginx缓存服务</td></tr><tr><td style="text-align:left">/var/log/nginx</td><td style="text-align:left">目录</td><td style="text-align:left">Nginx的日记目录 Nginx日记</td></tr></tbody></table><h1 id="nginx-安装编译参数-nginx-V查看-eg：版本不同可能会有区别-￣▽￣-，我使用的是1-14-2版本"><a href="#nginx-安装编译参数-nginx-V查看-eg：版本不同可能会有区别-￣▽￣-，我使用的是1-14-2版本" class="headerlink" title="nginx 安装编译参数 (nginx -V查看)  eg：版本不同可能会有区别 (￣▽￣)~*，我使用的是1.14.2版本"></a>nginx 安装编译参数 (<code>nginx -V</code>查看)  eg：版本不同可能会有区别 (￣▽￣)~*，我使用的是1.14.2版本</h1><table><thead><tr><th>编译选项</th><th>作用</th></tr></thead><tbody><tr><td>–prefix=/usr/share/nginx<br>–conf-path=/etc/nginx/nginx.conf<br>–http-log-path=/var/log/nginx/access.log<br>–error-log-path=/var/log/nginx/error.log<br>–lock-path=/var/lock/nginx.lock<br>–pid-path=/run/nginx.pid<br>–modules-path=/usr/lib/nginx/modules<br></td><td>有什么作用，看看就懂了</td></tr><tr><td>–http-client-body-temp-path=/var/lib/nginx/body<br>–http-fastcgi-temp-path=/var/lib/nginx/fastcgi<br>–http-proxy-temp-path=/var/lib/nginx/proxy<br>–http-scgi-temp-path=/var/lib/nginx/scgi<br>–http-uwsgi-temp-path=/var/lib/nginx/uwsgi<br></td><td>执行对应模块是，nginx所产生保留的临时性文件</td></tr></tbody></table><h1 id="nginx-常用命令-help"><a href="#nginx-常用命令-help" class="headerlink" title="nginx 常用命令 (help)"></a>nginx 常用命令 (help)</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx -V  显示版本和配置选项</span></span><br><span class="line"><span class="comment"># nginx -t  测试配置</span></span><br><span class="line"><span class="comment"># nginx -c  用来指定启动Nginx服务使用的配置文件（默认值：/etc/nginx/nginx.conf）</span></span><br><span class="line"><span class="comment"># nginx -p  prefix路径 用来改变Nginx的安装路径，常用在平滑升级Nginx服务器的场合</span></span><br><span class="line"><span class="comment"># nginx -g  'directives' 用来补充Nginx配置文件，向Nginx服务指定启动时应用于全局的配置。eg: nginx -g 'daemon off'</span></span><br><span class="line"><span class="comment"># nginx -s  signal 用来向Nginx服务的主进程发送信号 stop, quit, reopen, reload</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 学习笔记</title>
      <link href="/2018/11/26/TechnologyStack/docker/"/>
      <url>/2018/11/26/TechnologyStack/docker/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;最近在搞小程序，已经好久没写博客了。本以为很小的一个项目，居然做现在(⇀‸↼‶)，不得不说小程序的坑真多。先缓一下了，学习一下最近很火的docker容器技术，随便做一下笔记。</p><h2 id="虚拟机与docker"><a href="#虚拟机与docker" class="headerlink" title="虚拟机与docker"></a>虚拟机与docker</h2><img src="/2018/11/26/TechnologyStack/docker/2018-11-27_205611.png" title="Vm vs docker"><h2 id="docker-commands-常用"><a href="#docker-commands-常用" class="headerlink" title="docker commands (常用)"></a>docker commands (常用)</h2><h3 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h3><ul><li>run 创建一个新的容器并运行一个命令 (没有的镜像会自动下载) <blockquote><p>-d(daemon): 后台运行容器，并返回容器ID；<br>  -i(interactive): 以交互模式运行容器，通常与 -t 同时使用;( • ̀ω•́ )✧<br>  -p: 端口映射，格式为：主机(宿主)端口:容器端口<br>  -v(vulome): 实现挂载功能 1.容器目录 2.主机目录(window的目录记得将<code>\</code>改成<code>/</code>):容器目录 …<br>  –vulomes-from: <code>--vulomes-from name|id</code>(容器的vulome)挂载到其他容器 将一个容器的挂载附加到另一个容器上（差不多这个意思 在容器终端用mount命令看一下）<br>  -t(terminal): 伪终端<br>  –name: –name “name” 为容器指定一个名称<br>  –rm: 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)</p></blockquote></li><li>start/stop/restart  启动/停止/重启容器(可多个)</li><li>create 创建一个新的容器但不启动它（区别于run命np令）</li><li>rm 删除一个或多少容器<blockquote><p><code>docker rm $(docker ps -aq)</code> 删除所有容器</p></blockquote></li><li>exec ：在运行的容器中执行命令<blockquote><p>-v: 实现挂载功能</p></blockquote></li></ul><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><ul><li>ps 列出容器<blockquote><p>-a: 显示所有的容器，包括未运行的。<br>-q: 静默模式，只显示容器编号。</p></blockquote></li><li>inspect 获取容器/镜像的元数据<blockquote><p>inspect [OPTIONS] NAME|ID</p></blockquote></li><li>logs 获取容器的日志<blockquote><p>-f: 跟踪日志输出<br>-t: 显示时间戳</p></blockquote></li></ul><h3 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h3><ul><li>images 列出本地镜像。(mirror)</li><li>rmi 删除本地一个或多少镜像。</li><li>build 命令用于使用 <code>Dockerfile</code> 创建镜像。<blockquote><p>–tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；<br>-f :指定要使用的Dockerfile路径；</p></blockquote></li><li>tag 标记本地镜像，将其归入某一仓库。 </li></ul><h3 id="镜像仓库-registry"><a href="#镜像仓库-registry" class="headerlink" title="镜像仓库(registry)"></a>镜像仓库(registry)</h3><ul><li>pull 从镜像仓库中拉取或者更新指定镜像<blockquote><p>-a :拉取所有 tagged 镜像</p></blockquote></li><li>push 将本地的镜像上传到镜像仓库, 要先登陆到镜像仓库<blockquote><p><code>docker push myapache:v1</code></p></blockquote></li><li>search 从Docker Hub查找镜像</li></ul><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><ul><li>FROM<blockquote><p><code>FROM &lt;image&gt;/&lt;image&gt;:&lt;tag&gt;/&lt;image&gt;:&lt;digest&gt;</code><br>指定基础镜像，并且必须是第一条指令。<br>如果不以任何镜像为基础，那么写法为：FROM scratch。</p></blockquote></li><li>RUN 运行指定的命令(区别于CMD)<blockquote><p>两种格式</p><ol><li><code>RUN &lt;command&gt;</code> </li><li><code>RUN [&quot;executable&quot;(可执行文件/command), &quot;param1&quot;, &quot;param2&quot;]</code> 一定要用双引号</li></ol></blockquote></li><li>CMD 容器启动时要运行的命令<blockquote><p>写法同RUN命令<br>一个dockerfile至多只能有一个cmd，如果有多个，只有最后一个生效。<br><strong>如果docker run没有指定任何的执行命令或者dockerfile里面也没有entrypoint，那么，就会使用cmd指定的默认的执行命令执行。 </strong></p><p>RUN &amp; CMD &amp; ENTRYPOINT<br>RUN是构件容器时就运行的命令以及提交运行结果<br>CMD是容器启动时执行的命令，在构件时并不运行</p></blockquote></li><li>MAINTAINER 指定作者<blockquote><p><code>MAINTAINER &lt;name&gt;</code></p></blockquote></li><li>EXPOSE 暴漏容器运行时的监听端口给外部<blockquote><p>EXPOSE并不会使容器访问主机的端口<br>如果想使得<code>容器与主机的端口有映射关系</code>，必须在容器启动的时候(<code>docker run</code>)加上 <strong><code>-P 参数</code></strong></p></blockquote></li><li>ENV 设置环境变量<blockquote><p>语法有两种:</p><ol><li><code>ENV &lt;key&gt; &lt;value&gt;</code> 设置一个  </li><li><code>ENV &lt;key&gt;=&lt;value&gt; ...</code> 可设置多个</li></ol></blockquote></li><li>ADD  一个复制命令，把文件（可以是远程的）复制到景象中。(区别COPY)<blockquote><p><code>ADD &lt;src&gt; &lt;dest&gt;</code></p></blockquote></li><li>COPY 复制本地文件到容器</li><li>ENTRYPOINT 启动时的默认命令<blockquote><p>写法同RUN命令格式<br>ENTRYPOINT 指令和CMD类似，它也可用户指定容器启动时要执行的命令，但如果dockerfile中也有CMD指令，CMD中的参数会被附加到ENTRYPOINT 指令的后面。<br>如果这时docker run命令带了参数，这个参数会覆盖掉CMD指令的参数，并也会附加到ENTRYPOINT 指令的后面。</p></blockquote></li><li>VOLUME 实现挂载功能，可以将内地文件夹或者其他容器种得文件夹挂在到这个容器中</li><li>USER 启动容器的用户，可以是用户名或UID</li><li>WORKDIR 设置工作目录</li></ul><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><pre><code>Compose是一个用于定义和运行多容器Docker应用程序的工具</code></pre><ul><li>window/MAC 安装时会自带 Linux需要独立安装一遍</li><li>docker-compose.yml</li><li>commands<pre><code>docker-compost stop    #停止容器docker-compose rm      #删除容器docker-compose build   #重新建立docker-compose up -d   #启动运行’‘</code></pre></li></ul><h2 id="遇到的问题记录"><a href="#遇到的问题记录" class="headerlink" title="遇到的问题记录"></a>遇到的问题记录</h2><ul><li>window下使用git bash 执行 <code>docker run -it nginx bash</code> 出现 <code>the input device is not a TTY.  If you are using mintty, try prefixing the command with &#39;winpty&#39;</code><br>  解决： 根据提示使用<code>winpty docker run -it nginx bash</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sass 学习笔记</title>
      <link href="/2018/11/08/web/css/sass/"/>
      <url>/2018/11/08/web/css/sass/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code>简单记录一下 sass 内容 （超简单的部分啊）</code></pre><h1 id="CSS-预处理器语言"><a href="#CSS-预处理器语言" class="headerlink" title="CSS 预处理器语言"></a>CSS 预处理器语言</h1><p><a href="https://www.sass.hk/" target="_blank" rel="noopener">Sass（SCSS</a>, LESS, Stylus, Turbine, Swithch CSS, CSS CacheerDT CSS</p><h1 id="进入-SASS"><a href="#进入-SASS" class="headerlink" title="进入 SASS"></a>进入 SASS</h1><p>Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。</p><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>sass使用<code>$</code>符号来标识变量</p><ul><li><p>变量名用中划线还是下划线分隔;</p><ol><li>sass的变量名可以与css中的属性名和选择器名称相同，包括中划线和下划线。</li><li>在sass的大 多数地方，中划线命名的内容和下划线命名的内容是互通的，除了变量，也包括对混合器和Sass函数的命名。但是在sass中纯css部分不互通，比如类名、ID或属性名。<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$link-color</span>: blue;</span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="variable">$link_color</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译后</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>默认变量值 !default<br>  一般情况下，你反复声明一个变量，只有最后一处声明有效且它会覆盖前边的值。<br>  Sass的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可。</p>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">'red.scss'</span>;   <span class="comment">//  $link-color: red;</span></span><br><span class="line"><span class="variable">$link-color</span>: blue;</span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="variable">$link_color</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译后</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./test.scss'</span>;  <span class="comment">//  $link-color: red;</span></span><br><span class="line"><span class="variable">$link-color</span>: blue !default;</span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="variable">$link_color</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="导入SASS文件"><a href="#导入SASS文件" class="headerlink" title="导入SASS文件"></a>导入SASS文件</h2><h3 id="使用SASS部分文件"><a href="#使用SASS部分文件" class="headerlink" title="使用SASS部分文件"></a>使用SASS部分文件</h3><p>那些专门为@import命令而编写的sass文件，<strong>并不需要生成对应的独立css文件</strong>，这样的sass文件称为局部文件。对此，sass有一个特殊的约定来命名这些文件。sass局部文件的文件名以下划线开头(<code>_test.scss</code>)。这样，sass就不会在编译时单独编译这个文件输出css，而只把这个文件用作导入。<br>当你@import一个局部文件时，还可以不写文件的全名，即省略文件名开头的下划线。举例来说，你想导入themes/_night-sky.scss这个局部文件里的变量，你只需在样式表中写@import “themes/night-sky”;。</p><h3 id="嵌套导入"><a href="#嵌套导入" class="headerlink" title="嵌套导入"></a>嵌套导入</h3><p>sass允许@import命令写在css规则内。这种导入方式下，生成对应的css文件时，局部文件会被直接插入到css规则内导入它的地方。</p><h3 id="原生的CSS导入"><a href="#原生的CSS导入" class="headerlink" title="原生的CSS导入"></a>原生的CSS导入</h3><p>被导入文件的名字以.css结尾；<br>被导入文件的名字是一个URL地址（比如<a href="http://www.sass.hk/css/css.css），由此可用谷歌字体API提供的相应服务；" target="_blank" rel="noopener">http://www.sass.hk/css/css.css），由此可用谷歌字体API提供的相应服务；</a><br>被导入文件的名字是CSS的url()值。</p><h2 id="混合器"><a href="#混合器" class="headerlink" title="混合器"></a>混合器</h2><p>@mixin<br>@include</p><h2 id="继承-extend"><a href="#继承-extend" class="headerlink" title="继承 @extend"></a>继承 @extend</h2><p>使用<code>sass</code>的时候，最后一个减少重复的主要特性就是选择器继承。基于<code>Nicole Sullivan</code>面向对象的css的理念，选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过<code>@extend</code>语法实现。<br><code>混合器主</code>要用于展示性样式的重用，而类名用于语义化样式的重用。因为继承是基于类的（有时是基于其他类型的选择器），所以继承应该是建立在语义化的关系上。</p><ul><li>基本用法</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fdd</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">  @<span class="keyword">extend</span> .error;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compiled</span></span><br><span class="line"><span class="selector-class">.error</span>, <span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fdd</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------</span><br><span class="line"><span class="comment">// .seriousError不仅会继承.error自身的所有样式，</span></span><br><span class="line"><span class="comment">// 跟.error有关的组合选择器样式也会被.seriousError以组合选择器的形式继承</span></span><br><span class="line"><span class="selector-class">.error</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-class">.error</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.2rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">  @<span class="keyword">extend</span> .error;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// compiled</span></span><br><span class="line"><span class="selector-class">.error</span> <span class="selector-tag">h1</span>, <span class="selector-class">.seriousError</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-class">.error</span>, <span class="selector-tag">h1</span><span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Commands</title>
      <link href="/2018/11/05/linux/linux/"/>
      <url>/2018/11/05/linux/linux/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code>一些linux的知识点。未分类。未分类。未分类。说三遍。</code></pre><h1 id="sh-bash-source"><a href="#sh-bash-source" class="headerlink" title="sh, bash, source, ./"></a>sh, bash, source, ./</h1><pre><code>- source 用法 `source filename` 可以用`.`来代替。source(或.)命令通常用于重新执行刚修改的初始化文档。（会改变当前process环境）- bash/sh 用法 都是打开一个subshell去读取、执行脚本，subshell里运行的脚本里设置变量，不会影响到父shell的。- ./ 用法 打开一个subshell去读取、执行脚本，但脚本需要有&quot;执行权限&quot;, 使用chmod +x filename直接运行./name.sh，首先你会查找脚本第一行是否指定了解释器，如果没指定，那么就用当前系统默认的shell(大多数linux默认是bash)，如果指定了解释器，那么就将该脚本交给指定的解释器。</code></pre><h1 id="find-grep"><a href="#find-grep" class="headerlink" title="find / grep"></a>find / grep</h1><pre><code>find /PATH -name &quot;*.h&quot; -exec grep -in &quot;helloworld&quot; {} \;</code></pre><h1 id="service目录"><a href="#service目录" class="headerlink" title="service目录"></a>service目录</h1><pre><code>/etc/init.d  # /etc/init.d 是 /etc/rc.d/init.d 的软链接(soft link)</code></pre><h1 id="netstat查看网络状态、端口状态"><a href="#netstat查看网络状态、端口状态" class="headerlink" title="netstat查看网络状态、端口状态"></a>netstat查看网络状态、端口状态</h1><pre><code>&gt; netstat -luntp 查看端口被占用情况 // t 指TCP端口 u 指UDP端口</code></pre><h1 id="etc-profile-etc-bashrc-bash-profile-bashrc（修改之后使用source命令进行初始化）"><a href="#etc-profile-etc-bashrc-bash-profile-bashrc（修改之后使用source命令进行初始化）" class="headerlink" title="/etc/profile, /etc/bashrc, ~/.bash_profile, ~/.bashrc（修改之后使用source命令进行初始化）"></a>/etc/profile, /etc/bashrc, ~/.bash_profile, ~/.bashrc（修改之后使用source命令进行初始化）</h1><ul><li>/etc/profile: 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置.</li><li>/etc/bashrc:  为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.</li><li>~/.bash_profile: 每个用户都可使用该文件输入<code>专用于自己</code>使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些<a href="#$PATH-变量">环境变量</a>,执行用户的.bashrc文件.</li><li>~/.bashrc: 权限控制到用户级别,该文件包含<code>专用于你</code>的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取. tip: alias 一般在这里设置永久生效</li></ul><p>参考链接:<br><a href="https://blog.csdn.net/missmecn/article/details/51941050" title="linux用户登录启动配置文件" target="_blank" rel="noopener">linux用户登录启动配置文件</a><br><a href="https://blog.csdn.net/sch0120/article/details/70256318" target="_blank" rel="noopener">关于“.bash_profile”和“.bashrc”区别的总结</a></p><h1 id="变量相关"><a href="#变量相关" class="headerlink" title="变量相关"></a>变量相关</h1><ul><li>在linux下声明一个变量的方法：变量名=变量值，=左右不能有空格，使用$变量名调用变量。</li><li>set命令可以查看所有变量，包括普通变量和环境变量 unset删除变量</li><li>将命令的执行结果赋值给变量有两种方法，方法一：使用<code></code>包住执行的命令，方法二：将命令放入$()内执行</li></ul><h1 id="压缩-and-解压"><a href="#压缩-and-解压" class="headerlink" title="压缩 and 解压"></a>压缩 and 解压</h1><ul><li><p>tar命令 </p><pre><code>tar -czvf a.tar.gz a.jpg  // c 压缩, z 有gzip属性的, v 显示所有过程, f 使用档案名字,这个参数是最后一个参数，后面只能接档案名。tar -xf file.tar -C ./file  // x 解压, -C 解压时指定释放的路径。tar -cjf a.tar.bz2 a.jp  // j 有bz2属性的</code></pre></li><li>其他命令<ol><li>zip/unzip</li><li>rar/unrar<br> rar a a.rar a.jpg</li><li>gzip -d/gunzip</li></ol></li></ul><h1 id="mount命令是经常会使用到的命令-它用于挂载Linux系统外的文件。"><a href="#mount命令是经常会使用到的命令-它用于挂载Linux系统外的文件。" class="headerlink" title="mount命令是经常会使用到的命令,它用于挂载Linux系统外的文件。"></a><code>mount</code>命令是经常会使用到的命令,它用于挂载Linux系统外的文件。</h1><h1 id="vim-常用操作"><a href="#vim-常用操作" class="headerlink" title="vim 常用操作"></a>vim 常用操作</h1><pre><code>- 翻页    <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ctrl+f forward向前翻一页</span></span><br><span class="line"><span class="comment"># ctrl+b backward向后翻一页</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ctlr+u up向上翻半页</span></span><br><span class="line"><span class="comment"># ctrl+d down向下翻半页</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># zz 让光标所在的行居屏幕中央</span></span><br><span class="line"><span class="comment"># zt 让光标所在的行居屏幕最上一行 t=top</span></span><br><span class="line"><span class="comment"># zb 让光标所在的行居屏幕最下一行 b=bottomE</span></span><br></pre></td></tr></table></figure>- 搜索        ?.. 在光标之前搜索        /.. 在光标之后搜索，按 n/N 分别是向后，向前- 替换<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># `:n1,n2(填$s时表示文件末尾)/替换的字符/替换成为的/g`</span></span><br></pre></td></tr></table></figure>- 定位：    gg: 命令将光标移动到文档开头    G: 移动的这个文件的最后一行    输入冒号(:)，打开命令输入框 输入命令：1或者0    输入冒号(:)，打开命令输入框 输入命令：$</code></pre><h1 id="dev-null-空设备"><a href="#dev-null-空设备" class="headerlink" title="/dev/null 空设备"></a>/dev/null 空设备</h1><pre><code>&gt; /dev/null属于字符特殊文件，它属于空设备，是一个特殊的设备文件，它会丢弃一切写入其中的数据，写入它的内容都会永远丢失，而且没有任何可以读取的内容。&gt;&gt; `cat $filename &gt;/dev/null` 与 `cat $filename 1&gt;/dev/null`一样。其中 1：表示标准输出（stdout）（默认值）， 0：表示标准输入流（stdin）， 2：表示标准错误输出（stderr）</code></pre><h1 id="head-和-tail"><a href="#head-和-tail" class="headerlink" title="head 和 tail"></a>head 和 tail</h1><pre><code>&gt; head 显示文件开头部分内容，默认10行 -n 显示行数&gt; tail 显示文件结尾部分内容，默认10行 -f 监听文件 -n 显示行数</code></pre><h1 id="iptables-防火墙"><a href="#iptables-防火墙" class="headerlink" title="iptables 防火墙"></a>iptables 防火墙</h1><pre><code>&gt; [参考链接](https://www.cnblogs.com/jtestroad/p/8031850.html)- 命令行方式    1. 开放端口命令： /sbin/iptables -I INPUT -p tcp --dport 8080(端口) -j ACCEPT(开放)|DROP(关闭)    2. 保存：/etc/rc.d/init.d/iptables save    3. 重启服务：/etc/init.d/iptables restart    4. 查看端口是否开放：iptables  -L -n- 编辑/etc/sysconfig/iptables文件    1. 编辑/etc/sysconfig/iptables文件：vim /etc/sysconfig/iptables       加入内容并保存：-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 8080(开放的端口) -j ACCEPT    1. 重启服务：/etc/init.d/iptables restart    2.  查看端口是否开放：/sbin/iptables -L -n&gt; 注意： Centos升级到7之后，内置的防火墙已经从iptables变成了firewalld。所以，端口的开启还是要从两种情况来说明的，即iptables和firewalld。参考链接：https://www.cnblogs.com/moxiaoan/p/5683743.html</code></pre><h1 id="ps-查看进程-用于显示当前进程-process-的状态。"><a href="#ps-查看进程-用于显示当前进程-process-的状态。" class="headerlink" title="ps 查看进程 用于显示当前进程 (process) 的状态。"></a>ps 查看进程 用于显示当前进程 (process) 的状态。</h1><pre><code>1. 常用参数        -a 显示同一终端下的所有程序        -A 显示所有进程 （等价于-e）        -w 显示加宽可以显示较多的资讯        -au 显示较详细的资讯        -aux 显示所有包含其他使用者的进程        c  显示进程的真实名称        -C&lt;命令&gt; 列出指定命令的状况  显示一个名为getty的进程的信息 ps -C getty        -d 显示所有进程，但省略所有的会话引线(utility)        -e 等于&quot;-A&quot;        e  显示环境变量        -f 全部列出，通常和其他选项联用。如：ps -fa or ps -fx and so on.        f  显示程序间的关系(树形结构  pstree命令也是显示树形结构)        x 显示所有程序，不以终端机来区分。        -x 显示没有控制终端的进程，同时显示各个命令的具体路径。dx不可合用。（utility）2. ps aux 和ps -ef  两者的输出结果差别不大，但展示风格不同。aux是BSD风格，-ef是System V风格。这是次要的区别，一个影响使用的区别是aux会截断command列，而-ef不会。当结合grep时这种区别会影响到结果。 举例请参考：http://www.2cto.com/os/201303/197697.html</code></pre><h1 id="Linux下查看和添加环境变量-PATH"><a href="#Linux下查看和添加环境变量-PATH" class="headerlink" title="Linux下查看和添加环境变量 PATH"></a>Linux下查看和添加环境变量 PATH</h1><h2 id="PATH-变量"><a href="#PATH-变量" class="headerlink" title="$PATH 变量"></a>$PATH 变量</h2><p>$PATH：决定了shell将到哪些目录中寻找命令或程序，PATH的值是一系列目录，当您运行一个程序时，Linux在这些目录下进行搜寻编译链接。<br>格式: <code>PATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:------:&lt;PATH N&gt;</code><br>可以自己加上指定的路径，中间用冒号隔开。环境变量更改后，在用户下次登陆时生效，如果想立刻生效，则可执行下面的语句：$ source .bash_profile</p><h2 id="查看PATH"><a href="#查看PATH" class="headerlink" title="查看PATH"></a>查看PATH</h2><ol><li>使用 <code>export</code> 命令查看PATH值</li><li><code>echo $PATH</code></li></ol><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><ol><li><p>临时添加PATH环境变量</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[yonjim@localhost ~]$ <span class="built_in">export</span> PATH=/binPath/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li><li><p>永久添加环境变量(仅影响当前用户)</p><ol><li>编辑<code>~/.bashrc</code>或者<code>~/.bash_profile</code>文件 <code>vim ~/.bash_profile</code> 在文档最后，添加:<code>export PATH=&quot;/binPath/bin:$PATH&quot;</code>保存，退出</li><li>使用修改内容生效 <code>source ~/.bash_profile</code></li></ol></li><li>永久添加环境变量(影响所有用户)<ol><li>编辑/etc/profile文件 <code>vim /etc/profile</code> 在文档最后，添加:<code>export PATH=&quot;/binPath/bin:$PATH&quot;</code>保存，退出</li><li>使用修改内容生效 <code>source /etc/profile</code></li></ol></li></ol><blockquote><p>参考链接：<a href="https://www.cnblogs.com/aaronLinux/p/5837702.html" target="_blank" rel="noopener">https://www.cnblogs.com/aaronLinux/p/5837702.html</a></p></blockquote><h1 id="nohup-和-amp-和-daemon"><a href="#nohup-和-amp-和-daemon" class="headerlink" title="nohup 和 &amp; 和 daemon"></a>nohup 和 &amp; 和 daemon</h1><h2 id="linux下的常见信号"><a href="#linux下的常见信号" class="headerlink" title="linux下的常见信号"></a>linux下的常见信号</h2><p>在了解nohup 和 &amp; 和 daemon之前，我们要先简单了解一下linux下的信号。</p><h3 id="信号本质"><a href="#信号本质" class="headerlink" title="信号本质"></a>信号本质</h3><p>软中断信号（signal，又简称为信号）用来通知进程发生了异步事件。在软件层次上是对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。</p><h4 id="Linux支持的信号（这里只列了SIGHUP和SIGINT信号，详细了解请到Linux信号（signal-机制分析）"><a href="#Linux支持的信号（这里只列了SIGHUP和SIGINT信号，详细了解请到Linux信号（signal-机制分析）" class="headerlink" title="Linux支持的信号（这里只列了SIGHUP和SIGINT信号，详细了解请到Linux信号（signal) 机制分析）"></a>Linux支持的信号（这里只列了SIGHUP和SIGINT信号，详细了解请到<a href="https://blog.csdn.net/dai_xiangjun/article/details/41871647" target="_blank" rel="noopener">Linux信号（signal) 机制分析</a>）</h4><ol><li><p>SIGHUP：终端挂起或者控制进程终止</p><p>SIGHUP会在以下3种情况下被发送给相应的进程：</p><p> 1、终端关闭时，该信号被发送到session首进程以及作为job提交的进程（即用 &amp; 符号提交的进程）</p><p> 2、session首进程退出时，该信号被发送到该session中的前台进程组中的每一个进程</p><p> 3、若父进程退出导致进程组成为孤儿进程组，且该进程组中有进程处于停止状态（收到SIGSTOP或SIGTSTP信号），该信号会被发送到该进程组中的每一个进程。</p><p> 系统对SIGHUP信号的默认处理是终止收到该信号的进程。所以若程序中没有捕捉该信号，当收到该信号时，进程就会退出。</p></li><li><p>SIGINT： 程序中止信号，在用户键入INTR字符（通常是Ctrl+C）时发出。</p></li></ol><h2 id="nohup（不挂起）"><a href="#nohup（不挂起）" class="headerlink" title="nohup（不挂起）"></a>nohup（不挂起）</h2><p>用途：不挂断地运行命令。<br>语法：nohup Command [Arg…] [&amp;]<br>描述：nohup 命令运行由 Command 参数和任何相关的 Arg 参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的nohup 命令，添加&amp;（表示”and”的符号）到命令的尾部。</p><h2 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h2><p>就是将程序放在后台运行。对于shell来说，通过&amp; 可以把一个程序放在后台运行。其就是作为一个job来运行的。此时如果终端断开，程序还是会被SIGHUP信号导致退出的。即上面SIGHUP信号的第一种场景。</p><h2 id="nohup与-amp"><a href="#nohup与-amp" class="headerlink" title="nohup与&amp;"></a>nohup与&amp;</h2><ol><li><p>使用&amp;后台运行程序：</p><p> 结果会输出到终端<br> 使用Ctrl + C发送SIGINT信号，程序免疫<br> 关闭session发送SIGHUP信号，程序关闭</p></li><li><p>使用nohup运行程序：</p><p> 结果默认会输出到nohup.out<br> 使用Ctrl + C发送SIGINT信号，程序关闭<br> 关闭session发送SIGHUP信号，程序免疫  </p></li><li><p>平日线上经常使用nohup和&amp;配合来启动程序：</p><p> 同时免疫SIGINT和SIGHUP信号</p></li></ol><h2 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h2><p>Daemon进程也就是守护进程，linux大多数的服务进程都是通过守护进程实现的。比如0号进程(调度进程) ，1号进程(init进程)。从其名字守护看出其一般就是机器启动就运行，关机才停止。所以其应该不会受到终端的影响。同时其实在后台运行的。</p><p>参考链接：<br><a href="https://blog.csdn.net/dai_xiangjun/article/details/41871647" target="_blank" rel="noopener">Linux信号（signal) 机制分析</a><br><a href="https://blog.csdn.net/lovemdx/article/details/20529563" target="_blank" rel="noopener">linux 的nohup &amp; 和daemon 总结</a><br><a href="https://mp.weixin.qq.com/s/nyT-FPdIUdJUiUCYVGEnTg" target="_blank" rel="noopener">一分钟了解nohup和&amp;的功效</a></p><h1 id="ln命令-软链接"><a href="#ln命令-软链接" class="headerlink" title="ln命令 软链接"></a>ln命令 软链接</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 常用来设置软链接</span><br><span class="line">ln -s 源目标 目标文件</span><br></pre></td></tr></table></figure><p>注意：路径的问题，用绝对路径没那么多问题，相对路径的话。。</p><p>了解更多：<a href="http://www.runoob.com/linux/linux-comm-ln.html" target="_blank" rel="noopener">http://www.runoob.com/linux/linux-comm-ln.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用命令整合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 hexo 标签插件</title>
      <link href="/2018/11/03/blog/hexo/tagPlugins/"/>
      <url>/2018/11/03/blog/hexo/tagPlugins/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;hexo的标签插件和markdown的原生语法的作用差不多，但还是有挺大的区别的，写个博客记录一下。</p><h2 id="引用资源"><a href="#引用资源" class="headerlink" title="引用资源"></a>引用资源</h2><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">asset_path</span> 11.png %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">asset_img</span> 11.png This is an example image %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">asset_link</span> 11.png This is an example image %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><h2 id="插入图片-Image"><a href="#插入图片-Image" class="headerlink" title="插入图片 Image"></a>插入图片 Image</h2><p>在文章中插入指定大小的图片（也可以用img标签实现）<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125;</span><br></pre></td></tr></table></figure></p><h2 id="插入图片-Link"><a href="#插入图片-Link" class="headerlink" title="插入图片 Link"></a>插入图片 Link</h2><p>在文章中插入链接，并自动给外部链接添加 target=”_blank” 属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link text url [external] [title] %&#125;</span><br></pre></td></tr></table></figure></p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>简单的写法，它使用三个反引号来包裹。<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">``` [language] [title] [url] [link text] </span><br><span class="line"><span class="keyword">code</span> snippet</span><br><span class="line">```</span><br></pre></td></tr></table></figure></p><p>在文章中插入代码。<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock <span class="string">[title 说明]</span> <span class="string">[lang:language 指定语言（原生语法也可以指定语言）]</span> <span class="string">[url 网址]</span> <span class="string">[link text 连接显示的文本]</span> %&#125;</span><br><span class="line">code snippet</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure></p><p>附加说明和网址（多了的）<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock _.compact ht<span class="symbol">tp:</span>//underscorejs.org/#compact Underscore.js %&#125;</span><br><span class="line">_.compact([<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">false</span>, <span class="number">2</span>, '', <span class="number">3</span>]);</span><br><span class="line">=&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure></p><p>使用效果：<br><figure class="highlight excel"><figcaption><span>_.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="noopener">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.compact([<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">false</span>, <span class="number">2</span>, '', <span class="number">3</span>]);</span><br><span class="line">=&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><h2 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h2><p>在文章中插入引言，可包含作者、来源和标题。<br>（跟 &gt; 差不多，区别在于它提供了一个标准格式，可以很方便地插入引言，可包含作者、来源和标题。）<br><figure class="highlight twig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">blockquote</span> [author[, <span class="name">source</span>]] [link] [source_link_title] %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">content</span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">endblockquote</span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p><p>效果：<br><blockquote><p>content</p><footer><strong>YongJian</strong><cite><a href="https://YongJianh.github.io" target="_blank" rel="noopener">myBlog</a></cite></footer></blockquote></p><h2 id="插入-Swig-标签"><a href="#插入-Swig-标签" class="headerlink" title="插入 Swig 标签"></a>插入 Swig 标签</h2><p>如果您想在文章中插入 Swig 标签，可以尝试使用 Raw 标签，以免发生解析异常。</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">raw</span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name">set</span> foo = [1,2,3] %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">for</span></span> bar <span class="keyword">in</span> foo %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        </span><span class="template-tag">&#123;% <span class="name">bar</span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endfor</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">endraw</span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><h1 id="NexT主题的内置标签"><a href="#NexT主题的内置标签" class="headerlink" title="NexT主题的内置标签"></a>NexT主题的内置标签</h1><h2 id="Bootstrap-Callout"><a href="#Bootstrap-Callout" class="headerlink" title="Bootstrap Callout"></a>Bootstrap Callout</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#其中，class_name 可以是以下列表中的一个值：default, primary, success, info, warning, danger</span></span><br></pre></td></tr></table></figure><h2 id="文本居中的引用"><a href="#文本居中的引用" class="headerlink" title="文本居中的引用"></a>文本居中的引用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;</span><br><span class="line">&lt;!-- 其中 class=<span class="string">"blockquote-center"</span> 是必须的 --&gt;</span><br><span class="line">&lt;blockquote class=<span class="string">"blockquote-center"</span>&gt;blah blah blah&lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;</span><br><span class="line">&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 标签别名 --&gt;</span><br><span class="line">&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>glup 自动化构建学习笔记</title>
      <link href="/2018/11/01/web/glup/"/>
      <url>/2018/11/01/web/glup/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- **gulp.js** - 基于流的自动化构建工具。 --><blockquote><p>gulp.js 4.0以上的版本</p><footer><strong>gulp.js</strong><cite><a href="https://gulpjs.com/" target="_blank" rel="noopener">基于流的自动化构建工具</a></cite></footer></blockquote><h1 id="自动化构建工具"><a href="#自动化构建工具" class="headerlink" title="自动化构建工具"></a>自动化构建工具</h1><ul><li>ant<br>  ant是一个非常流行的自动化构建工具，类似于make，用Java编写并使用XML文件格式。</li><li>Maven<br>  它可用来做依赖管理和构建，并且主要用于Java项目。</li><li>Gradle<br>  它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，抛弃了基于XML的各种繁琐配置。</li></ul><!-- Npm Script --><h1 id="前端构建工具-webpack和browserify，gulp和grunt"><a href="#前端构建工具-webpack和browserify，gulp和grunt" class="headerlink" title="前端构建工具 webpack和browserify，gulp和grunt"></a>前端构建工具 webpack和browserify，gulp和grunt</h1><ul><li><p>webpack和<a href="http://browserify.org/" target="_blank" rel="noopener">browserify</a> 前端模块化方案<br>  预编译模块的方案<br>  webpack 是一个模块打包器。<br>  Browserify 可以让你使用类似于 node 的 require() 的方式来组织浏览器端的 Javascript 代码。</p></li><li><p>gulp和grunt 前端自动化构建的工具<br>  压缩css、js、编译less、sass等等</p></li></ul><h1 id="gulp-Api-部分，有需要再更新"><a href="#gulp-Api-部分，有需要再更新" class="headerlink" title="gulp Api (部分，有需要再更新)"></a>gulp Api (部分，有需要再更新)</h1><h2 id="gulp-task-gulp4-只支持两个参数"><a href="#gulp-task-gulp4-只支持两个参数" class="headerlink" title="gulp.task (gulp4 只支持两个参数)"></a>gulp.task (gulp4 只支持两个参数)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个参数，分别是任务名和运行任务的函数。 </span></span><br><span class="line"><span class="comment">// 也可以直接传入一个普通函数。gulp.task能把函数名转成任务名。</span></span><br><span class="line"><span class="comment">// 注意因为gulp4没有了第二个参数deps(前置依赖)，所以你懂的。</span></span><br><span class="line"><span class="comment">// default表示默认执行的任务。</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1111</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以给任务定义描述 gulp --tasks查看</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">styles</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line">styles.displayName = <span class="string">"displayName"</span>; <span class="comment">// 取一个新名字？</span></span><br><span class="line">styles.description = <span class="string">"This is so cool"</span>;</span><br><span class="line">gulp.task(styles);</span><br><span class="line"><span class="comment">// 添加描述 不能传第二个参数</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>).description = <span class="string">"Does Default Stuff"</span>;</span><br></pre></td></tr></table></figure><ul><li><p>异步任务支持</p><ul><li><strong>执行的是同步任务，在Gulp3中不需要写任何其他代码，但是在Gulp4中就不能如此轻松了：现在也你必须运行done回调。</strong></li><li><p>你执行的是异步任务，你则有三个选择来确保Gulp能够检测到你的任务真的完成了，方法如下：</p><ol><li><p>接受一个 callback</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 你可以在你的任务函数的参数中提供一个回调函数并且在你的任务完成后调用它：</span></span><br><span class="line"><span class="keyword">var</span> del = <span class="built_in">require</span>(<span class="string">'del'</span>);</span><br><span class="line">gulp.task(<span class="string">'clean'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">    del([<span class="string">'.build/'</span>], done);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// del() 会返回一个Promise对象 也就是方法三</span></span><br><span class="line">gulp.task(<span class="string">'clean'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> del([<span class="string">'.build/'</span>]); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>返回一个 stream<br> 你也可以返回一个流，通常通过gulp.src或vinyl-source-stream这个库来创建。这一般也是最常用的方式：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'somename'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'client/**/*.js'</span>)</span><br><span class="line">        .pipe(minify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'build'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>返回一个 promise</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</span><br><span class="line">gulp.task(<span class="string">'somename'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> deferred = Q.defer();</span><br><span class="line"><span class="comment">// 执行异步的操作</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    deferred.resolve();</span><br><span class="line">&#125;, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ul><h2 id="gulp-watch"><a href="#gulp-watch" class="headerlink" title="gulp.watch"></a>gulp.watch</h2><ul><li>gulp.watch(glob [, opts], tasks) 或 gulp.watch(glob [, opts, cb])</li><li>gulp.watch将像之前一样会返回一个的“观察”对象，不过你可以对它添加各种事件监听(glup3 好像只会在change时触发), 不用再使用 <a href="https://www.npmjs.com/package/gulp-watch" target="_blank" rel="noopener">gulp-watch</a> 了  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> watcher = gulp.watch(<span class="built_in">String</span> or <span class="built_in">Array</span>)</span><br><span class="line">watcher.on(<span class="string">'all/changle/add/unlink'</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'File '</span> + event.path + <span class="string">' was '</span> + event.type + <span class="string">', running tasks...'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="gulp-series-和-gulp-parallel-gulp4新增-都会返回一个函数"><a href="#gulp-series-和-gulp-parallel-gulp4新增-都会返回一个函数" class="headerlink" title="gulp.series 和 gulp.parallel (gulp4新增,都会返回一个函数)"></a>gulp.series 和 gulp.parallel (gulp4新增,都会返回一个函数)</h2><ul><li>都可以接受数个函数或任务名作为参数 (以<code>,</code>间隔起来 或者 一个数组)<br>  gulp.series会返回一个函数用来<strong>串行</strong>执行它所接受的任务/函数<br>  gulp.parallel返回的函数则会<strong>并行</strong>的运行它们</li><li>这两个的api使我们不再需要其他的第三方依赖（如：run-sequence）</li></ul><h2 id="gulp-dest"><a href="#gulp-dest" class="headerlink" title="gulp.dest"></a>gulp.dest</h2><pre><code>能被 pipe 进来，并且将会写文件。并且重新输出（emits）所有数据，因此你可以将它 pipe 到多个文件夹。如果某文件夹不存在，将会自动创建它。</code></pre><h2 id="gulp-src-globs-options"><a href="#gulp-src-globs-options" class="headerlink" title="gulp.src(globs[, options])"></a>gulp.src(globs[, options])</h2><ul><li>输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 <strong><a href="https://github.com/gulpjs/vinyl-fs" title="vinyl" target="_blank" rel="noopener">Vinyl files</a> 的 stream</strong> 它可以被 piped 到别的插件中。</li><li>globs参数<br>  类型： String 或 Array</li><li>options参数 类型： Object<br>  传递给选项的值必须是预期的类型，否则将被忽略。</li></ul><h2 id="gulp-lastRun"><a href="#gulp-lastRun" class="headerlink" title="gulp.lastRun"></a>gulp.lastRun</h2><ul><li>gulp.lastRun(name,timePrecision)<br>  name: 任务名<br>  timePrecision： 时间精度 eg: 1000/10</li></ul><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="CoffeeScript"><a href="#CoffeeScript" class="headerlink" title="CoffeeScript"></a>CoffeeScript</h2><p>CoffeeScript是一套JavaScript的转译语言,CoffeeScript 会将类似 <a href="http://www.ruby-lang.org/zh_cn/" title="Ruby" target="_blank" rel="noopener">Ruby</a> 语法的代码编译成 JavaScript，而且大部分结构都相似，但不同的是 CoffeeScript 拥有更严格的语法。<br>在gulp中使用 gulp-coffee</p><blockquote><p>参考链接: <a href="https://segmentfault.com/a/1190000005357048" target="_blank" rel="noopener">【译】相对完整的Gulp4升级指南</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人博客</title>
      <link href="/2018/10/31/blog/blog-buliding/"/>
      <url>/2018/10/31/blog/blog-buliding/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;一直想搭个博客，也可以学习一下markdown。折腾了一天终于将第一个博客搭起来了，简单记录一下这个过程。</p><h1 id="搭建博客的选择"><a href="#搭建博客的选择" class="headerlink" title="搭建博客的选择"></a>搭建博客的选择</h1><ol><li><p>选择网上流行的论坛或者社区平台</p><p> 这里列出常见的几个： <a href="https://www.jianshu.com/" title="简书" target="_blank" rel="noopener">简书</a>, <a href="https://juejin.im/" title="掘金" target="_blank" rel="noopener">掘金</a>, <a href="https://www.zhihu.com/" title="知乎" target="_blank" rel="noopener">知乎</a>,<a href="https://www.jianshu.com/" title="博客园" target="_blank" rel="noopener">博客园</a>,<a href="https://www.csdn.net/" title="CSDN" target="_blank" rel="noopener">CSDN</a>,<a href="https://segmentfault.com/" title="SegmentFault" target="_blank" rel="noopener">SegmentFault</a>等。相信这里面总有一个你见过的,我就直接进入主题吧。</p></li><li><p>选择自己搭建</p><p> 现在网上常见的几个方法：</p><ol><li><p>使用WordPress （PHP语言开发的博客平台，也可以当一个CMS来使用）搭建。 （要氪金）<br>需要配置服务器，域名，数据库等。如果你熟悉PHP和web知识可以选择这个哦。</p></li><li><p>hexo/jekyll + Github Pages/Coding Pages（氪金，不存在的！）<br>hexo和jekyll都是静态博客框架，在本地生成静态html后上传到Github或者Coding等代码托管平台。可以简单快捷搭建出一个静态博客，我就是用了hexo + Github Pages搭建的。</p></li></ol></li></ol><h1 id="Hexo-Github-Pages-博客搭建"><a href="#Hexo-Github-Pages-博客搭建" class="headerlink" title="Hexo + Github Pages 博客搭建"></a>Hexo + Github Pages 博客搭建</h1><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><ol><li><p>Hexo 官网 <a href="https://hexo.io/docs/" target="_blank" rel="noopener">https://hexo.io/docs/</a></p><p> 详细步骤请参考在<a href="https://hexo.io/docs/" title="hexo" target="_blank" rel="noopener">Hexo</a>的官网，我在这里简单描述一下几个重要的步骤。</p></li><li><p>先安装一下应用程序<br> <a href="https://nodejs.org/zh-cn/" title="node" target="_blank" rel="noopener">Node.js</a><br> <a href="https://git-scm.com/" title="Git" target="_blank" rel="noopener">Git</a></p></li><li><p>安装 hexo</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li><li><p>初始化项目</p><pre><code>$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install</code></pre></li><li><p>启动服务器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p> 打开浏览器访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 你会发现博客已在本地搭建成功。<br> 详细配置请到<a href="https://hexo.io/docs/" title="hexo" target="_blank" rel="noopener">官网</a>查看。</p></li></ol><h2 id="推送到GitHub"><a href="#推送到GitHub" class="headerlink" title="推送到GitHub"></a>推送到GitHub</h2><ol><li>首先你得要有一个<a href="https://github.com/" title="GitHub" target="_blank" rel="noopener">GitHub</a>账号，注册过程非常简单，我就不展示了。</li><li>新建一个仓库，仓库命名格式为 (你的github账号名称).github.io。<br> <img src="/asset/images/github-repo.png" alt="github-repo" title="github-repo"></li><li><p>使用ssh密钥方式推送（也可以使用https的方式）</p><ul><li><p>生成秘钥（window用户需要使用Git Bash输入），按回车三下，即生成成功。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><img src="/2018/10/31/blog/blog-buliding/2018-11-04_201852.png" title="ssh-keygen"></li><li><p>命令行输入<code>cat ~/.ssh/id_rsa.pub</code>，将显示的内容复制。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></li><li><p>添加到 github。</p>  <img src="/2018/10/31/blog/blog-buliding/setting.png" title="ssh-keygen">  <img src="/2018/10/31/blog/blog-buliding/ssh_key.png" title="ssh-keygen">  <img src="/2018/10/31/blog/blog-buliding/new.png" title="ssh-keygen">  <img src="/2018/10/31/blog/blog-buliding/add.png" title="ssh-keygen"><p>  点击Add SHH key按钮。就ok了。</p></li><li><p>测试是否成功添加。<br>  命令行输入<code>ssh git@github.com</code>。<br>  若出现<code>Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>，恭喜你，添加成功了。请跳过下面的步骤。</p><p>  若出现<code>ssh: connect to host github.com port 22: Connection refused</code>。<br>  进入用户的.ssh目录<code>cd ~/.ssh</code>(windwo用户进入<code>C:\Users\Administrator\.ssh</code>)，新建config文件<code>touch config</code><br>  输入配置信息</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host github.com  </span><br><span class="line">User 这里填写你注册时使用的邮箱  </span><br><span class="line">Hostname ssh.github.com  </span><br><span class="line">PreferredAuthentications publickey  </span><br><span class="line">IdentityFile ~/.ssh/id_rsa  </span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure></li><li><p>Hexo 部署（详细可以到hexo官网查看）<br>  安装 hexo-deployer-git。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>  修改配置（初始化目录下的_config.yml）。</p>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">    repo:</span> <span class="string">git@github.com:你的github账号名称/你的github账号名称.github.io.git</span></span><br><span class="line"><span class="attr">    branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>  推送到github上之前，不要忘记执行<code>hexo g</code>命令生成静态文件。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>  执行<code>hexo d</code>命令</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>  最后出现<code>INFO  Deploy done: git</code>，表示已经推送到github上了。</p></li></ul></li><li><p>您的Hexo博客已经搭建好啦~~ 打开浏览器输入https://你的github账号名称.github.io。</p></li><li><p>更换主题<br> 如果你想要更换主题可以到<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a>，找到你喜欢的主题。<br> 把下载的主题放到初始化目录的themes目录下，修改初始化目录的_config.yml</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="comment"># theme: landscape</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">下载的主题文件夹名称</span></span><br></pre></td></tr></table></figure><p> 执行命令</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p> 你会发现主题已经更换成功了！</p><p> 我使用的是next的主题，附上<a href="http://theme-next.iissnan.com/getting-started.html" title="next" target="_blank" rel="noopener">主题文档</a></p></li></ol><!-- 参考式链接 -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World！</title>
      <link href="/2018/10/31/index/"/>
      <url>/2018/10/31/index/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1544774900991&amp;di=469a7d238c9e1d86930ceaa98c24be2c&amp;imgtype=0&amp;src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farchive%2F4e0497372e6bad20813c84ae4588c5529c338e6a.jpg" alt="Hello World!" title="111"><br><!-- <pre></pre> --></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
